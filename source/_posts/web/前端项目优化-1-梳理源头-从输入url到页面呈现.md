---
title: 前端项目优化-1. 梳理源头-输入url到页面呈现
comments: true
mathjax: true
categories:
  - 技术帖
tags:
  - web
  - 优化
  - 追本溯源
date: 2024-03-04 22:22:22
---

## 从更高维度审视页面

作为一名合格的开发者, **要能站在用户体验角度来考虑页面性能**。我们看下面几个常见的用户体验指标:

* 页面加载时长:
  * 当用户请求一个网站时，如果在 **1 秒内看不到关键内容**，用户会产生任务被中断的感觉。
* 用户交互反馈时长:
  * 当用户点击某些按钮时，如果 **100ms 内无法响应**，用户会感受到延迟。
* Web 动画中的帧数:
  * 如果 Web 中的动画**没有达到 60fps**，用户会感受到动画的卡顿。

通常，这些指标是由一系列的复杂因素导致的。如果你要开发流畅的页面，或者诊断 Web 页面中的性能问题，那你就需要了解 URL 是怎么变成页面的，以及在这个过程中都发生了什么。

比如， 首屏的显示就涉及了 DNS、HTTP、DOM 解析、CSS 阻塞、JavaScript 阻塞等技术因素，其中一项没处理好就可能导致整个页面的延时。

## Chrome 多进程架构

首先，在开始讲解整个过程前，我们需要认识一下 Chrome 多进程架构。因为，从浏览器输入 URL 到页面渲染的整个过程都是由 Chrome 架构中的各个进程之间的配合完成。

Chrome 的多进程架构：

* **浏览器主进程**，它负责用户界面（地址栏、菜单等等）、子进程的管理（例如，进程间通信和数据传递）、存储等等
* **渲染进程**，它负责将接收到的 HTML 文档和 JavaScript 等转化为用户界面
* **网络进程**，它负责网络资源的请求，例如 HTTP请求、WebSocket 模块
* **GPU（图形处理器）进程**，它负责对 UI 界面的展示
* **插件进程**，它负责对插件的管理

## 输入 URL 到页面呈现的过程

简单来说，整个过程可以分为以下几个步骤：

1. **DNS 解析**:
   * 用户输入 URL 后，浏览器会先进行 DNS 解析，将域名解析为 IP 地址。
2. **建立 TCP 连接**:
    * 浏览器通过 IP 地址找到服务器后，会建立 TCP 连接。
3. **发送 HTTP 请求**:
    * 浏览器向服务器发送 HTTP 请求。
4. **服务器处理请求**:
    * 服务器接收到请求后，会处理请求，返回相应的数据。
5. **浏览器接收响应**:
    * 浏览器接收到响应后，会解析响应数据，生成 DOM 树。
6. **浏览器渲染页面**:
   * 浏览器解析 CSS，生成 CSSOM 树。
    * 将 DOM 树和 CSSOM 树结合成 Render 树。
    * 浏览器根据 Render 树进行页面布局和绘制。
    * 用户可以看到页面上的内容。
7. **关闭 TCP 连接**:
    * 当浏览器不再需要服务器返回的数据时，会关闭 TCP 连接。
8. **页面加载完成**:
    * 页面加载完成后，用户可以看到页面上的内容。
    * 用户可以与页面上的内容进行交互。
        * 用户可以点击页面上的链接，转到其他页面。
        * 用户可以输入表单数据，提交给服务器。
        * 用户可以执行页面上的 JavaScript 代码。

### 解析输入

发生这个过程的前提，用户**在地址栏中输入了 URL**，而地址栏会根据用户输入，做出如下判断：

* **非URL结构的字符串**，则会用浏览器默认的搜索引擎**搜索该字符串**
* **URL 结构字符串**，则会 **解析URL结构**，浏览器进程会将完整的 URL 通过IPC，**发送给网络进程**

### 通信过程

#### HTTP请求流程

##### 构建请求

首先会构建请求行，它包括：**请求方法、请求url、协议版本**

```bash
  GET /index.html HTTP1.1
```

##### 查找HTTP缓存

根据上次请求的结果，**查找缓存**，分别依据强缓存 `cache-control` / `expires` 和协商缓存 `last-modified` / `Etag` 进行判断。 如果命中缓存，会直接返回缓存数据，并直接结束请求。

* 缓解服务器端压力，提升性能（获取资源的耗时更短了）；
* 对于网站来说，缓存是实现快速资源加载的重要组成部分。

具体看 (网络协议-HTTP核心问题## HTTP 缓存)[]

##### 准备IP 和 端口

##### DNS 解析得到IP

首先，**进行 DNS 解析域名得到对应的 IP**。 DNS 解析会 经过 递归查询 客户端、系统 缓存 在到 本地 DNS 服务器，如果没有再到 遍历查询 根域名服务器、顶级域名服务器、权威 DNS 服务器。最终得到 IP 地址。

具体看 (网络协议-DNS)[]

##### 等待 TCP 队列

1. 浏览器对 TCP 连接数的限制, 超过 `6个 TCP` 链接 会进入等待队列

* 现代浏览器 为了**优化性能**和 **避免过多的并发连接对服务器造成压力**，会 限制对 **单个域名限制 6 个并发 TCP 连接**。

2. TCP 连接复用的限制

* HTTP/1.0 中，**每个请求都需要建立一个新的 TCP 连接**，连接完成后立即关闭（每次都要三次握手，四次挥手）
* HTTP/1.1 中，尽管支持持久连接（Keep-Alive），允许复用 TCP 连接，但 **每个 TCP 连接一次只能处理一个请求**
* HTTP/2 中，虽然 **支持多路复用**（一个 TCP 连接可以同时处理多个请求），但如果 **某个请求被阻塞，其他请求可能会被间接阻塞** (TCP 阻塞机制 )
* HTTP/3：基于 QUIC 协议（UDP），彻底解决了 TCP 的队头阻塞问题: 即使某个流（请求）被阻塞，其他流仍然可以继续传输，不会影响整个连接

> 如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。

##### 建立 TCP 连接

不用等待 TCP 队列后, 拿到 IP 后， 首先，建立 TCP 连接，即三次握手过程：

1. 客户端发送标有 `SYN = 1，seq = x` 的数据包，表示 将要发送请求(x 为随机数)。
2. 服务器发送标有 `SYN = 1，ACK=1, ack = x + 1，seq = y` 的数据包，表示 **已经收到通知，告知客户端发送请求**(y 为随机数)。
3. 客户端发送标有 `ACK = 1, ack = y + 1，seq = x + 1` 的数据包，表示 **确认收到服务器的响应**。

##### 进行http 通信

然后，利用 TCP 通道进行数据传输：

###### 发起 HTTP 请求

请求行
请求头
请求体（只有post请求有，get请求没有）

###### 接收 服务器处理响应

响应行：版本协议、状态码
响应头
响应体

1. 发包收包，不断重复这个过程
2. TCP 的重发机制：客户端在**发送一个数据包后，未接收到服务端的确定消息**，则**重新发送该数据包**
3. 当接收完所有的数据包后，接收端会按照 TCP 头中的需要进行排序，形成完整的数据

##### 关闭 TCP 连接

最后，断开 TCP 连接，即四次握手过程：

终止一个连接要经过 4次握手。
因为 `CP 连接是 **全双工** (即数据在两个方向上能同时传递，同时双向传输数据)， 因此**每个方向必须单独地进行关闭**` 。
这原则就是 当一方完成它的数据发送任务后，就能发送一个 FIN 来终止这个方向连接。当一端收到一个 FIN，它必须通知 应用层 另一端已经 终止了数据传送。

四次挥手过程如下：

1. 客户端发送一个 FIN，用来关闭客户端到服务器的数据传送。
2. 服务器收到这个 FIN，发送一个 ACK 给客户端，确认序号为收到的seq number + 1。
3. 服务器完成发送数据，向客户端发送一个 FIN。
4. 客户端发送一个 ACK 给服务器，确认序号为收到的seq number + 1。

### 数据处理

当网络进程接收到的响应报文状态码，进行相应的操作。

状态码为 200 OK 时，会解析响应报文中的 Content-Type 首部字段 解析 MIME 类型。
Content-Type 会出现 application/javascript、text/css、text/html，即对应 Javascript 文件、CSS 文件、HTML 文件。

### 创建渲染进程

浏览器网络线程 进行 网络通信**获取HTML代码**，然后进入**渲染主线程**的**消息队列**进行包装，得到渲染任务后，则需要创建渲染进程，用于后期渲染。
而对于渲染进程，如果是**同一站点是可以共享一个渲染进程**，例如 a.abc.com 和 c.abc.com 可以共享一个渲染渲染进程。
否则，需要重新创建渲染进程

![渲染开始时间点](/images/web_optimize/1/render_start.png)

> 需要注意的是，**同站指的是顶级域名和二级域名相等**

### 开始渲染

在创建完渲染进程后，网络进程会将接收到的 HTML、JavaScript 等数据传递给渲染进程。而在渲染进程接收完数据后，此时用户界面上会发生这几件事：

* 更新地址栏的安全状态
* 更新地址栏的 URL
* 前进后退此时 enable，显示正在加载状态
* 更新网页

### 渲染过程

大家都知道页面渲染的过程也是面试中单独会考的点，并且时常会由这个点延申出另一个问题，即如何避免回流和重绘。

![总流程](/images/web_optimize/1/render_1.png)

渲染过程，是整个从理器输入 URL 到页面渲染过程的最后一步。而页面渲染的过程可以分为 9 个步骤：

解析html-Parse HTML 生成 DOM 树
解析 CSS  生成 CSSOM
加载或执行 JavaScript
生成渲染树（Render Tree）
布局
分层-Layer
生成绘制-Paint列表
分块-Tiling
光栅化-Raster
画-Draw（合成）

#### 构建DOM树 && 解析CSS生成CSSOM

 该步骤主要生成DOM树和CSSOM树。html代码解析后生成DOM树，css代码解析后生成CSSOM树。

![构建 DOM 树](/images/web_optimize/1/render_Parse_HTML.png)

> 注意的是这个 DOM 树不同于 Chrome-devtool 中 Element 选项卡的 DOM 树，它是存在内存中的，用于提供 JavaScript 对 DOM 的操作。

在解析过程中，为了提⾼解析效率，浏览器会启动⼀个预解析器率先下载和解析 CSS。

![解析 CSS  生成 CSSOM](/images/web_optimize/1/render_Parse_HTML1_1.png)

> CSS Object Model 是一组允许用 JavaScript 操纵 CSS 的 API。详细 API 讲解可以看 MDN

#### 加载 JavaScript

通常情况下，在构建 DOM 树或 CSSOM 的同时，如果也要加载 JavaScript，会造成前者的构建的暂停。

因为JS可能会改变DOM树， 所以需要先解析，但如果声明是异步加载，那就不会暂停。当然 **预解析线程**可以分担⼀点**下载 JS 的任务**。

![渲染开始时间点](/images/web_optimize/1/render_Parse_HTML1_2.png)

> ⚠️ 可以通过 defer 或 sync 来实现异步加载 JavaScript。
> sync  ： 虽然 **可以实现异步加载 JavaScript，但是 仍然会造成阻塞**
> defer ： 则是 **等待 CSSOM 和 DOM 树构建完后才执行 JavaScript**

##### 编译和运行 JavaScript 的过程

由于 JavaScript 是解释型的语言。所以这个过程会是这样的：

* 针对每句代码进行分行处理，即 Token 化
* 根据 Token，生成 AST（Abstract Sytanx Tree） 抽象语法树和创建上下文
* 解释器解析和执行 AST，生成字节码。
* 编译器针对需要反复执行的代码，生成对应的机器码，提高运行效率

#### 生成渲染树（Render Tree）

在有了 DOM 树和 CSSOM 之后，需要将两者结合生成渲染树 Render Tree，并且这个过程会去除掉那些 display: node 的节点。此时，渲染树就具备元素和元素的样式信息。

![解析 CSS  生成 CSSOM](/images/web_optimize/1/render_Recalculate_Style.png)

#### 布局（第二次称回流）

根据 Render Tree 渲染树，对树中每个节点进行计算，确定每个节点在页面中的宽度、高度和位置。

![布局](/images/web_optimize/1/render_layout.png)

##### 布局树和可见内容是一一对应的，与 DOM树并不一定一一对应

1、**display值为none的元素**，只是不可见，**DOM树 添加**，**布局树 不添加**。

![渲染开始时间点](/images/web_optimize/1/render_layout_1.png)

2、**before伪类添加的元素**，由于不算做一个单独的元素，**DOM树 不添加**，**布局树添加**。

![渲染开始时间点](/images/web_optimize/1/render_layout_2.png)

3、浏览器在渲染过程中为了保持布局的连贯性和符合CSS规范会自动创建一些布局盒子：**匿名行盒与匿名块盒**，**DOM树 不添加**，**布局树添加**。

![渲染开始时间点](/images/web_optimize/1/render_layout_3.png)

> 需要注意的是，第一次确定节点的大小和位置的过程称为布局，而第二次才被称为**回流**

#### 分层

在现代浏览器中，为了**优化渲染性能**，渲染树被**分解成多个层**（Layers）。**每个层可以独立于其他层进行渲染和合成**，这有助于减少绘制和合成的工作量。

![渲染开始时间点](/images/web_optimize/1/render_layer.png)

  跟堆叠上下文有关的属性，会影响分层，比如 `z-index` ， `opacity` 、 `transform` 、 `filter` ，或者元素被设置为 `will-change` ，以及部分 3D 的效果、动画 和过度效果可能也会被分为新的层。[内容溢出存在滚轮的情况也会进行分层]

[告知浏览器提前优化 will-change](https://developer.mozilla.org/zh-CN/docs/Web/CSS/will-change)

> 相关拓展
> opacity属性 与 堆叠上下文有关，因为 **当元素的opacity值小于1时，它将创建一个内部的堆叠上下文**。
>
> * 这意味着，即使元素的z-index值较低，它的不透明部分仍然可以覆盖在其后面的元素的不透明部分。
> * 这可能导致一些不可预见的层叠效果，因为**元素的不透明度会影响其在堆叠上下文中的行为**。
>
> 例如，假设有两个元素A和B，A在B的上方，A的z-index值较高，但A的opacity为0.5，B的opacity为1。在这种情况下，A的不透明部分将覆盖B，但A的半透明部分将允许B的内容显示出来。这是因为A的半透明部分创建了一个内部堆叠上下文，而B的内容在这个内部堆叠上下文中显示。

##### 堆叠上下文的层级规则如下

* 根元素（通常是HTML元素）形成一个堆叠上下文。
* 定位元素（position属性为relative、absolute或fixed）可以形成新的堆叠上下文。
* 元素的z-index属性可以指定其在堆叠上下文中的层级。
* 某些CSS属性和值，如opacity、transform、filter等，可以创建新的堆叠上下文。

#### 绘制-Paint (重绘在这里)

为分层结果的**每⼀层**⽣成如何 **绘制的指令**，并不是真的绘制。
到这里**渲染主线程**的工作 就 结束了，剩下的任务交给其他线程完成。

#### 分块-Tiling

有了绘制列表后，渲染引擎中的**合成线程**会 根据 当前视口的大小 将图层进行**分块处理**。
这一步会**将每⼀层**分为**多个小的区域**。

分块的目的是对分层结果进行进一步细分，通过**只渲染用户可以看到的部分**（即视口中的部分），浏览器可以更快地完成绘制工作。
当用户**滚动页面时**，浏览器可以**丢弃不在视口中的块**，并重新绘制新进入视口的块。

此来减少内存使用，提高渲染效率，优化重绘制，改善滚动性能。

![分块-Tiling](/images/web_optimize/1/render_tiling.png)

#### 光栅化

- 光栅化: 合成线程会对**视口附近的图块生成位图**，**以此提高渲染效率**。
- 这一过程需要GPU加速 【例如使用 wil-change、opacity，就会通过 GPU 加速显示】

而渲染进程也维护了一个栅格化的线程池，专门用于将图块转为位图。

#### 画-Draw（合成）

合成线程 **计算每个位图在屏幕上的位置**，交给GPU进行最终呈现。

![画-Draw（合成）](/images/web_optimize/1/render_Draw.png)

而这个整个从绘制-Paint 阶段 生成绘制列表、光栅化、显示的过程，就是我们常说的重绘的过程

完整过程的分工情况如图：

![完整过程的分工](/images/web_optimize/1/render_all.png)

## 相关问题

1. 什么是回流/重排（reflow）？

    * reflow 的本质就是重新计算 layout 树。
    * 第一次确定节点的大小和位置，称之为布局（layout）
      * 之后对节点的大小、位置修改重新计算称之为回流
    * "重排/回流"必然导致"重绘"
      * 比如改变一个网页元素的位置，就会同时触发"重排"和"重绘"，因为布局改变了
      * 所以回流是一件很消耗性能的事情
    * 什么属性会导致回流呢？
      * `width top position..` （比如 DOM 结构发生改变 / 修改了布局）

2. 什么是重绘 （repaint）

    * repaint 的本质就是**重新根据分层信息计算了绘制指令**。
    * 当第一次渲染内容称之为绘制（paint）
      * 之后重新渲染称之为重绘
    * 重绘不会带来重新布局，所以并不一定伴随重排。
      * 浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。
    * 什么属性会导致重绘呢？
    * `color background box-shadow..` (比如修改背景色、文字颜色、边框颜色、样式等)

3. 为什么transform效率高

    因为 transform 既**不会影响布局**也**不会影响绘制指令**，它影响的只是渲染流程的最后一个「draw」阶段
    - 由于 draw 阶段在合成线程中，所以 transform 的变化几乎不会影响渲染主线程。
    - 反之，渲染主线程无论如何忙碌，也不会影响 transform 的变化。


---

## 缓存技术方案实践
1. 静态资源优化方案与思考
- 配置超长时间的本地缓存 —— 节省带宽，提高性能
- 采用内容摘要作为缓存更新依据 —— 精确的缓存控制
- 静态资源 CDN 部署 —— 优化网络请求
- 更资源发布路径实现非覆盖式发布 —— 平滑升级
2. 充分利用浏览器缓存机制
- 对于某些不需要缓存的资源，可以使用 Cache-control: no-store ，表示该资源不需要缓存
- 对于频繁变动的资源（比如经常需要刷新的首页，资讯论坛新闻类），可以使用 Cache-Control: no-cache 并配合 ETag 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新。
- 对于代码文件来说，通常使用 Cache-Control: max-age=31536000 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件。
- 静态资源文件通过 Service Worker 进行缓存控制和离线化加载

---

## 首屏加载
浏览器从响应用户输入网址地址，到首屏内容渲染完成的时间，此时整个网页不一定要全部染完成，但需要展示当前视窗需要的内容
利用 performance.timing 提供的数据
通过 DOMContentLoad 或者 performance 来计算出首屏时间
// 方案-
document.addEventListener('DoMcontentLoaded',(event)=>{
    console.log('first contentful painting');
});
// 方案二:
performance.getEntriesByName("first-contentful-paint")[0].startTime
// performance.getEntriesByName("first-contentful-paint")[θ]
//会返回一个 PerformancePaintTiming的实例，结构如下:
｛
    name:"first-contentful-paint",
    entryType:"paint",
    startTime:587.88888802123415,
    duration: 0
}｝

首屏性能优化  性能优化
（1） 减少http请求的次数：CSS Sprites，JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存，图片服务器。
（2）前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数
（3）用innerHTML代替DOM操作，减少DOM操作次数，优化JavaScript性能。
（5）少用全局变量，缓存DOM节点查找的结果。减少IO读取操作。。
1.资源加载优化
减少资源大小
  代码、图片压缩，可以利用打包工具
  对HTML、CSS、JavaScript这些文件去除冗余字符（例如不必要的注释、空格符和换行符等），再进行压缩，减小文件数据大小，加快浏览器解析文件编码。
  代码拆分
  Gzip
    1. 浏览器和服务器都需要支持gzip编码
    2. 采用 LZ77 算法与 Huffman 编码来压缩文件，是一种无损压缩算法
    3. 压缩比率在3-10倍左右（纯文本），可以大大节省服务器的网络带宽
    重复度越高的文件可压缩的空间就越大，图片的重复度是很低，不适合
    原理
    1. 浏览器请求url，并在请求头中设置属性accept-encoding: gzip。这表明该浏览器是支持gzip，该参数浏览器在请求资源时会自动带上。
    2. 服务器在接收到浏览器发送的请求之后，服务器会返回压缩后的文件，并在响应头中包含content-encoding: gzip。若是没有gzip文件，会返回为压缩的文件。
    3. 浏览器接收到服务器的响应之后，根据content-encoding: gzip响应头使用gzip策略自动解压压缩后的资源，通过content-type内容类型决定怎么编码读取该文件内容。
    应用
    前端借助构建工具，预先生成gz文件，缺点是构打包后构建的产物体积会变大，优点是不耗费服务器的性能。
    webpack安装compression-webpack-plugin
    Vite 使用vite-plugin-compression 来实现
    在 vue.congig.js 中引入并修改 webpack 配置
const CompressionPlugin=require('compression-webpack-plugin')

configurewebpack:(config)=>{
    if(process.env.NODE ENV === 'production'){
    // 为生产环境修改配置.
    config.mode ='production'
    return {
        plugins:[new CompressionPlugin({
            test:/\.js$|\.html$|\.css/，//匹配文件名
            threshold:10240，//对超过10k的数据进行压缩
            deleteoriginalAssets:false//是否网除原文件
          })]
        }
    }

//在服务器我们也要做相应的配置 如果发送请求的浏览器支持 gzip，
//Nginx 服务器配置文件中
http {
    gzip on;
    gzip_types text/plain text/css application/javascript;
}
减少HTTP请求次数
  HTTP强缓存  Expires（http1.0）和Cache-Control(http1.1
  Service Worker 离线缓存
  本地存储(合理利用 localStorage等)
  合并文件，合并请求(nginx-http-concat模块。雪碧图等)
  使Ajax可缓存。
  非必须组件延迟加载。
  未来所需组件预加载
提高http请求响应速度
  CDN 内容分发网络
  CDN服务商，网站的静态资源如图片、CSS文件、JavaScript文件等都可以缓存到CDN节点上，当用户访问网站时，CDN会根据用户的地理位置，从最近的节点提供资源，极大减少了资源加载时间。CDN还提供了缓存功能，可以进一步提高资源加载速度。
  HTTP弱缓存 last-modified 和 etag
  减少DNS查找时间
  - 减少外部资源的引用
  - 使用DNS预解析，DNS缓存将资源分布到恰当数量的主机名，平衡并行下载和DNS查询
  - 使用可靠的DNS服务提供商
  http2
  新型的网络协议，通过多路复用、头部压缩等技术，可以显著提高网络性能。通过在服务器上启用HTTP/2，可以显著提高页面加载速度，Nginx配置。
server {
    listen 443 ssl http2;
    # 其他配置
}
  提高服务器性能
  配置更高的服务器、使用SSD硬盘、增加服务器带宽
  负载均衡：将用户请求分配到多台服务器，减少单台服务器的负载，Nginx。
优化资源加载时机
  按需加载 UI框架按需加载
  懒加载，图片懒加载
   1）小图标合并成雪碧图，进而减少img的HTTP请求次数；
 2）图片加载较多时，采用懒加载的方案，滚动页面可视区时再加载渲染图片
  预加载(preload 等
优化资源、内容加载方式
  客户端内H5页可考虑离线包等方式
  内容直出
2.页面渲染优化
优化html代码
    js外链放在底部，加上时间戳
    避免阻塞页面的渲染。当浏览器遇到JavaScript文件时，会停止解析HTML，直到JavaScript文件加载完毕并执行完毕，这会导致页面渲染被阻塞。
    CSS文件应该放在HTML文档的头部
    确保在页面渲染之前，样式已经加载完毕。如果CSS文件放在底部，会导致页面在没有样式的情况下渲染，产生闪烁和白屏现象。
    减少DOM数量
优化渲染关键路径方案
   异步加载非关键资源，优化渲染关键路径，优化页面渲染性能，减少页面白屏时间。
  - 优化JS：JavaScript文件加载会阻塞DOM树的构建，可以给<script>标签添加异步属性，浏览器的HTML解析就不会被js文件阻塞。async属性表示脚本在下载完成后立即执行，而 defer 属性表示脚本在HTML解析完成后再执行。
  - 优化CSS：浏览器每次遇到<link>标签时，浏览器就需要向服务器发出请求获得CSS文件，然后才继续构建DOM树和CSSOM树，可以合并所有CSS成一个文件，减少HTTP请求，减少关键资源往返加载的时间，优化渲染速度。
优化js、css代码
  使用webworker
    为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。
  长任务分片执行
  减少重排、重绘
  降低css选择器复杂性
  当需要设置的样式很多时设置className而不是直接操作style
  避免使用CSS Expression（css表达式）又称Dynamic properties(动态属性)
优化动面效果
  使用requestAnimationFrame
  使用 transform和opacity 属性来实现动面
  合理使用wi-change战transiateZ来提升某些元素到新的合成层
使用SSR
  组件或页面通过服务器生成html字符串，再发送到浏览器
  从头搭建一个服务端渲染是很复杂的vue 应用建议使用 Nuxt.js 实现服务端渲染

---

页面卡顿定位工具  加载慢原因
原因
  - JavaScript 代码出现严重错误导致后续的脚本执行中断
  - 网络延时问题
  - 资源文件体积是否过大
  - 资源是否重复发送请求去加载了
  - 加载脚本的时候，渲染内容堵塞了
  - URL 网址无效或者含有中文字符
  - 浏览器兼容问题
https://cloud.tencent.com/developer/article/1733071
https://zhuanlan.zhihu.com/p/144934079
- 检查网络连接是否正常，尝试刷新页面或重新加载。
- 查看浏览器控制台是否有报错信息，如果有，根据报错信息进行代码修复。
- 分析网页加载过程，查看是否有资源加载失败或加载时间过长的情况，逐个排查并修复。
- 考虑使用一些工具进行网页性能分析，找出加载速度慢的原因，并进行相应的优化。
- 如果问题仍然存在，可以寻求专业的前端开发人员的帮助，进行深入的调试和修复。




## 离线包
1. 各域名下的 /app/webzip/zipVersion.json 开启允许跨域
   - 每次 新增域名 需要 对其 开启允许跨域
   - 以往都是在 s3 桶上直接配置；
   - 少部分 `app-h5部署在nodestatic目录的项目` 需要 在 node 服务中配置跨域具体参照 pro 项目
2. 离线包中使用 window.location2 代替 window.location。
   - window.location2 仅提供 location 的取值操作 （PS：如 reload 和 replace 方法 无法实现）
   - 如果需要跳转 需要使用配套方法 `window.KEWLWebZip.jump`
3. 依赖资源（例如 kewlglobal.js）更新，需要同步更新对应 zip 包
   - 需要 重新打 zip 包,来更新 对应项目的 kewlglobal.js
4. 因为替换 location，所以神策采用了本地版本 /app/js/dev/src/lib/sensorsdata.min.js
5. zip 包 关于 svga 的部分：
   - 服务端下发 -- 图床上地址： 根据接口而来，不参与 zip 打包，无需关注
   - 写死在 h5 本地，此处需要注意：
     - 必须 放在 `public`目录 或者 `assets` 目录
6. iframe 使用 url 必须使用 window.location2 拼接全路径后使用
      ```js
         const iframeUrl = `${window.location2.origin}/activity/2022/dist/nightClub/index.html?source=2`
      ```
7. 为排查 方便排查，在zip 情况时，神策上报的 url 中拼接了 zipVer=[当前zip包版本]


## CSS优化
- 内联首屏关键CSS
- 异步加载CSS
  - 使用javascript将link标签插到head标签最后
  - 设置link标签media属性为noexis，浏览器会认为当前样式表不适用当前类型，会在不阻塞页面渲染的情况下再进行下载。加载完成后，将media的值设为screen或all，从而让浏览器开始解析CSS
  - 通过rel属性将link元素标记为alternate可选样式表，也能实现浏览器异步加载。同样别忘了加载完成之后，将rel设回stylesheet
- 资源压缩  利用webpack、rollup等模块化工具，将css代码进行压缩
- 合理使用选择器
  - 不嵌套使用过多复杂选择器，最好不要三层以上
  - 使用id选择器就没必要再进行嵌套
  - 通配符和属性选择器效率最低，避免使用
- 减少使用昂贵的属性
  - 如box-shadow/border-radius/filter/透明度/:nth-child等
- 不要使用@import
  - @import会影响浏览器的并行下载，使得页面在加载时增加额外的延迟，增添了额外的往返耗时
  - 而且多个@import可能会导致下载顺序紊乱
- cssSprite，合成所有icon图片，减少了http请求，用宽高加上backgroud-position的背景图方式显现出我们要的icon图，background-repeat，background-position的组合background-image进行背景定位
- 把小的icon图片转成base64编码
- CSS3动画或者过渡尽量使用transform和opacity来实现动画，不要使用left和top属性
CSS模块化
针对问题
- 高耦合——改样式的时候，会同时影响其他地方的样式，导致意外的样式问题
- 低复用——重复编写相同的样式，即枯燥乏味又导致 CSS 体积过大，从而影响开发体验与页面加载体验
https://segmentfault.com/a/1190000039772466






## 如果某个页面有几百个函数需要执行，可以怎么优化页面的性能?
1. 异步执行:将函数调用转换为异步操作，使用setTimeout或requestAnimationFrame 等方法将函数分散到多个时间片中执行。这样可以避免一次性执行大量函数造成的阻塞。
2. 分批处理:将函数分批执行，而不是一次性执行所有函数。可以使用循环和计数器来控制每个批次的函数数量，并在每个批次之间添加适当的延迟，以确保主线程有足够的空闲时间处理其他任务。
3. Web Worker:将函数放入Web Worker中执行，以在后台线程中进行计算，避免阻塞主线程。Web Worker可以独立于主线程运行，并发出消息来与主线程通食
4. 函数优化:检查需要执行的函数是否可以进行优化，例如减少计算量、缓存结果、避免重复计算等。通过优化单个函数的执行效率，可以减少整体执行的时间和资源消耗
5. 任务调度库:使用第三方任务调度库，如 async.js 或 p-queue 等，来管理并行执行和限制同时执行的函数数量。这些库提供了更灵活的任务管理和控制，可以根据需求进行配置和调整。


## 列表有 100000 个数据，这个该怎么进行展示?
我们需要思考的问题:该处理是否必须同步完成? 数据是否必须按顺序完成?
1. 将数据分页，利用分页的原理，每次服务器端只返回一定数目的数据，浏览器每次只对一部分进行加载，
2. 使用懒加载的方法，每次加载一部分数据，其余数据当需要使用时再去加载
3. 使用数组分块技术，基本思路是为要处理的项目创建一个队列，然后设置定时器每过一段时间取出一部分数据，然后再使用定时器取出下一个要处理的项目进行处理，接着再设置另一个定时器。
4. 虚拟列表，每次只渲染需要视口的部分
  Vue 的响应性系统默认是深度的。虽然这让状态管理变得更直观，但在数据量巨大时，深度响应性也会导致不小的性能负担，因为每个属性访问都将触发代理的依赖追踪。
  Vue 确实也为此提供了一种解决方案，通过使用 shallowRef() 和 shallowReactive() 来绕开深度响应。浅层式 API 创建的状态只在其顶层是响应式的，对所有深层的对象不会做任何处理。这使得对深层级属性的访问变得更快，但代价是，我们现在必须将所有深层级对象视为不可变的，并且只能通过替换整个根状态来触发更新
```js
const shallowArray = shallowRef([
  /* 巨大的列表，里面包含深层的对象 */
])

// 这不会触发更新...
shallowArray.value.push(newObject)
// 这才会触发更新
shallowArray.value = [...shallowArray.value, newObject]

// 这不会触发更新...
shallowArray.value[0].foo = 1
// 这才会触发更新
shallowArray.value = [
  {
    ...shallowArray.value[0],
    foo: 1
  },
  ...shallowArray.value.slice(1)
]

```