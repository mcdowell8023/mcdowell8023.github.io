{"meta":{"title":"mcdowell博客","subtitle":"博客+笔记","description":"javascript/vue/react/node OR 其他 笔记帖以及日常磨叨","author":"mcdowell","url":"http://mcdowell8023.github.io"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2019-08-30T09:38:03.620Z","updated":"2019-08-30T09:38:03.620Z","comments":false,"path":"/404.html","permalink":"http://mcdowell8023.github.io//404.html","excerpt":"","text":""},{"title":"关于","date":"2020-03-31T01:34:44.107Z","updated":"2020-03-31T01:34:44.107Z","comments":false,"path":"about/index.html","permalink":"http://mcdowell8023.github.io/about/index.html","excerpt":"","text":"123456789101112131415161718192021222324252627// initlet me = nullconst timeAxis = ['1991', '2013', '2016', '2017', 'today']const person = function(name, sex) &#123; return &#123; name: name, sex: sex &#125;&#125;// thentimeAxis.map(year =&gt; &#123; if (year === '1991') &#123; me = new person('mcdowell', 'male') &#125; if (year === '2013') &#123; me.college = '邯郸学院' &#125; if (year === '2016') &#123; me.job = 'coder' me.skills = ['html', 'css', 'js', 'JQ'] &#125; if (year === '2017') &#123; me.skills = [...me.skills, 'react', 'vue'] &#125;&#125;)// checkconsole.log(me, '个人简介')"},{"title":"书单","date":"2019-08-30T09:38:03.622Z","updated":"2019-08-30T09:38:03.622Z","comments":false,"path":"books/index.html","permalink":"http://mcdowell8023.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-08-30T09:38:03.622Z","updated":"2019-08-30T09:38:03.622Z","comments":false,"path":"categories/index.html","permalink":"http://mcdowell8023.github.io/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2019-08-30T09:38:03.622Z","updated":"2019-08-30T09:38:03.622Z","comments":false,"path":"repository/index.html","permalink":"http://mcdowell8023.github.io/repository/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-08-30T09:38:03.622Z","updated":"2019-08-30T09:38:03.622Z","comments":true,"path":"links/index.html","permalink":"http://mcdowell8023.github.io/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-08-30T09:38:03.623Z","updated":"2019-08-30T09:38:03.623Z","comments":false,"path":"tags/index.html","permalink":"http://mcdowell8023.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"web移动端调试笔记","slug":"web移动端调试笔记","date":"2020-04-22T08:26:08.000Z","updated":"2020-04-23T02:11:22.410Z","comments":true,"path":"2020/04/22/web移动端调试笔记/","link":"","permalink":"http://mcdowell8023.github.io/2020/04/22/web移动端调试笔记/","excerpt":"","text":"常见的几种调试方式Chrome Develop Tool 调试 ：无须额外的成本，方便快捷。但是，真机器和模拟还是不一样的(vConsole 调试)[https://github.com/Tencent/vConsole],使用简单，方便，就是 UI 界面，和 websock 问题，很头疼苹果调试套装 ：IOS Safari + Mac OS Safari 配合调试 （以下重点说明）安卓调试套装 ：Android Chrome + 桌面 Chrome 配合调试（以下重点说明） IOS Safari + Mac OS Safari 配合调试 设置手机设置: 设置 -&gt; Safari -&gt; 高级 -&gt; Web 检查器mac 电脑 设置： Safari 启用开发菜单：选择偏好设置 -&gt; 高级 -&gt; 在菜单栏中显示’开发’菜单命令 调试设备与计算机通过数据线连接,手机打开要调试的页面在 Safari 菜单：开发 -&gt; iphone-&gt; 要调试的页面可以愉快调试了 Android Chrome + 桌面 Chrome 配合调试手机端：开启开发者 -&gt; usb 调试, 用数据线连接至电脑【 你也可以通过 adb 无线调试方式进行连接 】手机端：安装装谷歌浏览器，并打开打开控制台，更多 -&gt; More tools -&gt; Remote devices 【 直接 地址栏 输入 Chrome://inspect 】最早在谷歌 75 时候，我是可以直接见到 调试控制 DevTools 页面，更显版本后发现有些不一样。谷歌版本&gt;= 81 你可能会碰到，Remote devices 栏中显示 如下： 12345This panel has been deprecated in favor of the chrome://inspect/#devices interface,which has equivalent functionality/* 直译： 此面板已被弃用，取而代之的是 chrome://inspect/#devices 接口，它具有同等的功能*/ 此时我们可以直接地址栏 输入 `chrome://inspect/#devices` 直接进入 DevTools 页面 找到 RemoteTarget 下 调试设备名称下面，输入 url 地址 open 后（会见到手机打开对应页面），下面会显示对应手机浏览器页签，点击 inspect正常情况下你会见到弹窗 显示手机页面和控制台，就可以进行调试了当地 5 步 出现弹窗，你有可能 会碰到 404 或者白页面。别急，打开你的 翻墙，或是 下载离线包具体看这里 Android 通过 Chrome Inspect 调试 WebView 的 H5 App 出现空白页面的解决方法（不需要 FQ） 关于无线连接方式ADB 无线模式调试 具体可以看我的文章 使用 scrcpy 连接安卓手机进行投屏演示 里的无线连接打开开发者模式，插线，保证同一网络插上 USB 线，开启 USB 连接，adb usb检查插上的设备，adb devices开启手机服务： adb tcpip 5555（PS：5555 是端口号，可以随意地指定）拔掉数据线，关于手机 找手机 ip 地址 adb connect 10.0.1.50:5555 [端口可以缺省，需要与 4 一致，默认 5555] # 返回 connected to 10.0.1.50 就表示成功","categories":[{"name":"工具","slug":"工具","permalink":"http://mcdowell8023.github.io/categories/工具/"}],"tags":[{"name":"web移动端","slug":"web移动端","permalink":"http://mcdowell8023.github.io/tags/web移动端/"},{"name":"调试","slug":"调试","permalink":"http://mcdowell8023.github.io/tags/调试/"}]},{"title":"zshell--从不小心切换开始","slug":"zshell-从不小心切换开始","date":"2020-04-22T03:48:55.000Z","updated":"2020-04-22T08:27:01.478Z","comments":true,"path":"2020/04/22/zshell-从不小心切换开始/","link":"","permalink":"http://mcdowell8023.github.io/2020/04/22/zshell-从不小心切换开始/","excerpt":"","text":"每次在 mac 中 打开 iTerm, 提示：123The default interactive shell is now zsh.To update your account to use zsh, please run `chsh -s /bin/zsh`.For more details, please visit https://support.apple.com/kb/HT208050.手贱，执行了chsh -s /bin/zsh【其实我都不知道 zeshell 是啥 🤦‍♂️】然后 adb connect 设备的 时候，adb 找不到了！！！🤦‍♂️🤦‍♂️🤦‍♂️查了一圈，终于有了了解，记录下。 关于 shellShell 是 Linux/Unix 的一个外壳，你理解成衣服也行。它负责外界与 Linux 内核的交互，接收用户或其他应用程序的命令，然后把这些命令转化成内核能理解的语言，传给内核，内核是真正干活的，干完之后再把结果返回用户或应用程序。那么关于切换 shell12345678# 查看 电脑几种 shellcat /etc/shells# 切换 shell# 切换成 Zshellchsh -s /bin/zsh# 切换成 bashchsh -s /bin/bash 回到最初问题仔细想来，其实就是环境变量问题，上面之所以提示找不到，无非 是 zshell 的环境变量没有配置 adb 需要去配置其实到这里，我仅仅为了使用 adb 切换回去 继续使用 bash 就好，但是： 好奇啊，那么继续 关于 ZshellShell 是在程序员与服务器间建立一个桥梁，它对外提供一系列命令，让我们得以控制服务器。常用的 Bash 就是 Shell 的一种，也是 Linux 下默认 Shell 程序。Zsh 属于 Shell 中的一种，但比 Bash 好用，而且完全兼容 Bash，拥有及其丰富的插件、强大的自动补全能力、以及自定义功能、代码高亮，可以大大提供我们使用 Linux 的效率。因为 Z 是最后一个字母，因此大家称之为——终极 Shell。 安装 Zshmac 跳过， 【系统已经默认安装好了】Redhat Linux，执行：sudo yum install zshUbuntu Linux，执行：sudo apt-get install zshwindows , 洗洗睡吧 👋 安装 on-my-zshZsh 虽然好用，但直接用起来比较麻烦，这就是为啥初期用的人少，后台有个大神，把 Zsh 的配置弄得相当简单 ：(ohmyzsh)[https://github.com/robbyrussell/oh-my-zsh]; 我们就借助 on-my-zsh 进行配置。 自动安装1wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O - | sh 手动安装克隆项目 git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh创建.zshrc 配置文件 cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc切换 zsh chsh -s /bin/zsh (如果你还没有切换的话)查看 zsh 版本 zsh --version有人说 还 需要 更新配置 source ~/.zshrc ,但是我实际是从新打开 iTerm 就看到 shell 的变化了，代码高亮… 配置 主题.zshrc 配置文件 中 默认主题 是 robbyrussell1ZSH_THEME=\"robbyrussell\" # 更换主题名称即可更多主题 插件.zshrc 配置文件 中 plugins=(git) 即时配置插件位置【默认支持 git】如果 mac 为例 增加 autojump安装 brew install autojump配置 增加12plugins=(git autojump)[[ -s ~/.autojump/etc/profile.d/autojump.sh ]] &amp;&amp; . ~/.autojump/etc/profile.d/autojump.sh关于 autojump，他是快捷跳转 你历史目录。比如， 先 cd /projcet/lanjiang/dist ,才可以 j lanjiang 更多作为一个 前端程序员 ，显然没有运维和服务端人员 shell 玩的溜。能了解的有限可以戳终极 Shell——ZSH zshell 配置 adb说会最开始碰到的问题，修正 zshell 环境变量其实 ，打开 bash 的配置 .bash_profile 对照添加到 .zshrc，然后重启就是了。我的配置。12345678910# 用户配置export ANDROID_HOME=$HOME/Library/Android/sdkexport PATH=$PATH:$ANDROID_HOME/toolsexport PATH=$PATH:$ANDROID_HOME/tools/binexport PATH=$PATH:$ANDROID_HOME/platform-toolsexport PATH=$PATH:$ANDROID_HOME/emulatorexport NVM_DIR=\"/Users/mcdowell/.nvm\"[ -s \"$NVM_DIR/nvm.sh\" ] &amp;&amp; \\. \"$NVM_DIR/nvm.sh\" # This loads nvm重启 iTerm adb version ,不会在报找不到 adb 了 为啥重启，不用 source .zshrc每次 zsh 启动都会读取这个 .zshrc 配置文件，所以我们可以把环境变量的配置信息放到这个配置文件中，这样每次启动 zsh 的时候，就会执行一次环境变量配置信息。而 bash 修改 配置环境变量后， 必须 倒入环境变量配置文件source .bash_profile 才可以生效。zsh 与 bash 设置环境变量的不同点","categories":[{"name":"工具","slug":"工具","permalink":"http://mcdowell8023.github.io/categories/工具/"}],"tags":[{"name":"zsh","slug":"zsh","permalink":"http://mcdowell8023.github.io/tags/zsh/"},{"name":"bash","slug":"bash","permalink":"http://mcdowell8023.github.io/tags/bash/"},{"name":"adb","slug":"adb","permalink":"http://mcdowell8023.github.io/tags/adb/"}]},{"title":"使用scrcpy连接安卓手机进行投屏演示","slug":"使用scrcpy连接安卓手机进行投屏演示","date":"2020-04-01T07:40:35.000Z","updated":"2020-04-23T01:30:43.158Z","comments":true,"path":"2020/04/01/使用scrcpy连接安卓手机进行投屏演示/","link":"","permalink":"http://mcdowell8023.github.io/2020/04/01/使用scrcpy连接安卓手机进行投屏演示/","excerpt":"","text":"需要演示？手机投屏到电脑上？快快使用 scrcpy 远程显示/控制 Android 手机scrcpy-github 安装要求 Android 5.0 以上，电脑安装 adb，手机启用 adb 调试，开发者模式 windowsscrcpy-win64-v1.12.1.zip macOS12brew install scrcpybrew cask install android-platform-tools # 如果 有了adb 不需要安装 使用github scrcpy mac 启动12345# 启动scrcpy# 帮助scrcpy --help windows 启动1234# 先进到对应目录cd /d d:scrcpy-win64adb connect 172.16.4.37:5555:11330scrcpy.exe -s 10.0.1.158:5555 -m 720 使用 USB 线连接在手机上启用 USB 调试adb devices 此时可以看到自己的设备。scrcpy 即可看到 手机屏幕投射到 电脑control + c 退出无法看到自己设备时，查看手机 USB 调试是否打开；PC 端是否安装手机驱动。 windos需要先进入 使用无线 WiFi 连接 ADB 无线模式调试打开开发者模式，插线，保证同一网络插上 USB 线，开启 USB 连接，adb usb检查插上的设备，adb devices开启手机服务： adb tcpip 5555（PS：5555 是端口号，可以随意地指定）拔掉数据线，关于手机 找手机 ip 地址adb connect 10.0.1.50:5555 [端口可以缺省，需要与 4 一致，默认 5555] # 返回 connected to 10.0.1.50 就表示成功scrcpy -s 10.0.1.50:5555 -m 720 # 启动 10.0.1.50:5555 的设备 以 720 分辨率 显示【分辨率越大，越卡】据说，你的手机设备每次重启后，你可能需要重复 1-6 【 🥱 好在我的手机一般不重启 】 安卓手机连接命令123456// 进入对象ip 手机 shell 命令adb -s 10.0.1.50 shell# 进入 adb shell 命令// 查看手机日志logcat ｜ grep 'TAG'# 过滤 TAG 日志","categories":[{"name":"工具","slug":"工具","permalink":"http://mcdowell8023.github.io/categories/工具/"}],"tags":[{"name":"调试","slug":"调试","permalink":"http://mcdowell8023.github.io/tags/调试/"},{"name":"安卓","slug":"安卓","permalink":"http://mcdowell8023.github.io/tags/安卓/"}]},{"title":"JavaScript从头来2.1-数据类型","slug":"JavaScript从头来2.1-数据类型","date":"2020-03-28T22:47:24.000Z","updated":"2020-04-22T08:23:17.218Z","comments":true,"path":"2020/03/29/JavaScript从头来2.1-数据类型/","link":"","permalink":"http://mcdowell8023.github.io/2020/03/29/JavaScript从头来2.1-数据类型/","excerpt":"","text":"本篇 是 JavaScript 从头来 的第二篇。数据类型，在面试中经常问到。 判断数据类型也是日常开发中的常见操作。由此可见，数据类型是多么重要。 数据类型 ECMAscript 的数据类型 简单的数据类型（基本数据类型）【7 种】1234字符串型、数值型、布尔型、null型、undefined型、 Symbol型、BigInt型// Symbol 是 ES6 引入了一种新的原始数据类型，表示独一无二的值// BigInt 也是 新增类型 用于表示比较大的 正数// 后两种为ES6新增类型 放在最后说 复杂数据类型（引用类型）【1 种】123Objecet类型 // 本质由一组无序的名值队组成// 几种基本数据类型以外的都被称为 Objecet 【 其实是个合集，并不单纯指 &#123;&#125; 】// Array、Function 属于 object 类型ECMAscript 数据类型具有动态性【弱类型】【 变量可以从一个类型变成另外的类型，不存在变量类型的概念 】基本数据类型 的 实例 被称作《值》，Object 类型的实例 被称为 《对象》。 字符串 字符串字面量（字符串型）字符串 类型由零个或者多个 16 位 Unicode 字符 组成的字符序列。''、&quot;&quot; 单引号、双引号均可。 转译序列【用于表示非打印字符、或者具有其他用途的字符】字面量含义\\0空字符\\ ’单引号\\ &quot;双引号\\ \\反斜杠\\n换行(LF) 【将光标“垂直”移动到下一行，而并不移动到下一行的开头】\\r回车(CR)【将光标移动到当前行的开头】\\v垂直制表符\\t水平制表符 【缩进】\\b退格\\f换页\\xXX用十六进制代码表示 一个字符 如： \\x42 表示 字符 B\\uXXXX用十六进制代码表示 一个 Unicode 字符 如： \\u03a3 表示 Σ 字符串的运算字符串一旦创建无法改变、修改变量的字符串需要采取覆盖方式 var str ='qwer'; str = str+'000';使用 + 、+= 进行拼接长字符串拼接普通拼接12345678910111213// 使用 + 进行拼接let longString = 'This is a very long string which needs ' + 'to wrap across multiple lines because ' + 'otherwise my code is unreadable.'longString += '还可使用+=方式'// 使用 \\ 连接let longString = 'This is a very long string which needs \\to wrap across multiple lines because \\otherwise my code is unreadable.'ES6 新增 模版字符串12var name = 'mcdowell'console.log(`hi!$&#123;name&#125;`) // hi!mcdowell字符串的比较123456789101112131415161718var str1 = '0'var str2 = '22'var num = str1 + str2 - 0 // 一种从从 字符串转 换为 数字 的方式var str3 = str1 + str2console.log(str1 == str2) // falseconsole.log(str1 === str2) // falseconsole.log(str3 == num) // trueconsole.log(str3 === num) // falsevar name1 = 'jack'var name2 = 'mcdowell'var name3 = '张三'var name4 = '李四'console.log(name2 &gt;= name1) // trueconsole.log(name2 &lt; name1) // falseconsole.log(name2 &gt; name3) // falseconsole.log(name3 &lt; name4) // true比较运算基于 Unicode 字符的编码值（编码位置）【实际中只有英语单词的比较是有意义的】英文字母是字典序（abc 顺序）英文字母的大写 排在小写字母前字符串 比较第一个字符数字和符号在英文字母之前（个别符号在字母之后）中文字符情况更为复杂，基于 《康熙字典》的部首顺序及壁画顺序进行排序的 字符串类（String 类） 字符串对象String 类 其实就是 String() 方法，我们可以借助 new【 构造函数调用 】 进行实例化 得到 字符串对象123var stringObject = new String('123') // 生成字符串对象 也就是装箱操作typeOf stringObject // objectvar stringValue = stringObject.valueOf() // 得到字符串对象的值 也就是拆箱操作装箱: 把基本数据类型转换为对应的引用类型的操作称为装箱，把引用类型转换为基本的数据类型称为拆箱拆箱: 将引用类型对象转换为对应的值类型对象，它是通过引用类型的 valueOf()或者 toString()方法来实现的。如果是自定义的对象，你也可以自定义它的 valueOf()/tostring()方法，实现对这个对象的拆箱。摘自：javascript 中的装箱和拆箱操作 字符串型 与 String 类 进行的隐式转换字符串型 与 String 类 之间存在隐式转换，即 从 字符串型到 String 类 是 装箱操作，从 String 类 到 字符串型 是拆箱操作。123456789'123'.length // 3 要得到字符串的长度，其实是先进行了 隐式转换 装箱操作 才得到的结果// '123'其实只是字面量，他自己本身是没有 length 的方法。那么 实际是如何运行的呢// 字符串 ‘123’ 将会先被隐式转换 成 字符串对象var stringObject = new String('123') // 生成字符串对象 也就是装箱操作// 然后 读取 字符串对象 下的 lengthstringObject.length // 3typeof stringObject 通过 ‘+’ 进行隐式转换12345678var stringObject = new String('123') // 生成字符串对象 也就是装箱操作stringObject + '789' // '123789' 把 字符串对象 进行 隐式转换// 常见使用的隐式转换456 + '' // '456'// 过程 =&gt; new String(456).valueOf() + '' // 把 字符串对象 进行 隐式转换(valueOf()) 后进行拼接 字符串与字符串对象123456789101112var str1 = new String('abc')var str2 = new String('abc')str1 == 'abc' // truestr2 == 'abc' // true 在左右两边类型不想等时候，会进行隐式转换成（调用对象的的 valueOf）变成字符串 后进行比较str2 === 'abc' // false 类型不一样str1 == str2 // false == 虽然字符串相等，但是并非引用了同一个对象， 所以是falsestr1 === str2 // false == 虽然字符串相等，但是并非引用了同一个对象， 所以是false// 实际中不推荐 这样使用str1 + '' == str2 + '' // truestr1 + '' === str2 + '' // true为了避免 字符串 与 字符串对象 混用，造成混乱，使用字符串隐式转换即可满足日常 字符串类 的方法建议在控制台中输入 new String() 得到 String 进行属性查看，同步理解 函数或者构造函数String(value) : 将参数转换为字符串类型new String(value) : 得到一个 Sting 实例 属性fromCharCode([char0,…]): 可接受一个指定的 Unicode 值，然后返回一个字符串[只接受 Unicode 的数字]; String.fromCharCode(72,69,76,76,79)// HELLOlength: 值为 1prototype: 用于原型链 prototype 对象所具有的部分属性字面量含义String.prototype.charAt(pos)返回下标 pos 对应位置的 的长度为 1 的字符串，从 0 开始，如果超过了，返回空字符串String.prototype.charCodeAt(pos)返回下标 pos 对应位置 字符 编码，如果超过了下标范围，返回 NANString.prototype.concat([str，...])和参数字符串连接后返回新的字符串String.prototype.endsWith(endStr)用来判断 字符串 是否是以 endStr 结尾，返回 true 或 false ｜String.prototype.includes(str,start=0)根据第一个参数查找字符串，根据情况返回 true 或 false；第二个参数，指定检索开始位置，可不传，默认 0String.prototype.indexOf(str,start=0)根据第一个参数查找字符串，返回下标，如果没有返回-1；第二个参数，指定检索开始位置，可不传，默认 0String.prototype.lastIndexOf(searchValue[, fromIndex])从尾到头地检索字符串，看它是否含有子串 searchValue,返回对应的 index,找不到返回-1， 从 fromIndex 位开始 向左（向开始位） 查找 字符串 【区分大小写】String.prototype.localeCompare()用于字符串比较，用本地特定的顺序来比较两个字符串。如果 stringObject 大于 target，则该方法返回大于 0 的数。stringObject.localeCompare(target) // 如果两个字符串相等，或根据本地排序规则没有区别，该方法返回 0。String.prototype.match(regexp)返回匹配正则表达式 regexp 的结果String.prototype.matchAll()方法返回一个包含所有匹配正则表达式的结果及分组捕获组的迭代器String.prototype.padEnd(length,str)用 str 从末尾 填充字符串到指定长度[如果填充长度小于当前长度，不进行填充]String.prototype.padStart(length,str)用 str 从头 填充字符串到指定长度[如果填充长度小于当前长度，不进行填充]String.prototype.repeat(count)重复 count（正整数） 次返回 字符出副本[-1:报错，1：不重复，2:重复两次。。。]String.prototype.replace(searchValue,replaceValue)将 searchValue（正则表达式或者字符串值）替换为 replaceValue（字符串或者函数）后返回经过替换后的字符串String.prototype.search(regexp)返回匹配正则表达式 regexp 的位置的下标String.prototype.slice(start，end)将参数 start 开始至 end 结束的字符串部分作为新的字符串值返回。如果 start 和 end 是负数，则返回从末尾逆向起数的下标值。String.prototype.split(separator,howmany)依据 separator 字符串或正则表达式 进行分割为数组，howmany 小于数组 length 按 howmany 返回对应长度数组，超过 length 返回 lengthString.prototype.startsWith(str,start)判断当前字符串是否以另外一个给定的子字符串开头，并根据判断结果返回 true 或 false。 start:从 start 位开始String.prototype.substring(indexStart[, indexEnd])返回一个截取 开始索引 到 结束索引的字符串, indexStart：需要截取的第一个字符的索引（包含位）。indexEnd：可选。一个 0 到字符串长度之间的整数（不包含）。String.prototype.toLowerCase()将字符串转为小写String.prototype.toString()返回指定对象的字符串形式String.prototype.toUpperCase()返回大写字符串String.prototype.trim()去除字符串的头尾空格String.prototype.trimEnd()去除字符串的尾部空格 trimRight 是别名String.prototype.trimStart()去除字符串的头部空格 trimLeft 是别名String.prototype.valueOf()返回对象的原始值 数据类型的判断 typeof 操作符typeof 是检测数据类型的，返回 操作数类型 的字符串‘undefined’ – 未定义‘boolean’ – 布尔值‘string’ – 字符串‘number’ – 数值‘function’ – 函数‘object’ – 对象或者 null [ null 被认为是 空对象的引用 ]技术角度说，函数不是一种数据类型，是对象，但是函数有一些特殊属性。因此需要 将函数 与对象区分开123456789typeof true // \"boolean\"typeof &#123;&#125; // \"object\"typeof typeof 11 // \"string\"typeof function () &#123;&#125; // \"function\" -- 由于特殊考虑，确实需要将function 与 object区分开来typeof [1, 2, 3] // \"object\" -- 可是数组 不如你所预想的那样typeof /abc/g // \"object\"typeof new RegExp('meow') // \"object\" -- 遇到检测数组的同样问题正如你看到的，typeof 返回的，不一定都是你想看到的。【因为 array、正则表达式、函数等，除了原始值，都是对象】 对象的类定义其实我们要的，是检测对象的 的内部属性 [[Class]] 的值 （对象的 类定义）；JavaScript 标准文档中定义: [[Class]] 的值只可能是下面字符串中的一个： Arguments, Array, Boolean, Date, Error, Function, JSON, Math, Number, Object, RegExp, String.为了获取对象的 [[Class]]，我们需要使用定义在 Object.prototype 上的方法 toString。123456789101112131415161718Object.prototype.toString.call([]) // \"[object Array]\"Object.prototype.toString.call(&#123;&#125;) // \"[object Object]\"Object.prototype.toString.call(4) // \"[object Number]\"// 高级浏览器表现Object.prototype.toString.call(null) // \"[object Null]\"Object.prototype.toString.call(undefined) // \"[object Undefined]\"// IE8Object.prototype.toString.call(null) // \"[object Object]\"Object.prototype.toString.call(undefined) // \"[object Object]\"// 通用方法 通常不对null undefined 进行判断function is(type, obj) &#123; var clas = Object.prototype.toString.call(obj).slice(8, -1) return obj !== undefined &amp;&amp; obj !== null &amp;&amp; clas === type&#125;is('String', 'test') // trueis('String', new String('test')) // true敲黑板辨别到底是不是数组的方法 ：使用 Array.isArray 或者 Object.prototype.toString.call 方法那么为什么是 Object.prototype.toString 而不是直接使用 toString 方法。因为，array 、date 等 对象都是派生自 Object,对其进行实例化的时候，已经改写了 toString 方法。参考 1：typeof 和 instanceOf 的区别参考 2：为什么用 Object.prototype.toString.call(obj)检测对象类型?","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://mcdowell8023.github.io/categories/基础知识/"}],"tags":[{"name":"js基础","slug":"js基础","permalink":"http://mcdowell8023.github.io/tags/js基础/"},{"name":"追本溯源","slug":"追本溯源","permalink":"http://mcdowell8023.github.io/tags/追本溯源/"},{"name":"笔记","slug":"笔记","permalink":"http://mcdowell8023.github.io/tags/笔记/"}]},{"title":"JavaScript从头来1-基本概念","slug":"JavaScript从头来1-基本概念","date":"2020-03-26T22:47:24.000Z","updated":"2020-04-22T08:23:11.612Z","comments":true,"path":"2020/03/27/JavaScript从头来1-基本概念/","link":"","permalink":"http://mcdowell8023.github.io/2020/03/27/JavaScript从头来1-基本概念/","excerpt":"","text":"经常在开发中，发现自己知识盲区。其实还是基础不牢固。所以一直想，抽时间从新走下，查漏补缺。 javascript 简介 特点解释型语言类似于 c 和 java 的语法结构动态语言基于原型的面向对象字面量的表现能力函数式编程 JavaScript 组成浏览器客户端 :核心（ECMAScript）+ 文档对象模型（DOM）+ 浏览器对象模型（BOM）服务端：核心（ECMAScript）+ 内置宿主对象ECMAScript 与浏览器没有依赖关系（本身不包含输入、输出定义）。ECMA-262 定义的是语言基础，可以在此基础上构建完善的脚本语言。具体包含【语法、类型、语句、关键字、保留字、操作符、对象】 区分大小写变量、函数名、操作符都区分大小写 标识符标识符指变量、函数、属性的名字、或者函数的参数。组合规则：第一个字符必须是字母、下划线（_）、或者美元( $ )其他字母可以是字母、下划线、美元或者数字驼峰写法： 第一个字母小写 剩下的每个单词首字母大写 严格模式头部添加' use strict '，表示在严格模式下的执行。严格执行模式下，执行结果会有很大不同。支持浏览器：IE10+、Firefox4+、Safari5.1+、Opera12+、Chrome 语句每条语句，分号结尾（;）【 现代项目架构中，不加分号是编译后，统一由脚手架添加 】。使用花括号 （{}）进行代码块分割，明确意图，降低出错情况。 关键字和保留字就有特殊用途的–关键字，如：void break return do case else new var ... 预留的不能用作特殊字符的保留字，如：boolean float native init short ... 变量ECMAscript 变量是非常松散的（可以保存任何**类型**的数据）。每个变量仅仅只是一个用于存值的占位符。1234567891011121314151617181920212223// 操作符（关键字） + 变量名var clock // 变量值是： undefinedvar count = 1 // 变量值是： 1 【 等于： var count = undefined； count = 1; 】先声明 后负值dfunction test() &#123; num = 1 // 有意 忽略 var 关键字，的确可以在局部作用域创建一个全局变量。 // 但是不推荐这样使用会导致， 造成不必要的混乱 var isShow = true // 局部变量 console.log(count) // 1 count 是个全局变量&#125;test()console.log(isShow) // 错误 : isShow is not defined 因为 局部变量 无法访问console.log(clockName) // undefined： 变量提升【只会提升变了声明 ，不回提升负值】var clockName = 'littleClock'// 批量var message = 'hi', found = false, age = 29关于 变量、常量、字面两：变量、常量是引用，变量值可变，常量值固定。字面量是值","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://mcdowell8023.github.io/categories/基础知识/"}],"tags":[{"name":"js基础","slug":"js基础","permalink":"http://mcdowell8023.github.io/tags/js基础/"},{"name":"追本溯源","slug":"追本溯源","permalink":"http://mcdowell8023.github.io/tags/追本溯源/"},{"name":"笔记","slug":"笔记","permalink":"http://mcdowell8023.github.io/tags/笔记/"}]},{"title":"vue项目调整兼容IE8+","slug":"vue项目调整兼容IE8+","date":"2019-11-28T06:29:00.000Z","updated":"2020-03-29T10:03:45.659Z","comments":true,"path":"2019/11/28/vue项目调整兼容IE8+/","link":"","permalink":"http://mcdowell8023.github.io/2019/11/28/vue项目调整兼容IE8+/","excerpt":"","text":"记一次，vue 项目调整兼容 IE8+ 要点flex 样式兼容element UI 部分组件兼容 详细 交代说明公司项目开发接近收尾,突然硬性要求兼容 ie9。项目搭建时，采用 vue2.6 + elementUI + axios,使用大量 es6 语法（Promise），和 flex 布局。 需要面临的问题elementUI 针对 IE 部分存在兼容问题axios 针对 IE 下返回表现不同flex 只支持到 IE10Promise IE 系（不含除去 Edge） 不支持 基本兼容垫片babel-polyfill1npm install --save-dev babel-polyfill在 webpack config.js 中加入:123module.exports = &#123; entry: &#123;app: ['babel-polyfill', './src/main.js']&#125; IE 11 中接口返回值接收失败查找发现 Axios 返回值 response 的 data 是个字符串的 json。需要转换为 JavaScript 对象，才可正常读取。代码如下：1234567891011121314151617181920212223242526272829303132import axios from 'axios'import config from './config'const Axios = axios.create(config)// 用于转换为 JavaScript对象const looseJsonParse = function(obj) &#123; return Function('\"use strict\";return (' + obj + ')')()&#125;// Response 拦截器Axios.interceptors.response.use( response =&gt; &#123; var pathsearch = window.location.pathname + window.location.search if (response) &#123; var res = typeof response.data === 'string' ? looseJsonParse(response.data) : response.data switch (res.status) &#123; case '200': return res case '40001': console.log(response) return 0 default: return res &#125; &#125; &#125;, error =&gt; &#123; return error &#125;)export default Axios关于 looseJsonParse 转换为 JavaScript 对象其实也可使用 JSON.parse() 【 ie8+ 】虽然可以 eval(’(’ + obj + ‘)’)，但不建议使用由于性能和容易被劫持攻击等原因，推荐使用 looseJsonParse 方式 戳这里 插曲：eval 与 JSON.parse()详细了解？戳这里JSON.parse 只是格式化 json;要求严格的 json 格式（只能解析属性名是双引号包裹的字符串对象【key、value 都要双引号】，并会忽略换行和空格（值外面））。eval 函数可将一个 JavaScript 代码字符串求值成特定的对象，解析 json 只是其中一点功能。eval 解析 json 需要加入’()’ eg: eval(’(’ + obj + ‘)’)eval 对 josn 的格式没有特殊要求，但是会直接执行里面内容进行运算。（eval 相当于一个执行环境）eg: eval(’(’ + ‘{data:new Date()}’ + ‘)’)eval 解析 json 需要加入’( )’ 是因为eval()相当于一个执行环境，当你不加括号的时候，jsonstr1 会被认为是一条复合语句。运行的时候就会逐个字符的解析。但是加上括号的时候，jsonstr1 就当做一个表达式去运算。从括号开始就被当做了对象进行识别。 IE 9 中接口返回值的 data 为 undefined 查找发现在 Axios config 中，默认设置了 responseType: ‘json’ 。 ie9 下不支持,返回数据没有 data 字段 解决注释 // responseType: ‘json’ 就好 IE 中 elementUI 组件 bug NavMenu 导航 组件 移入下拉报错（TypeError 对象不支持此操作） 查找发现NavMenu 组件默认使用的 hover 方式不被 IE 支持 解决在对应的 el-menu 加入属性 menu-trigger=“click” mode=“horizontal”注意：文档说的很明确，menu-trigger (只在 mode 为 horizontal 时有效) IE 下 table 组件 下表格与表头错位的兼容问题 问题因为表格宽度未设置 100%，导致计算每列出现几 px 的精度差，最后导致整体样式错乱 解决全局接入 css 补丁:1234567891011body .el-table th.gutter &#123; display: table-cell !important;&#125;body .el-table colgroup.gutter &#123; display: table-cell !important;&#125;table &#123; width: 100% !important;&#125; IE 下报错 ：Unhandled promise rejection SyntaxError: 缺少 ‘;’ 或 Unhandled promise rejection SyntaxError: 缺少 ‘）’ 查找发现vue-chart 出现了兼容问题。 解决查阅文档步骤 1： npm i echarts vue-echarts -S步骤 2：npm i resize-detector -S步骤 3：当使用 Vue CLI 3+ 时，需要在 vue.config.js 中的 transpileDependencies 增加 vue-echarts 及 resize-detector，如下：1234567// vue.config.jsmodule.exports = &#123; transpileDependencies: [ 'vue-echarts', 'resize-detector' ]&#125;当使用 Vue CLI 2 的 webpack 模板时，需要按下述的方式修改 build/webpack.base.conf.js：1234567891011&#123; test: /\\.js$/, loader: 'babel-loader', - include: [resolve('src'), resolve('test')] + include: [ + resolve('src'), + resolve('test'), + resolve('node_modules/vue-echarts'), + resolve('node_modules/resize-detector') + ]&#125;还有一种方案，直接使用 echarts 兼容样式问题 问题最早使用了大量的 flex 布局，导致 IE9 无法正常显示。 解决在 index.html 中借助 “&lt;!–[if IE 9]&gt;” 来引入针对 IE9 的样式补丁，如下：1234567891011121314151617&lt;!--[if IE 9]&gt; &lt;style&gt; .flex-row-between &gt; :nth-child(1) &#123; float: left; &#125; .flex-row-between &gt; :nth-child(2) &#123; float: right; &#125; img &#123; vertical-align: middle; &#125; &lt;/style&gt;&lt;![endif]--&gt;&lt;!-- 或者，也比较建议借助link 引入补丁样式 --&gt;&lt;!--[if IE 9]&gt; &lt;link rel=\"stylesheet\" href=\"static/compatible/forIE9.css\" /&gt;&lt;![endif]--&gt; IE9、10、11、edge 下 头像裁剪上传 报错（提示对象或方法未定义）由于此处代码是同事写的，屡了下流程：通过 点击 label 标签 触发 隐藏 input file 控件，选取图片;通过 FileReader 读取文件 使用 FileReader.readAsArrayBuffer() 得到 blob 对象;使用 window.URL.createObjectURL 得到 dataUrl 喂给 vue-cropper 组件进行图片裁剪;从 vue-cropper 裁剪后，返回得到 base64，通过 new File() 转换为 file 文件; // 或者 blob 对象使用 formData 发送给后台;后台返回成功后，修改页面头像，流程完毕。了解到都使用哪些东西，还需要了解下基本知识。MDN 下了 File、 blob、URL.createObjectURL技术实现采用了一些比较高级的 api ，对于 IE 来讲不是太友好，总结如下：浏览器FileblobcreateObjectURLnew File(转换为 File 文件)IE9NONONONOIE10YESYESYESNOIE11YESYESYESNOEdgeYESYESYESNO看起来情况不太乐观。那么，一个一个解决。 IE9 下头像上传从上面看来，IE9 不支持高级 api ，原来的整套应该全部不适用。果然，从 第一步 获取文件就在报错。 input file 控件 的 target.files 是 udefined。难道无法拿到文件？补习了下：IE9 获取 File 文件对象前端图片预览，上传前预览，兼容 IE7、8、9、10、11，Firefox，Chrome得到如下信息：低版本 IE 由于 JS 安全问题，不允许 JS 访问本地文件,所以无法获取 files对于低版本的 IE 可以使用 ActiveXObject 获取文件对象, 但是默认情况下ActiveXObject 为不可用的, 所以要想使用此对象要先启用设置, 即:Tools(工具) / Internet options(选项) / Security(安全) / Custom level(自定义级别)找到&quot;Initialize and script ActiveX controls not marked as safe for scripting&quot;设置为&quot;Enable(not secure)&quot;即可.获取文件路径出于安全性的考虑，低版本 IE 上传文件时屏蔽了真实的本地文件路径,以 C:\\fakepath**取而代之, 所以默认情况下通过 fileEle.value 不能获取到文件的真实路径.如果想获取真实路径, 有两种方式:通过设置 IE 的安全设置, 即:Tools(工具) / Internet options(选项) / Security(安全) / Custom level(自定义级别)找到&quot;Include local directory path when uploading files to a server&quot;设置为的&quot;Enable&quot;使用 JS 获取, 即:fileEle.select().blur();var filePath = document.selection.createRange().text;然后试了下 在 IE 下使用 ActiveXObject 读取文件。然后读取文件还要设置【⊙﹏⊙b 汗】，放弃。与产品沟通了下。本着华丽升级，优雅降级的原则【好吧，就是我也没有办法】。IE9 下可以取消裁剪。先科普下兼容 ie9 文件上传，解决 ie9 下提示下载或保存HTML5 file 对象和 blob 对象的互相转换js blob 转 FileConvert blob to fileHTML 利用 meta 标签设置 IE 文档模式及相关知识拓展","categories":[{"name":"项目改造","slug":"项目改造","permalink":"http://mcdowell8023.github.io/categories/项目改造/"}],"tags":[{"name":"兼容","slug":"兼容","permalink":"http://mcdowell8023.github.io/tags/兼容/"},{"name":"vue","slug":"vue","permalink":"http://mcdowell8023.github.io/tags/vue/"}]},{"title":"docker笔记-基础篇","slug":"docker笔记-基础篇","date":"2019-10-28T02:24:19.000Z","updated":"2020-04-22T08:24:05.227Z","comments":true,"path":"2019/10/28/docker笔记-基础篇/","link":"","permalink":"http://mcdowell8023.github.io/2019/10/28/docker笔记-基础篇/","excerpt":"","text":"本文仅以前端视角，接触使用 docekr。认识较为肤浅，大神请绕行。关于 DockerDocker 是啥Docker 主要用途Docker 中的概念安装慢？！修改镜像源地址基本操作镜像操作检索拉取镜像新增 镜像删除 镜像修改 镜像 名称查看 镜像导入、导出、上传 镜像容器操作新增容器删除 容器修改 容器 状态进入 容器查看 容器器与主机之间的数据拷贝导入、导出 容器 关于 Docker Docker 是啥Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。它是目前最流行的 Linux 容器解决方案。 Docker 主要用途提供一次性的环境。比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。提供弹性的云服务。因为 Docker 容器可以随开随关，很适合动态扩容和缩容。组建微服务架构。通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。以上摘自阮老师博客 Docker 中的概念镜像（image）: 镜像中包含有需要运行的文件。镜像用来创建 container，一个镜像可以运行多个 container；镜像可以通过 Dockerfile 创建，也可以从 Docker hub/registry 上下载。容器（container）: 容器是 Docker 的运行组件，启动一个镜像就是一个容器，容器是一个隔离环境，多个容器之间不会相互影响，保证容器中的程序运行在一个相对安全的环境中。仓库（repository）: 共享和管理 Docker 镜像，用户可以上传或者下载上面的镜像，官方地址为 https://registry.hub.docker.com/（类似于 github 对源代码的管理），也可以搭建自己私有的 Docker registry。以上摘自Ant Design Pro 的 Docker 部署方式从我的角度，使用 docker 常常是要解决宿主依赖环境的问题。比如：我是个前端开发从业者，可能有些时候需要在本地 查看 打包编译后的项目真实表现。以前需要本地安装一个 Nginx 配好文件，然后启动。现在，只需要编写好 dockerfile 文件，直接输入命令，就可以在本地查看项目。再者，搭建较为复杂的环境（依赖因为网络等问题过于缓慢），不同开发者需要安装很多东西，不便捷。如，搭建一个 gitbook 文档项目（支持多个文档），从 nodejs ,gitbook, gitbookcli 等比较多的依赖全局安装后，还需要安装 gitbook 的插件（比较慢，而且还没有较快的国内镜像），才可本地启动。毕竟项目本身只是辅助编写文档，因为环境问题给团队带来困扰，就得不偿失了。 如果，将项目的依赖环境做成镜像，放到自己的内部服务器上，每个需要启动项目的人直接使用 docker 镜像，那么基本无痛启动项目。 安装安装系统推荐使用 Mac 或者 Linux。Windows 不建议使用。《菜鸟教程》的 Docker Windows 安装中说的 Docker toolbox（老黄历） 已经无法使用了。官方推荐 安装 Docker desktop，需要系统是专业版的。（而且折腾一番，及时能用，跑别人写的 Dockerfile 还会碰到问题。过于折腾，本末倒置。）Mac 或 Windows 安装软件地址安装教程：Mac 安装ubuntu 安装Windows 安装1234567# 查看版本 验证成功docker version# 把用户加入 Docker 用户组 避免每次命令都输入sudosudo usermod -aG docker $USER# 启动一个Nginx 验证效果 正常浏览器输入http://localhost/即可访问docker run --detach --publish=80:80 --name=webserver nginx 慢？！修改镜像源地址Docker 修改镜像源地址如果是 dockerDesktop 进入设置，找到 Daemon 选项，修改 registry-mirrors 选项为：'http://hub-mirror.c.163.com’ [这个是网易的加速镜像]，然后 apply &amp;&amp; startinsecure registry 一般 是公司搭建的私服使用 基本操作 镜像操作 检索拉取镜像1234# 1. 检索镜像 或去 &lt;https://hub.docker.com&gt; 进行搜索docker search &lt;Images Name&gt;# 2. 从仓库中拉取 镜像 到本地docker pull &lt;Images Name:tag-缺省为latest&gt;非官方下载 需要加上 仓库地址。如从网易蜂巢的镜像源来下载 ubuntu:18.04 镜像，可以使用如下命令，此时下载的镜像名称为 hub.c.163.com/public/ubuntu:18.04 新增 镜像根据现有容器生成镜像12345678# OPTIONS# -a: 作者信息；# -c: 提交时执行dockerfile指令，包含CMD等# -m: 提交消息# -p: 提交暂停容器运行docker commit [OPTIONS] CONTAINER [镜像名称[:TAG]]# 常用方式 填写信息 作者 镜像名称（不包含大写）docker commit -m'提交消息' -a '作者' &lt;容器ID&gt; &lt;Images Name:tag&gt;本地模版导入123456# OPTIONS# -c: 提交时执行dockerfile指令，包含CMD等# -m: 提交消息docker import [OPTIONS] file|URL|- &lt;Images Name:tag&gt;# eg:cat exampleimage.tgz | docker import - exampleimagelocal:new基于 dockerfile 创建12345678910# 编写好 dockerfile 后 进行build# OPTIONS# --file , -f Dockerfile的名称（默认为“ PATH / Dockerfile”）# --tag , -t 名称以及“ name：tag”格式的标签（可选）docker build [OPTIONS] &lt;Dockerfile的 PATH | URL | - &gt;# eg:# 使用URL github.com/creack/docker-firefox 的 Dockerfile 创建镜像。docker build github.com/creack/docker-firefox# 使用根目录下的 Dockerfile 创建名称为 lanjiang/gitbook 的镜像docker build -t lanjiang/gitbook . 删除 镜像docker rmi 删除123456# 删除 镜像 (没有使用该镜像的容器 才可删除，不推荐强制删除)docker rmi [-f: 强制删除] &lt;Images Name/ids&gt;# 筛选包含 none 的镜像删除docker rmi $(docker images | grep \"none\" | awk '&#123;print $3&#125;')# 删除全部镜像docker rmi $(docker images -a -q)docker image prune 清除没有被使用的镜像123456# 清除没有被使用的镜像# OPTIONS:# -a 删除所有无用镜像（不光临时镜像）；# -filter filter:只清理给定过滤的镜像；# -f,-force:强制删除docker image prune [OPTIONS] 修改 镜像 名称12# 给镜像添加标签docekr tag &lt;Images Name/id&gt; &lt;new Images Name&gt; 查看 镜像12345# 查看 本地镜像docker images / docker image ls# 查看 本地全部镜像（包含临时镜像）docker images -a 导入、导出、上传 镜像123456# 镜像 导出 和 载入docker save -o &lt;导出名称&gt; &lt;Images Name:tag&gt;# 将镜像 node 生成 /Users/mcdowell/Downloads/ 下的dockderApp.tardocker save -o /Users/mcdowell/Downloads/dockderApp.tar node# ordocker save node &gt; /Users/mcdowell/Downloads/dockderApp11.tar1234# 将/Users/mcdowell/Downloads/ 下的tf-keras.tar 镜像 导入镜像docker load -i /Users/mcdowell/Downloads/tf-keras.tar# ordocker load &lt; /Users/mcdowell/Downloads/tf-keras.tar12# 上传镜像docker push [OPTIONS] NAME[:TAG]123456789# eg:# 本地生成镜像docker commit c16378f943fe rhel-httpd# 给刚生成的镜像打上 源标签docker tag rhel-httpd registry-host:5000/myadmin/rhel-httpd# 上传镜像docker push registry-host:5000/myadmin/rhel-httpd# 如果是官网仓库 （官方仓库省略源地址）docker push myadmin/rhel-httpd 容器操作 新增容器新建123456789101112131415161718192021222324252627# 新建 容器（默认是停止的）docker create &lt;Images Name:version /ID&gt;# 用 XX镜像 新建容器 并启动 （ docker create + docker start ）# OPTIONS 常用说明# -d: 后台运行容器，并返回容器ID；# -i: 以交互模式运行容器，通常与 -t 同时使用；# -P: 随机端口映射，容器内部端口随机映射到主机的高端口# -p: 指定端口映射，格式为：主机(宿主)端口:容器端口# -t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；docker run [OPTIONS] &lt;Images Name:version&gt; [COMMAND] [ARG...]# 用 node 镜像 以交互模式终端 新建容器 并启动docker run -it node bash# 用 ubuntu:18.04 镜像 以交互模式终端 新建容器 并启动docker run -it ubuntu:18.04 /bin/bash# 进入交互模式 使用ctrl+d 或者 exit 退出# 用 lanjiang/gitbook镜像 新建容器 并启动 映射到 80 端口docker run -p 80:80 lanjiang/gitbook# 用 nginx镜像 以守护进行（后台运行）的方式 新建容器 并启动 映射到 80 端口 --默认返回ID号docker run -d -p 80:80 nginx# 使用docker镜像nginx:latest 以后 随机端口 台模式 启动一个容器,并将容器命名为mynginx【需要使用docker port 才可访问】docker run -P -d --name mynginx nginx:latest 删除 容器docker rm 删除1234567# 删除容器 id可以是多个 （容器必须终止才能删除）docker rm &lt;IDs&gt;# 筛选包含 gitbook 的容器删除docker rm $(docker ps -a|grep gitbook|awk '&#123;print $1&#125;')# 删除 全部容器docker rm $(docker ps -a -q)docker container prune 删除12345# 删除暂停的容器# OPTIONS# --filter 提供过滤器值（例如'until ='）# --force , -f 强制删除，不提示docker container prune [OPTIONS] 修改 容器 状态启动、重启12345# 启动 容器docker start &lt;Images Name:version /ID&gt;# 重启 容器docker restart &lt;ID&gt;暂停\\恢复 容器 (保存容器状态）1234# 暂停 容器docker pause &lt;ID&gt;# 恢复 容器docker unpause &lt;ID&gt;终止容器1234# 终止容器 id可以是多个 kill 也可以docker stop &lt;IDs&gt;# 筛选包含 gitbook 的容器终止docker stop $(docker ps -a|grep gitbook|awk '&#123;print $1&#125;') 进入 容器docker attach 进入 容器12345# 默认 CTRL-c不退出当前终端而是 给容器内 程序执行docker attach [OPTIONS] &lt;container Name/ID&gt;# 使用 --sig-proxy=false 避免上述问题docker attach --sig-proxy=false mynginx# 缺点：多个窗口执行时，一个窗口阻塞，其他窗口无法执行docker exec 进入 容器1234567891011# 使用 exec 进入容器#OPTIONS说明：# -d :分离模式: 在后台运行# -i :即使没有附加也保持STDIN 打开# -t :分配一个伪终端docker exec [OPTIONS] &lt;container Name/ID&gt; [\b命令] [ARG...]# 在容器 mynginx 中以交互模式执行容器内 /root/blue.sh 脚本:docker exec -it mynginx /bin/sh /root/blue.sh# 在运行的容器中 以 以交互模式终端 执行 bash 命令docker exec -it &lt;container Name/ID&gt; /bin/bash 查看 容器查看本地容器1234567# 输出 ID容器的 日志docker logs &lt;ID&gt;# 查看 运行的 容器docker ps# 查看全部容器（包含运行和暂停的）docker ps -a # -q:只显示ID查看容器内部信息123456789101112# 查看容器详情docker inspect &lt;container Name/ID&gt;# 查看容器内 进程（容器需要启动）docker top &lt;container Name/ID&gt;# 查看统计信息 （cpu 内存 存储 网络使用情况）docker stats &lt;container Name/ID&gt;# 查看系统变更docker diff &lt;container Name/ID&gt;# 查看 容器 端口映射docker port &lt;container Name/ID&gt; 器与主机之间的数据拷贝12345678# 容器与主机之间的数据拷贝docker cp &lt;path&gt; &lt;path&gt;# 将主机/www/blue目录拷贝到容器63d47d7c0d4c的/www目录下。docker cp /www/blue 63d47d7c0d4c:/www/# 将主机/www/blue目录拷贝到容器 63d47d7c0d4c中，目录重命名为www(此处无斜杠))docker cp /www/blue 63d47d7c0d4c:/www# 将容器 63d47d7c0d4c 的 /www 目录拷贝到主机的 /tmp 目录中。docker cp 63d47d7c0d4c:/www /tmp/ 导入、导出 容器123456# 容器导出docker export -o tf-keras-33f6c8359187.tar &lt;container Name/ID&gt;# ordocker export 33f6c8359187 &gt; tf-keras-33f6c8359187.tar# 导入docker import tf-keras-33f6c8359187.tar与镜像导出（docker save）比较：容器快照文件 将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积更大","categories":[{"name":"工具","slug":"工具","permalink":"http://mcdowell8023.github.io/categories/工具/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://mcdowell8023.github.io/tags/笔记/"},{"name":"Docker","slug":"Docker","permalink":"http://mcdowell8023.github.io/tags/Docker/"}]},{"title":"浏览器全屏api--fullScreen","slug":"浏览器全屏api-fullScreen","date":"2019-09-24T07:40:35.000Z","updated":"2020-03-29T10:00:02.803Z","comments":true,"path":"2019/09/24/浏览器全屏api-fullScreen/","link":"","permalink":"http://mcdowell8023.github.io/2019/09/24/浏览器全屏api-fullScreen/","excerpt":"","text":"fullScreen 浏览器 全屏 api本文转载 Fullscreen API工作开发中遇到需要浏览器 全屏。查询 api 后，决定使用 requestFullscreen，但是 api 存在兼容问题。借助大佬的总结： 启动全屏模式12345678910111213141516// 处理兼容性 调用 全屏apifunction launchIntoFullscreen(element) &#123; if (element.requestFullscreen) &#123; element.requestFullscreen() &#125; else if (element.mozRequestFullScreen) &#123; element.mozRequestFullScreen() &#125; else if (element.webkitRequestFullscreen) &#123; element.webkitRequestFullscreen() &#125; else if (element.msRequestFullscreen) &#123; element.msRequestFullscreen() &#125;&#125;// 开启全屏 模式 谷歌浏览器 、安卓手机 亲测可用launchIntoFullscreen(document.documentElement) // 整个页面launchIntoFullscreen(document.getElementById('videoElement')) // 或者任意对象 退出全屏模式12345678910// 退出全屏function exitFullscreen() &#123; if(document.exitFullscreen) &#123; document.exitFullscreen(); &#125; else if(document.mozCancelFullScreen) &#123; document.mozCancelFullScreen(); &#125; else if(document.webkitExitFullscreen) &#123; document.webkitExitFullscreen(); &#125;&#125; 全屏属性和事件document.fullScreenElement：已推送到全屏状态的元素。document.fullScreenEnabled：说明当前是否启用了全屏。123456789/* 兼容写法 */var fullscreenElement = document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElementvar fullscreenEnabled = document.fullscreenEnabled || document.mozFullScreenEnabled || document.webkitFullscreenEnabled实际使用12345678910111213// 添加事件监听document.addEventListener('fullscreenchange', function(e) &#123; console.log('fullscreenchange event! ', e)&#125;)document.addEventListener('mozfullscreenchange', function(e) &#123; console.log('mozfullscreenchange event! ', e)&#125;)document.addEventListener('webkitfullscreenchange', function(e) &#123; console.log('webkitfullscreenchange event! ', e)&#125;)document.addEventListener('msfullscreenchange', function(e) &#123; console.log('msfullscreenchange event! ', e)&#125;) 全屏 CSS1234567891011121314151617181920212223242526272829303132333435:-webkit-full-screen &#123; /* properties */&#125;:-moz-full-screen &#123; /* properties */&#125;:-ms-fullscreen &#123; /* properties */&#125;:full-screen &#123; /*pre-spec */ /* properties */&#125;:fullscreen &#123; /* spec */ /* properties */&#125;/* deeper elements */:-webkit-full-screen video &#123; width: 100%; height: 100%;&#125;/* styling the backdrop*/::backdrop &#123; /* properties */&#125;::-ms-backdrop &#123; /* properties */&#125; 实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" /&gt; &lt;title&gt;全屏api测试页面&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div style=\"padding:20px;\"&gt; &lt;button onclick=\"launchFullscreen(document.documentElement);\" class=\"sexyButton\" &gt; 启动全屏 &lt;/button&gt; &lt;button onclick=\"exitFullscreen();\" class=\"sexyButton\"&gt;关闭全屏&lt;/button&gt; &lt;button onclick=\"dumpFullscreen();\" class=\"sexyButton\"&gt; 转储全屏属性数据 &lt;/button&gt; &lt;/div&gt; &lt;!-- 谷歌浏览器 、安卓手机 亲测可用 --&gt; &lt;style&gt; /* 全屏后 样式 */ :-webkit-full-screen &#123; background: pink; &#125; :-moz-full-screen &#123; background: pink; &#125; :-ms-fullscreen &#123; background: pink; &#125; :full-screen &#123; /*pre-spec */ background: pink; &#125; :fullscreen &#123; /* spec */ background: pink; &#125; &lt;/style&gt; &lt;script&gt; // 处理兼容性 调用 全屏api function launchFullscreen(element) &#123; if (element.requestFullscreen) &#123; element.requestFullscreen() &#125; else if (element.mozRequestFullScreen) &#123; element.mozRequestFullScreen() &#125; else if (element.webkitRequestFullscreen) &#123; element.webkitRequestFullscreen() &#125; else if (element.msRequestFullscreen) &#123; element.msRequestFullscreen() &#125; &#125; // 退出全屏 function exitFullscreen() &#123; if (document.exitFullscreen) &#123; document.exitFullscreen() &#125; else if (document.mozCancelFullScreen) &#123; document.mozCancelFullScreen() &#125; else if (document.webkitExitFullscreen) &#123; document.webkitExitFullscreen() &#125; &#125; function dumpFullscreen() &#123; console.log( 'document.fullscreenElement is: ', document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement ) console.log( 'document.fullscreenEnabled is: ', document.fullscreenEnabled || document.mozFullScreenEnabled || document.webkitFullscreenEnabled || document.msFullscreenEnabled ) &#125; // 添加事件监听 document.addEventListener('fullscreenchange', function(e) &#123; console.log('fullscreenchange event! ', e) &#125;) document.addEventListener('mozfullscreenchange', function(e) &#123; console.log('mozfullscreenchange event! ', e) &#125;) document.addEventListener('webkitfullscreenchange', function(e) &#123; console.log('webkitfullscreenchange event! ', e) &#125;) document.addEventListener('msfullscreenchange', function(e) &#123; console.log('msfullscreenchange event! ', e) &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"拓展","slug":"拓展","permalink":"http://mcdowell8023.github.io/categories/拓展/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://mcdowell8023.github.io/tags/浏览器/"},{"name":"api","slug":"api","permalink":"http://mcdowell8023.github.io/tags/api/"}]},{"title":"ant-design踩坑：Cascader级联选择","slug":"ant-design踩坑-Cascader级联选择","date":"2019-09-03T11:33:33.000Z","updated":"2020-03-29T09:59:54.841Z","comments":true,"path":"2019/09/03/ant-design踩坑-Cascader级联选择/","link":"","permalink":"http://mcdowell8023.github.io/2019/09/03/ant-design踩坑-Cascader级联选择/","excerpt":"","text":"Cascader 级联选择 遇到的问题 要点级联选择 数据中 isLeaf: false 可以控制是否选中【false 表示不选中】，触发 loadData 函数级联选择 数据中 如果当前层不是最终级【就是你要 id 的那层】，children 一定不能为[],否则会导致组件选中错误层级，不会触发 loadData 函数 详细 交代说明 公司开发后台管理系统，涉及一个地级区域选择的功能，实现效果如下 后台给的接口是根据参数查询省，然后市…,如下 查看官网文档通过官网示例，了解到 采用 动态加载选项 示例的方式，使用 loadData 实现动态加载选项。按照官网的介绍，结合实际接口，我们需要 每次动态修改 根据返回 数据进行 数据拼接。 编码当然后台数据返回的字段与组件预制不同，我们可以借助 fieldNames 属性进行自定义字段。编码 测试组件 时候，你会发现点击第一层的数据就会直接选中【我们要的是最后一层，通信商的 id】。查阅属性说明未果。但是通过示例后发现，数据中 isLeaf: false 可以控制是否选中，从而触发 loadData。貌似准备就绪。然后，愉快的编码点击非 type 是 3 的一层，进行接口调用1234567891011121314151617// Cascader loadData 事件 函数 查询数据const cascaderLoadData = selectedOptions =&gt; &#123; // 点击得到的 一级 或 二级 数据 const targetOption = selectedOptions[selectedOptions.length - 1] const &#123; id, type &#125; = targetOption targetOption.loading = true const newType = type + 1 if (type !== 3) &#123; // 一级 或 二级 数据 // 这里是调用 查询地区接口的函数 getDict(&#123; [newType === 2 ? 'regionId' : 'cityId']: id, webId: id, type: newType &#125;) &#125;&#125;数据拼接,上代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// 这里是 得到后台返回数据 在 reducers 的 数据动态拼接处理// 提供 Cascader optionssaveVPNAddressDict(state, action) &#123; const &#123; params: &#123; type, webId &#125;, res, &#125; = action.payload; const &#123; VPNAddressDict &#125; = state; const pushList = (arr, typeNum) =&gt; &#123; return arr ? arr .map(item =&gt; &#123; if (!item) &#123; return null; &#125; return &#123; ...item, loading: false, isLeaf: typeNum === 3, // 用于控制非 第三层 不能选 children: null, &#125;; &#125;) .filter(item =&gt; item) : []; &#125;; let dicts = []; const dict = pushList(res, type); // 基本思路就是： 根据type 确定层级 当前数据该是第几层 根据 webId 找到应该对应的 数据对象 switch (type) &#123; case 1: // 查询省数据 dicts = [...dict]; break; case 2: // 查询市数据 dicts = VPNAddressDict.map(item =&gt; &#123; if (item.id === webId) &#123; return &#123; ...item, loading: false, children: [...dict], &#125;; &#125; return item; &#125;); break; case 3: // 运营商数据 dicts = VPNAddressDict.map(items =&gt; &#123; const list = items &amp;&amp; items.children ? items.children : []; const children = list.map(item =&gt; &#123; if (item.id === webId) &#123; return &#123; ...item, loading: false, children: [...dict], &#125;; &#125; return item; &#125;); return &#123; ...items, loading: false, isLeaf: false, children, &#125;; &#125;); break; default: dicts = []; break; &#125; return &#123; ...state, VPNAddressDict: dicts, &#125;;然后按照示例使用组件基本完成后。测试发现，如果你依次点击 【 广东 &gt; 广州 &gt; 移动 】（ 选中最后一层），再次选择 【北京】 组件直接选中了 【北京】（直接选中第一层）。多次测试发现只要不点击最后一层，那么不会出现这个问题。分析：根据 bug 出现的情况，可以判断，是执行了 saveVPNAddressDict 动态拼接函数 type= 3 的运营商数据拼接出现的问题。检查代码未发现明显错误。通过打印数据发现，【北京】数据的 children 是个空数组。 凭借多年开发的直觉[🤦‍ 好吧，我也不知道我是怎么知道的]，推测 children 数据问题。验证：自造一条假数据，直接给组件测试使用。数据如下1234567891011121314const options = [ &#123; value: '北京', label: '北京', isLeaf: false, children: [] &#125;, &#123; value: '广东', label: '广东', isLeaf: false, children: [] &#125;]验证结果发现，children 字段如果是数组，会导致直接选中，不会触发 loadData。8.修正。那么在函数执行时候，如果没被选中的 children 显示为 null。 修正如下1234567891011121314151617181920212223// saveVPNAddressDict case 3的代码片段case 3: // 运营商数据 dicts = VPNAddressDict.map(items =&gt; &#123; const list = items &amp;&amp; items.children ? items.children : []; const children = list.map(item =&gt; &#123; if (item.id === webId) &#123; return &#123; ...item, loading: false, children: [...dict], &#125;; &#125; return item; &#125;); return &#123; ...items, loading: false, isLeaf: false, children:children.length?children:null, &#125;; &#125;); break; 总结级联选择 数据中 isLeaf，children 两个字段直接影响 是否被选中，loadData 是否会触发。","categories":[{"name":"踩坑","slug":"踩坑","permalink":"http://mcdowell8023.github.io/categories/踩坑/"}],"tags":[{"name":"ant-design","slug":"ant-design","permalink":"http://mcdowell8023.github.io/tags/ant-design/"},{"name":"踩坑","slug":"踩坑","permalink":"http://mcdowell8023.github.io/tags/踩坑/"},{"name":"react","slug":"react","permalink":"http://mcdowell8023.github.io/tags/react/"}]},{"title":"git 学习笔记","slug":"git-学习笔记","date":"2019-08-28T08:37:24.000Z","updated":"2020-03-29T09:59:30.671Z","comments":true,"path":"2019/08/28/git-学习笔记/","link":"","permalink":"http://mcdowell8023.github.io/2019/08/28/git-学习笔记/","excerpt":"","text":"目录目录安装 git初始化基本配置配置帐号信息配置别名查看配置参数说明生成 shh 密钥获取 Git 仓库在现有目录中初始化仓库克隆现有的仓库本地已有构建的项目不进行版本控制添加不进行版本控制的文件目录提交 commit 后，想再忽略一些已经提交的文件常见操作查看信息查看帮助 git help查看状态 git status查看变化 git diff查看日志 git log查看某个文件的版本历史 git show图形化查看提交内容 gitk更新文件重命名文件删除提交撤销&amp;回滚简单总结撤销修改文件 尚未提交修改文件 已经提交（git commit）到 本地仓库回滚还原 远端服务器 提交的代码删除最后一次远程提交回滚某次提交删除某次提交操作标签创建标签查看标签删除标签操作分支查看分支新建分支提交到远程分支删除分支合并分支暂存分离头【detached HEAD】操作子仓库常用命令详解git pull 详解git fetch 详解git add 详解git commit 详解git remote 详解git push 详解语法示例完整示例本地分支名 缺省本地分支、远程分支都 缺省远程主机名、本地分支、远程分支都 缺省simple 方式 和 matching 方式git branch 详解语法示例git checkout 详解例子git reset 详解git cherry-pick 详解git submodule 详解git 原理git 工作解析图git 文件目录commit 与 tree 和 blob 的关系git 注意事项常见缩写 安装 git已有？请跳过git 文档地址git 下载地址查看 git 版本1git --version 初始化 基本配置 配置帐号信息1234# 设置 [本仓库 | 全局 | 系统 ] 的 用户名称$ git config [--local | --global | --system] user.name 'Your name'# 设置 [本仓库 | 全局 | 系统 ] 的 用户邮箱$ git config [--local | --global | --system] user.email 'Your email'当然你也可以通过修改 .git 文件目录下面的 config 文件进行修改 配置别名12345# 配置别名$ git config --global alias.st status # git st$ git config --global alias.co checkout # git co$ git config --global alias.br branch # git br$ git config --global alias.ci commit # git ci 查看配置1234# 查看配置git config --list [--local | --global | --system]# 根据git哈希值 查看内容 / 查看类型git cat-flie [-p / -t] 参数说明local：区域为本仓库global: 当前用户的所有仓库system: 本系统的所有用户缺省等同于 local优先级：local &gt; global &gt; system 生成 shh 密钥如果你想通过 https 的方式 每次提交输入密码，当然可以跳过此节检查是否已经存在公私钥1234# 查看.ssh目录下是否有密钥 如列表中包含 id_rsa和id_rsa.pub 说明电脑中已经存在公私钥ls -al ~/.ssh# cat ~/.ssh/id_rsa.pub生成密钥123456# 生成秘钥（根据电脑主机）$ ssh-keygen -t rsa# 根据邮箱生成 密钥$ ssh-keygen -t rsa -C \"youremail\"# 执行后 ：建议不要输入，一路回车，生成的 id_rsa 是私钥 生成的 id_rsa.pub 是公钥添加 密钥在对应服务器增加密钥。【github -&gt; setting -&gt; SSH and GPG keys】如果公司是自己搭建的 git 服务（未使用 gitlab），则交给管理员添加。如果使用 gitlab 在设置增加密钥 获取 Git 仓库 在现有目录中初始化仓库12345678910111213# 初始化本地仓库 缺省 为当前目录$ git init ['your_project'/缺省]# git init --bare 建立裸仓库【中心仓库】# 获取状态$ git status# .或*代表全部添加$ git add [file1] [file2] ...# 提交$ git commit -m \"提交message\"# 添加远程源$ git remote add origin [远程地址]# push 同时 设置默认跟踪分支$ git push -u origin master 克隆现有的仓库1234# 克隆远程仓库到本地 fileName 的文件夹内 【缺省-默认远端名称】$ git clone [url] &lt;fileName/缺省&gt;# 克隆 为 裸仓库【中心仓库】$ git clone --bare [ 连接地址 ] &lt; file bf名称 &gt;从裸仓库 clone 下来的本地仓库可以进行正常的 push 操作， 但是从一般仓库 clone 下来的本地仓库却不行。 这也正是裸仓库存在的意义。 裸仓库一般情况下是作为远端的中心仓库而存在的。 本地已有构建的项目12345678$ git remote -v #查看远程版本库信息$ git remote add github &lt;url&gt; #添加github远程版本库$ git fetch github #拉取远程版本库$ git merge -h #查看合并帮助信息$ git merge --allow-unrelated-histories github/master# or git pull origin master --allow-unrelated-histories# 对github上的master分支与本地master分支进行合并（两分支不是父子关系，所以合并需要添加 --allow-unrelated-histories）$ git push github #推送同步到github仓库 不进行版本控制 添加不进行版本控制的文件目录项目目录下 新建 .gitignore 文件 ，写入不需要进行版本控制的文件名或文件夹1234567891011121314# 文件示例node_modules # 对 node_modules文件夹及其文件 及 node_modules文件 不进行版本控制doc # 对 [doc文件夹及其子文件 和 名称为doc的文件] 不进行版本控制*doc # 不允许 任何 包含doc字符的 文件夹及其子文件 和 文件（包括.扩展名）不进行版本控制doc/ # 对 [doc文件夹及其下文件] 不进行版本控制*doc/ # 对 [任何 包含doc字符的文件夹及其下文件] 不进行版本控制*.md // 对 .md结尾的文件 不进行版本控制# /* 复合示例 */doc!doc/* # git管doc文件夹，不管doc文件 提交 commit 后，想再忽略一些已经提交的文件把忽略的文件添加到 .gitignore;通过 git rm --cached &lt; file &gt;的方式删除掉 git 仓库里面无需跟踪的文件。你需要确认 的 云端源 也要删除git commit -m 'delete git remote somefile'git push 常见操作 查看信息 查看帮助 git help12345678# 所有可用的命令都将打印在标准输出上$ git help [--all/-a]# 在标准输出中也会列出有用的Git指南$ git help [--guide/-g]# 显示 git 手册页$ git help git 查看状态 git statusgit status 命令用于显示工作目录和暂存区的状态。git status 不显示已经 commit 到项目历史中去的信息。看项目历史的信息要使用 git log常用于 git commit 之前, 这样能防止你不小心提交了您不想提交的东西。1234567# 显示工作目录和暂存区的状态$ git status# 只列出所有已经被git管理的且被修改但没提交的文件$ git status -uno# 紧凑的格式输出$ git status -s # or $ git status --short 查看变化 git diff对比 修改之后还没有暂存起来的内容变化123456789101112131415161718192021222324252627282930313233343536# 工作树中的更改尚未分段进行下一次提交$ git diff# 比较当前文件和暂存区文件差异 git diff$ git diff &lt;file&gt;$ git diff &lt;id1&gt;&lt;id1&gt;&lt;id2&gt; # 比较两次提交之间的差异$ git diff &lt;branch1&gt; &lt;branch2&gt; # 在两个分支之间比较$ git diff --staged # 比较暂存区和版本库差异$ git diff --cached # 比较暂存区和版本库差异$ git diff --stat # 仅仅比较统计信息$ git diff HEAD # 显示工作版本(Working tree)和HEAD的差别$ git diff test # 查看当前目录和另外一个分支(test)的差别# 假定：HEAD、缓存区、工作区中的readme.md文件内容均不相同。# 比较 工作区 &lt;===&gt; HEAD$ git diff HEAD -- readme.md# 比较 工作区 &lt;===&gt; 缓存区$ git diff -- readme.md# 比较 缓存区 &lt;===&gt; HEAD$ git diff --cached -- readme.md# 比较两个提交或分支的差异$ gti diff [分支名称/commit-id] [分支名称/commit-id] --&lt; file &gt;# 对比两个版本的不同$ git diff [commit号] [commit号]# 对比 当前提交版本与上次提交$ git diff HEAD HEAD^[同 HEAD～1]# 对比当前提交版本与上上次（前两次）提交$ git diff HEAD HEAD^^[同HEAD～2]补充说明：一个节点，可以包含多个子节点（checkout 出多个分支）一个节点可以有多个父节点（多个分支合并）是~都是父节点，区别是跟随数字时候，2 是第二个父节点，而~2 是父节点的父节点^和~可以组合使用,例如 HEAD~2^2 查看日志 git log1234567891011121314# 查看所有分支的历史 git log 等同于它$ git log --all# 查看图形化的 log 地址$ git log --all --graph# 查看单行的简洁历史。$ git log --oneline# 查看最近的四条简洁历史。$ git log --oneline -n4#查看所有分支最近 4 条单行的图形化历史。$ git log --oneline --all -n4 --graph# 跳转到git log 的帮助文档网页$ git help --web log$ git log -1 // 最近一次提交信息 查看某个文件的版本历史 git show1234// 先查看文件提交历史git log --pretty=oneline [文件名或文件路径] // 例如src/AfterView/common/commonStream.vuegit show [版本号] // 显示具体的某次的改动的修改 图形化查看提交内容 gitk1234# 在当前目录下输入，弹出图形化界面$ gitk$ gitk --all定制化图形界面 ： view --&gt; new view [勾选 all refs] # 显示全部分支 更新使用 git pull 进行更新1234# 按照git branch 设置的默认跟踪的服务器和分支来拉取$ git pull# 实例：拉取远程服务器origin的master分支$ git pull origin master使用 git fetch 进行更新12345678# 将远程仓库的master分支下载到本地当前branch中$ git fetch orgin master# 比较本地的master分支和origin/master分支的差别 $ git log -p master ..origin/master # 进行合并$ git merge origin/master 文件重命名先删除文件再添加文件123456# 重命名3步骤 eg: 重命名 readme 为 readme.md$ mv [文件名1] [文件名2] # 重命名文件名1为文件名2$ git add ['文件名'] # 添加新文件 eg: git add readme.md$ git rm ['文件名'] # 删除旧文件 eg: git rm readme# 就可以正常commit直接使用 git 命令123$ git mv ['旧文件名'] ['新文件名'] # git重命名（相当于上面三个步骤）# 就可以正常commit12345# 回滚到对版本号的应提交状态【缺省回滚到最近的一次提交】$ git reset --hard [提交版本号|缺省]# 记录所有HEAD的历史，也就是说当你做reset，checkout等操作的时候，这些操作会被记录在reflog中$ git reflog 文件删除先删除文件再添加文件1234$ rm &lt;file&gt; # 删除文件$ git add ['文件名'] # 添加新文件 eg: git add readme.md# 就可以正常commit直接使用 git 命令12# 删除工作区，暂存区 的文件$ git rm &lt;file&gt;如果删除出错 借助 git reset --hard 进行撤销 提交1234567891011121314151617181920# 添加新文件$ git add ['文件名' | '.'代表全部]# 查看提交状态【是否有未提交】（不必的） but 能防止你不小心提交了您不想提交的东西# $ git status # 没有未提交的显示 nothing to commit# 提交填写日志$ git commit -m'这里填写提交日志'# 如果发现点问题，那么继续进行了修改# 继续执行 git add . 重新提交，会覆盖上次提交，只以当前为准# $ git commit --amend# 查看日志(不必的)# $ git log# 更新 先更新避免发生冲突$ git pull# 推送到 orgin 远端服务器$ git push 撤销&amp;回滚 简单总结修改了工作区，恢复：git checkoutadd 后，想撤销： git reset HEADcommit 后，想撤销： git reset --hard [需要回退的 commit id] 撤销 修改文件 尚未提交未执行 git add 操作123# 从暂存区（index） 恢复 文件$ git checkout &lt;fileName&gt;$ git checkout .文件执行了 git add 操作，恢复 文件（index 内回滚）123456789# 取消暂存$ git reset HEAD fileName# 撤销修改$ git checkout &lt; fileName &gt;# 暂存区的 commitid 覆盖工作区修改$ git checkout [commitid] -- &lt;file&gt;# git checkout 5384b04 -- src/pages/AdScreen/components/commonStream.vue // 回退 5384b04 的文件同时对多个文件执行了 git add 操作，本次只想提交其中一部分文件1234$ git add *$ git status# 取消暂存$ git reset HEAD &lt;filename&gt; 修改文件 已经提交（git commit）到 本地仓库修改 git commit 不再产生新的 Commit[ 只能修改最近一次 ]1234# 修改最后一次提交$ git add sample.txt# 代替（或这说修改）上一次提交，不只是修改message。$ git commit --amend -m\"说明\"多次 git commit 撤销到其中某次 Commit1234567891011121314# 修改最后一次提交$ git reset --[soft/hard/mixed] [commit|HEAD]# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit] 回滚已进行 git push，即已推送到“远程仓库”中。我们将已被提交到“远程仓库”的代码还原操作叫做“回滚”！注意：对远程仓库做回滚操作是有风险的，需提前做好备份和通知其他团队成员！ 还原 远端服务器 提交的代码12345# 根据 tag 还原工作区代码$ git checkout &lt;tag&gt;# 回滚到指定commitID$ git checkout &lt;commitID&gt; &lt;filename&gt; 删除最后一次远程提交使用 revert123$ git revert HEAD$ git push origin master使用 reset123$ git reset --hard HEAD^$ git push origin master -f二者区别：revert 是放弃指定提交的修改，但是会生成一次新的提交，需要填写提交注释，以前的历史记录都在；reset 是指将 HEAD 指针指到指定提交，历史记录中不会出现放弃的提交记录。 回滚某次提交1234# 找到要回滚的 commitID$ git log# 根据 commitID 进行回滚$ git revert commitID 删除某次提交1234567891011# 找到要回滚的 commitID$ git log --oneline -n5# 注意：最后的^号，意思是commit id的前一次提交$ git rebase -i \"commit id\"^ # git rebase -i \"5b3ba7a\"^# 根据交互输入命令修改信息# 合并多个历史版本commit合并$ git rebase -i [父级commit id ]# 合并多个历史版本commit合并$ git rebase -i [开始commit 的父级id] [结束commit id]如果没有指定 结束 commit,那么结束 commit 默认为当前分支最新的 commit，那么 rebase 结束后会自动更新当前分支指向的 commit,如果指定了结束 commit，而且结束 commit 不是当前分支最新的 commit，那么 rebase 后会有生成一个 游离的 head,，而且当前分支指向的 commit 不会更新具体还可参考：Deleting a Git commit在 Git 中，如何『删除』commit？ 操作标签标签操作允许为存储库中的特定版本提供有意义的名称。 创建标签12345678910# 创建标签$ git tag -a 'tag1' -m 'tag1的说明' [HEAD / commit id / 缺省]# -a选项的 标签名称，-m选项的 标签消息。# 缺省：HEAD 要标记特定提交，则使用相应的COMMIT ID而不是HEAD指针# 将 tag1 推送到 origin 远端$ git push origin &lt;tagname&gt;# 一次性推送全部尚未推送到远程的本地标签$ git push origin --tags 查看标签123456$ git tag# 查看 所有可用的标签$ git tag -l# 查看 tagName标签的 详细信息$ git show tagName 删除标签1234567891011# 查看 所有可用的标签$ git tag -l# 删除 tagName标签$ git tag -d &lt;tagName&gt;# 删除 远端 tag 标签$ git push origin --delete tag &lt;tagname&gt;# 删除 远端 tag 标签 类似 删除远端分支的做法$ git push origin :refs/tags/标签名 操作分支 查看分支1234# 查看分支git branch -v# 查看本地分支对应的远程分支$ git branch -av 新建分支1234567891011121314151617# 新建一个名字为 dev2 的分支 (不切换到新分支)$ git branch dev2# 新建一个名字为 dev2 的分支 并切换到该分支$ git checkout -b &lt;branchname&gt;# 从某个版本创建分支 并切换到该分支$ git checkout -b &lt;branchname&gt; [commit号/分支名称]# 创建并切换分支$ git checkout -b &lt;branchname&gt; [commit版本号]# 基于 远端分支 建立 本地分支（远程分支名x） 采用此种方法建立的本地分支会和远程分支建立映射关系$ git checkout -b &lt;本地分支名x&gt; &lt;origin/远程分支名x&gt;/* 相当于分别执行了下面两条命令 */# git branch &lt;branchname&gt;# git checkout &lt;branchname&gt; 提交到远程分支12345678910$ git push [origin] &lt;分支名称&gt;:&lt;分支名称&gt;# 本地分支push到远程服务器，远程分支与本地分支同名（当然可以随意起名）$ git pull [origin] &lt;分支名称&gt; 更新远程分支到本地# /* 远程分支关联 */$ git branch --set-upstream-to=[origin]/&lt;分支名称&gt;# 接下来就 可以直接pull 或者push 了# 查看关联的分支名称$ git branch -vv[origin] 代指 添加远程裸仓库地址时候，创建的名称 删除分支123456789# 删除分支 -d是删除 -D 是强制删除$ git branch [-D/-d] &lt;branchname&gt;# 删除远程分支$ git branch -d -r &lt;branchname&gt;$ git push origin :&lt;branchname&gt;# OR$ git branch # 查看分支名称$ git push origin --delete &lt;branchname&gt; 合并分支fast-forwardfast-forward 方式 合并这种方法相当于直接把 master 分支移动到 test 分支所在的地方，并移动 HEAD 指针1234# 先切换到主分支，为合并分支准备$ git checkout master# 进行合并$ git merge devno-fast-forward 方式 合并这种合并方法会在 master 分支上新建一个提交节点，从而完成合并1234# 先切换到主分支，为合并分支准备$ git checkout master# 进行合并$ git merge –no-ff devsquash 方式 合并squash 和 no-ff 非常类似，区别只有一点不会保留对合入分支的引用12$ git checkout master$ git merge –squash devrebase 方式 合并rebase 与 merge 不同，rebase 会将合入分支上超前的节点在待合入分支上重新提交一遍，变成线性历史1234# 先切换到主分支，为合并分支准备$ git checkout master# 进行合并$ git rebase devcherry-pick 挑拣 合并对已经存在的 commit 进行 再次提交 [选择某些节点进行合并]12$ git cherry-pick &lt;commit id&gt;当执行完 cherry-pick 以后，将会 生成一个新的提交；这个新的提交的哈希值和原来的不同，但标识名 一样；图解 4 种 git 合并分支方法 &gt; git cherry-pick 的使用 暂存当收到紧急任务，手里又存在未完成的模块可以先放到暂存区12345678git stash # 暂存git stash list # 查看暂存列表git stash apply [序号/缺省为stash@&#123;0&#125;] # 恢复暂存进度到工作区git stash pop [序号/缺省为stash@&#123;0&#125;] # 恢复暂存进度到工作区并删除# git stash pop = git stash pop stash@&#123;0&#125; 分离头【detached HEAD】执行 git checkout [commit 版本号] ，git 会提示显示处于分离头（无分支状态），在此状态下，进行的提交操作不挂到在分支下，直接切换分支，会导致分离头的提交丢失。错误示范：123456789git checkout 15a6686b624 # 检出15a6686b624的提交，到分离头情况git commit -am\"错误示例\" # 创建一次提交git branch -av # 查看分支git checkout marst # 切换到marst 分支 此时git 会提示你，对分离头提交# 最后一次补救git branch [分支名称] [commit版本号]正常使用1234# 使用某个提交创建分支git checkout -b [分支名称] [commit版本号] // 创建并切换分支git checkout -b 本地分支名x origin/远程分支名x // 基于 远端分支 建立 本地分支（远程分支名x） 采用此种方法建立的本地分支会和远程分支建立映射关系 操作子仓库12345678910111213141516171819# 添加子仓库$ git submodule add &lt;仓库地址&gt; &lt;本地路径&gt;# 检出子仓库# 初始化本地配置文件$ git submodule init# 检出父仓库列出的commit$ git submodule update# 或者使用组合指令。$ git submodule update --init --recursive# 删除子仓库# 1删除.gitsubmodule里相关部分# 2删除.git/config 文件里相关字段# 3删除子仓库目录。$ git rm -r --cached &lt;本地路径&gt;git submodule 使用小结 常用命令详解 git pull 详解git pull 相当于从远程获取最新版本并 merge 到本地1234# 按照git branch 设置的默认跟踪的服务器和分支来拉取$ git pull# 实例：拉取远程服务器origin的master分支$ git pull origin mastergit pull 详解12345$ git pull [&lt;options/缺省&gt;] [&lt;远端仓库名称&gt; [&lt;分支名称&gt;…​]]# options : –allow-unrelated-histories 允许无关的历史，这个选项，更多是在更改远程仓库的时候用到# options : –ff 开启fast-forward# options : –no-ff 强行关闭fast-forward方式# options : –ff-only git fetch 详解git fetch 相当于是从远程获取最新到本地，不会自动 merge在实际使用中，git fetch 更安全一些使用 git fetch 进行更新12345678# 将远程仓库的master分支下载到本地当前branch中$ git fetch orgin master# 比较本地的master分支和origin/master分支的差别 $ git log -p master ..origin/master # 进行合并$ git merge origin/masterOR123456# 从远程仓库master分支获取最新，在本地建立tmp分支$ git fetch origin master:tmp#將當前分支和tmp進行對比$ git diff tmp#合并tmp分支到当前分支$ git merge tmpgit pull = git fetch + git merge git add 详解将修改添加到暂存区12345678910111213141516# 将所有修改添加到暂存区$ git add .# Ant风格添加修改$ git add *# 将文件的修改、文件的删除，添加到暂存区。$ git add -u# 将文件的修改，文件的删除，文件的新建，添加到暂存区$ git add -A# 将以Controller结尾的文件的所有修改添加到暂存区$ git add *Controller# 将所有以Hello开头的文件的修改添加到暂存区 例如:HelloWorld.txt,Hello.java,HelloGit.txt ...$ git add Hello*# 将以Hello开头后面只有一位的文件的修改提交到暂存区 例如:Hello1.txt,HelloA.java 如果是HelloGit.txt或者Hello.java是不会被添加的$ git add Hello? git commit 详解用于将更改记录(提交)到存储库1234567891011# 普通提交填写提交信息$ git commit -m \"the commit message\"# 将所有已跟踪文件中的执行修改或删除操作的文件都提交到本地仓库，即使它们没有经过git add添加到暂存区，# 然后提交(有点像svn的一次提交,不用先暂存)。# 对于没有track的文件,还是需要执行`git add &lt;file&gt;` 命令。$ git commit -a$ git commit -a -m \"the commit message\"# 增补提交（修改上次提交），会使用与当前提交节点相同的父节点进行一次新的提交，旧的提交将会被取消。$ git commit --amend git remote 详解git remote 命令管理一组跟踪的存储库1234567891011121314151617181920212223242526272829# 查看当前的远程库# 列出已经存在的远程分支$ git remote# 列出详细信息，在每一个名字后面列出其远程url$ git remote [-v | --verbose]# 添加一个名字为 &lt;name&gt; 的 远程服务器# $ git remote add &lt;name&gt; &lt;url&gt;$ git remote add [-t &lt;branch&gt;] [-m &lt;master&gt;] [-f] [--[no-]tags] [--mirror=&lt;fetch|push&gt;] &lt;name&gt; &lt;url&gt;# 重命名 远程链接$ git remote rename &lt;old&gt; &lt;new&gt;# 删除 远程链接$ git remote remove &lt;name&gt;$ git remote set-head &lt;name&gt; (-a | --auto | -d | --delete | &lt;branch&gt;)$ git remote set-branches [--add] &lt;name&gt; &lt;branch&gt;…​# 获取 &lt;name&gt; 远程服务 地址$ git remote get-url [--push] [--all] &lt;name&gt;# 设置 &lt;name&gt; 远程服务 地址$ git remote set-url [--push] &lt;name&gt; &lt;newurl&gt; [&lt;oldurl&gt;]# eg: git remote set-url [ 裸仓库名称/常用origin]$ git remote set-url --add [--push] &lt;name&gt; &lt;newurl&gt;$ git remote set-url --delete [--push] &lt;name&gt; &lt;url&gt;$ git remote [-v | --verbose] show [-n] &lt;name&gt;…​$ git remote prune [-n | --dry-run] &lt;name&gt;…​$ git remote [-v | --verbose] update [-p | --prune] [(&lt;group&gt; | &lt;remote&gt;)…​] git push 详解将修改添加到暂存区 语法12# 命令用于将本地分支的更新，推送到远程主机。与git pull命令相似。$ git push &lt;远程主机名/缺省&gt; &lt;本地分支名/缺省&gt;:&lt;远程分支名/缺省&gt; 示例origin 可通过 .git config 查看地址 完整示例12# 将本地的master分支推送到origin主机的master分支。如果master不存在，则会被新建。$ git push origin master 本地分支名 缺省表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。1234# 表示删除origin主机的master分支$ git push origin :master# 等同于$ git push origin --delete master 本地分支、远程分支都 缺省表示推送特定主机的对应分支简写方式：如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。12# 将当前分支推送到origin主机的对应分支$ git push origin 远程主机名、本地分支、远程分支都 缺省表示推送origin 主机的对应分支简写方式：如果当前分支只有一个追踪分支，那么主机名都可以省略。12# 将当前分支推送到 预设 主机【默认origin】的对应分支$ git push当前分支与多个主机存在追踪关系，则可以使用-u 选项指定一个默认主机，这样后面就可以不加任何参数使用 git push12# 将本地的master分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用git push了$ git push -u origin master simple 方式 和 matching 方式不带任何参数的 git push，默认只推送当前分支，这叫做 simple 方式matching 方式，会推送所有有对应的远程分支的本地分支Git 2.0 版本之前，默认采用 matching 方法，现在改为默认采用 simple 方式如果要修改这个设置，可以采用 git config 命令123$ git config --global push.default matching# 或者$ git config --global push.default simple12345678910111213141516171819202122232425# 不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机# 所有本地分支都推送到origin主机$ git push --all origin# 使用-–force选项，结果导致在远程主机产生一个”非直进式”的合并(non-fast-forward merge)$ git push --force origin# git push不会推送标签(tag)，除非使用–tags选项$ git push origin --tags# 推送tag$ git push origin tag_name# 删除远程标签$ git push origin :tag_name# 将当前分支推送到远程的同名分支$ git push origin HEAD# 将当前所在指针分支 推送到 远程的master分支$ git push origin HEAD:master# 用本地分支 dev 覆盖远程分支 dev_op$ git push -f origin dev:refs/dev_op# or$ git push origin :refs/dev //删除远程的dev分支$ git push origin dev:refs/dev_op git branch 详解用于列出，创建或删除分支 语法123456789101112# 查看分支$ git branch [-r | -a]# 新建分支$ git branch [-f] &lt;branchname&gt;# 重命名分支 使用-M则表示强制重命名$ git branch (-m | -M) &lt;oldbranch&gt; &lt;newbranch&gt;# 删除分支 使用-D则表示强制删除，相当于 --delete --force$ git branch (-d | -D) &lt;branchname&gt;使用-d 在删除前 Git 会判断在该分支上开发的功能是否被 merge 的其它分支。如果没有，不能删除。如果 merge 到其它分支，但之后又在其上做了开发，使用-d 还是不能删除。-D 会强制删除 示例12345678910111213141516171819202122232425# 查看分支$ git branch# 列出所有远程分支$ git branch -r# 查看本地和远程分支$ git branch -a# 查看本地分支对应的远程分支$ git branch -vv# 新建一个名字为 dev2 的分支$ git branch dev2# 修改分支的名字#你需要重命名远程分支，推荐的做法是：1.删除远程待修改分支 2.push本地新分支名到远程$ git branch -m dev2# 删除本地分支$ git branch -d &lt;branchname&gt;# 删除远程分支$ git branch -d -r &lt;branchname&gt;$ git push origin :&lt;branchname&gt;# OR$ git branch$ git push origin --delete dev2 git checkout 详解用于切换分支或恢复工作树文件。这条命令会重写工作区123456789101112131415161718192021222324252627282930313233343536# 切换 &lt;branch&gt; 分支$ git checkout &lt;branch&gt;# 从 &lt;branch&gt; 分支 提交中取出文件$ git checkout &lt;branch&gt; &lt;fileName&gt;# 从暂存区（index） 恢复文件$ git checkout &lt;fileName&gt;# 新建 &lt; branch &gt; 分支 并进行切换$ git checkout -b &lt;branch&gt;$ git checkout -b|-B &lt;new_branch&gt; [&lt;start point&gt;] # 完整版# 相当于 执行# git branch newBranch# git checkout newBranch# 换到newBranch的远程分$ git checkout -b newBranch origin/newBranch# 检出索引中的 fileName文件$ git checkout -- &lt;fileName&gt;# 检出索引中的 fileName文件$ git checkout -- &lt;fileName&gt;# 用于检出某一个指定文件# 不填写commit id，则默认会从暂存区检出该文件，如果暂存区为空，则该文件会回滚到最近一次的提交状态$ git checkout [-q] [&lt;commit id&gt;] [--] &lt;paths&gt;# 当暂存区为空，如果我们想要放弃对某一个文件的修改，可以用这个命令进行撤销$ git checkout [-q] [--] &lt;paths&gt;# 新建的分支，严格意义上说，还不是一个分支，因为HEAD指向的引用中没有commit值，只有在进行一次提交后，它才算得上真正的分支$ git checkout --orphan &lt;new_branch&gt;# 将当前分支修改的内容一起打包带走，同步到切换的分支下 [切换到新分支后，当前分支修改过的内容就丢失了]$ git checkout --merge &lt;branch&gt;$ git checkout -m &lt;branch&gt; 例子12345678910111213141516171819202122#//取出master版本的head。$ git checkout master#//在当前分支上 取出 tag_name 的版本$ git checkout tag_name#//放弃当前对文件file_name的修改$ git checkout master file_name#//取文件file_name的 在commit_id是的版本。commit_id为 git commit 时的sha值。$ git checkout commit_id file_name# 从远程dev/1.5.4分支取得到本地分支/dev/1.5.4$ git checkout -b dev/1.5.4 origin/dev/1.5.4#这条命令把hello.rb从HEAD中签出.$ git checkout -- hello.rb# 检出索引中的所有C源文件$ git checkout -- '*.c'#这条命令把 当前目录所有修改的文件 从HEAD中签出并且把它恢复成未修改时的样子.#注意：在使用 git checkout 时，如果其对应的文件被修改过，那么该修改会被覆盖掉。$ git checkout . git reset 详解123456789$ git reset [ –-soft | -–mixed | -–hard] &lt;commit&gt;# git reset &lt;commit&gt; 的意思就是 把HEAD移到&lt;commit&gt;# --soft 这个只是把 HEAD 指向的 commit 恢复到你指定的 commit，暂存区 工作区不变# --hard 这个是 把 HEAD， 暂存区， 工作区 都修改为 你指定的 commit 的时候的文件状态# --mixed 这个是不加时候的默认参数，把 HEAD，暂存区 修改为 你指定的 commit 的时候的文件状态，工作区保持不变# 取消暂存区 部分文件（files 代表多个）的修改$ git reset HEAD --&lt; files &gt; git cherry-pick 详解语法123456789$ git cherry-pick [&lt;options&gt;] &lt;commit-ish&gt;...# 常用options:# --quit 退出当前的chery-pick序列# --continue 继续当前的chery-pick序列# --abort 取消当前的chery-pick序列，恢复当前分支# -n, --no-commit 不自动提交# -e, --edit 编辑提交信息 git submodule 详解命令用于初始化，更新或检查子模块12345678910111213$ git submodule status [--cached] [--recursive] [--] [&lt;path&gt;…​]# 添加 子模块 路径为 相关信息保存在 .gitmodules 文件$ git submodule add &lt;url&gt; [&lt;path&gt;]# 初始化本地配置文件$ git submodule init [--] [&lt;path&gt;…​]# 检出父仓库列出的commit$ git submodule update# 使用组合指令$ git submodule update --init --recursive git 原理 git 工作解析图下面这个图展示了工作区、版本库中的暂存区和版本库之间的关系： git 文件目录COMMIT_EDITMSGconfig 当前 git 的配置文件description （仓库的描述信息文件）HEAD （指向当前所在的分支），例如当前在 develop 分支，实际指向地址是 refs/heads/develophooks [文件夹]indexinfo [文件夹]logs [文件夹]objects [文件夹] （存放所有的 git 对象，对象哈希值前 2 位作为文件夹名称，后 38 位作为对象文件名, 可通过 git cat-file -p 命令，拼接文件夹名称+文件名查看）ORIG_HEADrefs [文件夹]• heads （存放当前项目的所有分支）• tags (存放的当前项目的所有标签，又叫做里程碑) commit 与 tree 和 blob 的关系12345commit 对应一个treetree 包含文件[blob]，如果下级还是文件夹，则又是一个treeblob 是tree下面具体文件 【与文件名无关具体到文件内容】 git 注意事项checkout reset 慎用禁止向集成分支[多人使用分支] 执行 push -f [强制更新到远端 可能会导致远端所在分支回退很多版本]如果单人自行分支，确认是要返回某个节点， 使用 push -f公共分支修改 commit ： git reflog 命令查找历史，然后利用 git reset --hard [提交版本号|缺省] 的方式恢复公共分支 禁止进行 rebase 变基操作对于自己在本地的多次 commit，我想把他合并成一次 commit，还没有 push 的情况下,使用 rebase 常见缩写1234567891011121314-d --delete：删除-D --delete --force的快捷键-f --force：强制-m --move：移动或重命名-M --move --force的快捷键-r --remote：远程-a --all：所有","categories":[{"name":"工具","slug":"工具","permalink":"http://mcdowell8023.github.io/categories/工具/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://mcdowell8023.github.io/tags/笔记/"},{"name":"git","slug":"git","permalink":"http://mcdowell8023.github.io/tags/git/"}]},{"title":"git常用命令","slug":"git常用命令","date":"2019-08-21T03:23:21.000Z","updated":"2020-03-29T09:59:23.193Z","comments":true,"path":"2019/08/21/git常用命令/","link":"","permalink":"http://mcdowell8023.github.io/2019/08/21/git常用命令/","excerpt":"","text":"git 常用命令清单转载 阮老师博客 部分修改 说明Workspace：工作区Index / Stage：暂存区Repository：仓库区（或本地仓库）Remote：远程仓库 一、新建代码库12345678# 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url] 二、配置Git 的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。123456789# 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name \"[name]\"$ git config [--global] user.email \"[email address]\" 三、增加/删除文件1234567891011121314151617181920212223# 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p# 移除文件$ git rm -f *# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed] 四、代码提交123456789101112131415161718# 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ... 五、分支123456789101112131415161718192021222324252627282930313233343536373839404142# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -d -r [remote/branch] 六、标签1234567891011121314151617181920212223242526# 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag] 七、查看信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263# 通过图像方式查看提交历史gitk# 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其\"提交说明\"必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat \"@&#123;0 day ago&#125;\"# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog 八、远程同步1234567891011121314151617181920212223# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all 九、撤销123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475# 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 从仓库取出file覆盖当前分支$ git checkout branch|tag|commit -- file_name# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 取消已经暂存的文件$ git reset HEAD *# 同上$ git reset --mixed HEAD *# 重置到指定状态，不会修改索引区和工作树$ git reset --soft HEAD *# 重置到指定状态，会修改索引区和工作树$ git reset --hard HEAD *# 重置index区文件$ git reset -- files#撤销前一次操作$ git revert HEAD#撤销前前一次操作$ git revert HEAD~# 撤销指定操作commit 所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]# 暂时将未提交的变化移除，稍后再移入# 将工作区现场（已跟踪文件）储藏起来，等以后恢复后继续工作。$ git stash# 查看保存的工作现场$ git stash list# 恢复工作现场$ git stash apply# 删除stash内容$ git stash drop# 恢复的同时直接删除stash内容$ git stash pop# 恢复指定的工作现场，当你保存了不只一份工作现场时$ git stash apply stash@&#123;0&#125; 十、子仓库 git submodule12345678910111213141516171819# 添加子仓库$ git submodule add &lt;仓库地址&gt; &lt;本地路径&gt;# 检出子仓库# 初始化本地配置文件$ git submodule init# 检出父仓库列出的commit$ git submodule update# 或者使用组合指令。$ git submodule update --init --recursive# 删除子仓库# 1删除.gitsubmodule里相关部分# 2删除.git/config 文件里相关字段# 3删除子仓库目录。$ git rm -r --cached &lt;本地路径&gt; 十一、其他12# 生成一个可供发布的压缩包$ git archive","categories":[{"name":"工具","slug":"工具","permalink":"http://mcdowell8023.github.io/categories/工具/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://mcdowell8023.github.io/tags/笔记/"},{"name":"git","slug":"git","permalink":"http://mcdowell8023.github.io/tags/git/"},{"name":"命令","slug":"命令","permalink":"http://mcdowell8023.github.io/tags/命令/"},{"name":"速查","slug":"速查","permalink":"http://mcdowell8023.github.io/tags/速查/"}]},{"title":"hexo博客-常见问题","slug":"hexo博客-常见问题","date":"2019-07-17T16:15:05.000Z","updated":"2019-08-30T11:45:08.090Z","comments":true,"path":"2019/07/18/hexo博客-常见问题/","link":"","permalink":"http://mcdowell8023.github.io/2019/07/18/hexo博客-常见问题/","excerpt":"","text":"博客在 github 访问访问慢？在 coding page 上部署实现国内外分流申请 coding 账户，新建项目 同 GitHub添加 ssh key 同 GitHub修改_config.yml12345deploy: type: git repo: github: &lt;github项目地址 url&gt;,master coding: &lt;coding项目地址 url&gt;,master部署12hexo ghexo dcoding 控制台 开启 pages菜单目录中 -&gt; 代码 pages 服务注意：本地电脑之前 没有与 远端托管服务器[ github、coding等 ] 建立过ssh连接，部署会报错[ 即使已经在远端配置好了ssh公钥 ]。可以先用本地电脑与远端进行 ssh -T git@github.com 进行测试 或者 项目克隆。 第三方主题 没有办法上传到自己的项目中？在使用第三方主题的时候，难免要对主题进行微调。但是调整后的主题文件 是无法上传上去的。这时候，你换台电脑来写博客，就还得再来一遍。【别问我，我是怎么知道的 😂】其实第三方主题是别人的项目，你修改后自认是无法提交到别人的项目上。那么针对上面问题，有两个解决办法：删掉 第三方主题 的.git &lt; 好用但不推荐 &gt;git 不能嵌套上传，最好是显示隐藏文件，检查一下有没有，否则上传的时候会出错，导致你的主题文件无法上传使用 Git 的 Submodulefor 主题的仓库到自己的目录下 【喂，for 就不用说了吧】然后先删掉你原来主题文件 【❗️ 备份 ❗ 备份 ️❗️ 备份】1git rm -r --cached themes/&lt; 主题目录 &gt;添加 submodlue1git submodule add &lt; for后的主题仓库地址 &gt; themes/&lt; 主题目录 &gt;当前工程根路径下生成一个名为“.gitmodules”的文件123[submodule \"themes/主题\"]path = themes/主题url = https://github.com/wuchong/jacman.git # 主题地址单独提交修改后的主题【这是你还原主题更改的好时候】12345cd themes/&lt; 主题目录 &gt;git add .git commit -m \"我只是对主题进行了一些调整\"git push origin master //这是提交到fork后主题的仓库然后返回博客项目根目录 进行正常提交就好在新电脑上 clone 后 npm install 之前要去下载 主题123cd themes/&lt; 主题目录 &gt;git submodule initgit submodule update # 获取我的主题的配置注意：一定要切换到对应分支【 同时注意更新下来的版本 】 关于博客版本管理关于 hexo 博客的机制是这样的：由于 hexo d 上传部署到 github 的 pages 服务其实是 hexo 编译后的文件，是用来生成网页的，不包含源文件。那么我们写博客的源文件总要放到网上去托管啊。那么新建仓库，直接上传到 github？这样算上刚刚 for 的主题，再加上 主页的 pages 服务的主页，一个博客用了三个仓库。貌似有点浪费资源。那么。。。可以在主页仓库[pages 服务的仓库]的其他分支上传源码在下面，其实就是 git 的知识了，然而还是贴上吧1234567# 在github仓库上，创建hexo 分支，用于存放源码git remote -v #查看远程版本库信息git remote add github &lt;url&gt; #添加github远程版本库git fetch github hexo #拉取远程版本库git merge -h #查看合并帮助信息git merge --allow-unrelated-histories github/heox # 对github上的heox分支与本地master分支进行合并（两分支不是父子关系，所以合并需要添加 --allow-unrelated-histories）git push github hexo #推送同步到github仓库 的 hexo记得 fetch,pull,push 的时候 一定要 带着分支 相关连接基于 Hexo 的博客同步中的一些问题 相关文章hexo博客-建站","categories":[{"name":"技术帖","slug":"技术帖","permalink":"http://mcdowell8023.github.io/categories/技术帖/"}],"tags":[{"name":"hexoBlog","slug":"hexoBlog","permalink":"http://mcdowell8023.github.io/tags/hexoBlog/"}]},{"title":"hexo博客-建站","slug":"hexo博客-建站","date":"2019-07-17T16:14:13.000Z","updated":"2019-08-30T09:38:03.621Z","comments":true,"path":"2019/07/18/hexo博客-建站/","link":"","permalink":"http://mcdowell8023.github.io/2019/07/18/hexo博客-建站/","excerpt":"","text":"安装启动依赖：Node.js (Should be at least nodejs 6.9) / Git 安装 Hexo1npm install -g hexo-cli 建站123hexo init &lt;blogName&gt;cd &lt;blogName&gt;npm install 目录介绍12345678 .├── _config.yml # 博客项目配置文件├── package.json # 依赖包，不多少├── scaffolds # 文章模版 可以根据现有模版自定义├── source # 存放用户资源的地方| ├── _drafts| └── _posts # 文章存放目录└── themes # 主题source :资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。 修改配置12345678910vim _config.yml# 修改信息# Sitetitle: # 例如 mcdowell博客subtitle: # 例如 博客+笔记description: # 例如 javascript/vue/react/node OR 其他 笔记帖以及日常磨叨keywords: # 例如 web js vue react nodejsauthor: # 例如 mcdowelllanguage: # 例如 zh-CNtimezone:更多详细配置 见 hexo 本地启动12hexo g # g -&gt; generate 生成静态文件hexo s # s -&gt; server 启动项目然后你就见到 你的 项目了 更换主题去 hexo 官网挑选心仪主题找到主题 github 地址12git clone &lt;github 地址&gt; themes/&lt;主题名称&gt;#eg git clone https://github.com/blleng/hexo-theme-lx themes/lx修改配置 _config.yml123vim _config.yml# 修改配置theme: &lt;主题名称&gt; # eg: lx 新建文章 新建默认模版文章1hexo new &lt;title&gt;可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局 新建指定模版文章12hexo new &lt;模版名称&gt; \"文章标题\"# eg: hexo new photo \"My Gallery\" 准备 github GitHub 创建个人仓库准备 github 账号New repository，新建仓库创建一个和你用户名相同的仓库，后面加.github.io只有这样，将来要部署到 GitHub page 的时候，才会被识别，也就是 xxxx.github.io，其中 xxx 就是你注册 GitHub 的用户名。 生成 SSH 添加到 GitHub 本地电脑生成 ssh 密钥初始化 git 信息12git config --global user.name &quot;yourname&quot;git config --global user.email &quot;youremail&quot;生成密钥1ssh-keygen -t rsa -C &quot;youremail&quot;找到.ssh 下的 id_rsa.pub 文件，里面存放的就是密钥信息，可以对应添加到 github生成的 id_rsa 是私钥 生成的 id_rsa.pub 是公钥 将 hexo 部署到 GitHub修改配置 _config.yml123456vim _config.yml# 修改配置deploy:type: gitrepo: https://github.com/YourgithubName/YourgithubName.github.io.git # gitub 地址branch: master安装 deploy-git 用于部署1npm install hexo-deployer-git --save然后 三部曲123456hexo clean # 清理hexo generate # 生成静态文件hexo deploy # 部署推到远端# 缩写hexo g -d # -&gt; hexo generate --deploy然后浏览器打开 https://YourgithubName.github.io 【YourgithubName 是你的 githu 账户名称】 就可以访问了 关于留言功能valine :[https://valine.js.org/]为博客添加 Gitalk 评论插件 :[https://www.jianshu.com/p/78c64d07124d] 推荐相关连接Hexo 博客常用插件及用法GitHub+Hexo 搭建个人网站详细教程hexo 史上最全搭建教程 相关文章hexo博客-常见问题","categories":[{"name":"技术帖","slug":"技术帖","permalink":"http://mcdowell8023.github.io/categories/技术帖/"}],"tags":[{"name":"hexoBlog","slug":"hexoBlog","permalink":"http://mcdowell8023.github.io/tags/hexoBlog/"}]}]}