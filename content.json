{"meta":{"title":"mcdowell博客","subtitle":"博客+笔记","description":"javascript/vue/react/node OR 其他 笔记帖以及日常磨叨","author":"mcdowell","url":"http://mcdowell8023.github.io"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2019-08-30T09:38:03.620Z","updated":"2019-08-30T09:38:03.620Z","comments":false,"path":"/404.html","permalink":"http://mcdowell8023.github.io//404.html","excerpt":"","text":""},{"title":"关于","date":"2019-08-30T09:38:03.622Z","updated":"2019-08-30T09:38:03.622Z","comments":false,"path":"about/index.html","permalink":"http://mcdowell8023.github.io/about/index.html","excerpt":"","text":"123456789101112131415161718192021222324252627// initlet me = nullconst timeAxis = ['1991', '2013', '2016', '2017', 'today']const person = function(name, sex) &#123; return &#123; name: name, sex: sex &#125;&#125;// thentimeAxis.map(year =&gt; &#123; if (year === '1991') &#123; me = new person('mcdowell', 'male') &#125; if (year === '2013') &#123; me.college = '邯郸学院' &#125; if (year === '2016') &#123; me.job = 'coder' me.skills = ['html', 'css', 'js', 'JQ'] &#125; if (year === '2017') &#123; me.skills = [...me.skills, 'react', 'vue'] &#125;&#125;)// checkconsole.log(me, '个人简介')"},{"title":"书单","date":"2019-08-30T09:38:03.622Z","updated":"2019-08-30T09:38:03.622Z","comments":false,"path":"books/index.html","permalink":"http://mcdowell8023.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-08-30T09:38:03.622Z","updated":"2019-08-30T09:38:03.622Z","comments":false,"path":"categories/index.html","permalink":"http://mcdowell8023.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-08-30T09:38:03.622Z","updated":"2019-08-30T09:38:03.622Z","comments":true,"path":"links/index.html","permalink":"http://mcdowell8023.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2019-08-30T09:38:03.622Z","updated":"2019-08-30T09:38:03.622Z","comments":false,"path":"repository/index.html","permalink":"http://mcdowell8023.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-08-30T09:38:03.623Z","updated":"2019-08-30T09:38:03.623Z","comments":false,"path":"tags/index.html","permalink":"http://mcdowell8023.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"git 学习笔记","slug":"git-学习笔记","date":"2019-08-28T08:37:24.000Z","updated":"2019-08-30T09:38:03.621Z","comments":true,"path":"2019/08/28/git-学习笔记/","link":"","permalink":"http://mcdowell8023.github.io/2019/08/28/git-学习笔记/","excerpt":"","text":"目录目录1. 安装 git2. 初始化2.1. 基本配置2.1.1. 配置帐号信息2.1.2. 配置别名2.1.3. 查看配置2.1.4. 参数说明2.2. 生成 shh 密钥2.3. 获取 Git 仓库2.3.1. 在现有目录中初始化仓库2.3.2. 克隆现有的仓库2.3.3. 本地已有构建的项目2.4. 不进行版本控制2.4.1. 添加不进行版本控制的文件目录2.4.2. 提交 commit 后，想再忽略一些已经提交的文件3. 常见操作3.1. 查看信息3.1.1. 查看帮助 git help3.1.2. 查看状态 git status3.1.3. 查看变化 git diff3.1.4. 查看日志 git log3.1.5. 查看某个文件的版本历史 git show3.1.6. 图形化查看提交内容 gitk3.2. 更新3.3. 文件重命名3.4. 文件删除3.5. 提交3.6. 撤销&amp;回滚3.6.1. 简单总结3.6.2. 撤销3.6.2.1. 修改文件 尚未提交3.6.2.2. 修改文件 已经提交（git commit）到 本地仓库3.6.3. 回滚3.6.3.1. 还原 远端服务器 提交的代码3.6.3.2. 删除最后一次远程提交3.6.3.3. 回滚某次提交3.6.3.4. 删除某次提交3.7. 操作标签3.7.1. 创建标签3.7.2. 查看标签3.7.3. 删除标签3.8. 操作分支3.8.1. 查看分支3.8.2. 新建分支3.8.3. 提交到远程分支3.8.4. 删除分支3.8.5. 合并分支3.9. 暂存3.10. 分离头【detached HEAD】3.11. 操作子仓库4. 常用命令详解4.1. git pull 详解4.2. git fetch 详解4.3. git add 详解4.4. git commit 详解4.5. git remote 详解4.6. git push 详解4.6.1. 语法4.6.2. 示例4.6.2.1. 完整示例4.6.2.2. 本地分支名 缺省4.6.2.3. 本地分支、远程分支都 缺省4.6.2.4. 远程主机名、本地分支、远程分支都 缺省4.6.2.5. simple 方式 和 matching 方式4.7. git branch 详解4.7.1. 语法4.7.2. 示例4.8. git checkout 详解4.8.1. 例子4.9. git reset 详解4.10. git cherry-pick 详解4.11. git submodule 详解5. git 原理5.1. git 工作解析图5.2. git 文件目录5.2.1. commit 与 tree 和 blob 的关系5.3. git 注意事项5.4. 常见缩写 1. 安装 git已有？请跳过git 文档地址git 下载地址查看 git 版本1git --version 2. 初始化 2.1. 基本配置 2.1.1. 配置帐号信息1234# 设置 [本仓库 | 全局 | 系统 ] 的 用户名称$ git config [--local | --global | --system] user.name 'Your name'# 设置 [本仓库 | 全局 | 系统 ] 的 用户邮箱$ git config [--local | --global | --system] user.email 'Your email'当然你也可以通过修改 .git 文件目录下面的 config 文件进行修改 2.1.2. 配置别名12345# 配置别名$ git config --global alias.st status # git st$ git config --global alias.co checkout # git co$ git config --global alias.br branch # git br$ git config --global alias.ci commit # git ci 2.1.3. 查看配置1234# 查看配置git config --list [--local | --global | --system]# 根据git哈希值 查看内容 / 查看类型git cat-flie [-p / -t] 2.1.4. 参数说明local：区域为本仓库global: 当前用户的所有仓库system: 本系统的所有用户缺省等同于 local优先级：local &gt; global &gt; system 2.2. 生成 shh 密钥如果你想通过 https 的方式 每次提交输入密码，当然可以跳过此节检查是否已经存在公私钥1234# 查看.ssh目录下是否有密钥 如列表中包含 id_rsa和id_rsa.pub 说明电脑中已经存在公私钥ls -al ~/.ssh# cat ~/.ssh/id_rsa.pub生成密钥123456# 生成秘钥（根据电脑主机）$ ssh-keygen -t rsa# 根据邮箱生成 密钥$ ssh-keygen -t rsa -C \"youremail\"# 执行后 ：建议不要输入，一路回车，生成的 id_rsa 是私钥 生成的 id_rsa.pub 是公钥添加 密钥在对应服务器增加密钥。【github -&gt; setting -&gt; SSH and GPG keys】如果公司是自己搭建的 git 服务（未使用 gitlab），则交给管理员添加。如果使用 gitlab 在设置增加密钥 2.3. 获取 Git 仓库 2.3.1. 在现有目录中初始化仓库12345678910111213# 初始化本地仓库 缺省 为当前目录$ git init ['your_project'/缺省]# git init --bare 建立裸仓库【中心仓库】# 获取状态$ git status# .或*代表全部添加$ git add [file1] [file2] ...# 提交$ git commit -m \"提交message\"# 添加远程源$ git remote add origin [远程地址]# push 同时 设置默认跟踪分支$ git push -u origin master 2.3.2. 克隆现有的仓库1234# 克隆远程仓库到本地 fileName 的文件夹内 【缺省-默认远端名称】$ git clone [url] &lt;fileName/缺省&gt;# 克隆 为 裸仓库【中心仓库】$ git clone --bare [ 连接地址 ] &lt; file bf名称 &gt;从裸仓库 clone 下来的本地仓库可以进行正常的 push 操作， 但是从一般仓库 clone 下来的本地仓库却不行。 这也正是裸仓库存在的意义。 裸仓库一般情况下是作为远端的中心仓库而存在的。 2.3.3. 本地已有构建的项目12345678$ git remote -v #查看远程版本库信息$ git remote add github &lt;url&gt; #添加github远程版本库$ git fetch github #拉取远程版本库$ git merge -h #查看合并帮助信息$ git merge --allow-unrelated-histories github/master# or git pull origin master --allow-unrelated-histories# 对github上的master分支与本地master分支进行合并（两分支不是父子关系，所以合并需要添加 --allow-unrelated-histories）$ git push github #推送同步到github仓库 2.4. 不进行版本控制 2.4.1. 添加不进行版本控制的文件目录项目目录下 新建 .gitignore 文件 ，写入不需要进行版本控制的文件名或文件夹1234567891011121314# 文件示例node_modules # 对 node_modules文件夹及其文件 及 node_modules文件 不进行版本控制doc # 对 [doc文件夹及其子文件 和 名称为doc的文件] 不进行版本控制*doc # 不允许 任何 包含doc字符的 文件夹及其子文件 和 文件（包括.扩展名）不进行版本控制doc/ # 对 [doc文件夹及其下文件] 不进行版本控制*doc/ # 对 [任何 包含doc字符的文件夹及其下文件] 不进行版本控制*.md // 对 .md结尾的文件 不进行版本控制# /* 复合示例 */doc!doc/* # git管doc文件夹，不管doc文件 2.4.2. 提交 commit 后，想再忽略一些已经提交的文件把忽略的文件添加到 .gitignore;通过 git rm – cached &lt; file &gt; 的方式删除掉 git 仓库里面无需跟踪的文件。 3. 常见操作 3.1. 查看信息 3.1.1. 查看帮助 git help12345678# 所有可用的命令都将打印在标准输出上$ git help [--all/-a]# 在标准输出中也会列出有用的Git指南$ git help [--guide/-g]# 显示 git 手册页$ git help git 3.1.2. 查看状态 git statusgit status 命令用于显示工作目录和暂存区的状态。git status 不显示已经 commit 到项目历史中去的信息。看项目历史的信息要使用 git log常用于 git commit 之前, 这样能防止你不小心提交了您不想提交的东西。1234567# 显示工作目录和暂存区的状态$ git status# 只列出所有已经被git管理的且被修改但没提交的文件$ git status -uno# 紧凑的格式输出$ git status -s # or $ git status --short 3.1.3. 查看变化 git diff对比 修改之后还没有暂存起来的内容变化123456789101112131415161718192021222324252627282930313233343536# 工作树中的更改尚未分段进行下一次提交$ git diff# 比较当前文件和暂存区文件差异 git diff$ git diff &lt;file&gt;$ git diff &lt;id1&gt;&lt;id1&gt;&lt;id2&gt; # 比较两次提交之间的差异$ git diff &lt;branch1&gt; &lt;branch2&gt; # 在两个分支之间比较$ git diff --staged # 比较暂存区和版本库差异$ git diff --cached # 比较暂存区和版本库差异$ git diff --stat # 仅仅比较统计信息$ git diff HEAD # 显示工作版本(Working tree)和HEAD的差别$ git diff test # 查看当前目录和另外一个分支(test)的差别# 假定：HEAD、缓存区、工作区中的readme.md文件内容均不相同。# 比较 工作区 &lt;===&gt; HEAD$ git diff HEAD -- readme.md# 比较 工作区 &lt;===&gt; 缓存区$ git diff -- readme.md# 比较 缓存区 &lt;===&gt; HEAD$ git diff --cached -- readme.md# 比较两个提交或分支的差异$ gti diff [分支名称/commit-id] [分支名称/commit-id] --&lt; file &gt;# 对比两个版本的不同$ git diff [commit号] [commit号]# 对比 当前提交版本与上次提交$ git diff HEAD HEAD^[同 HEAD～1]# 对比当前提交版本与上上次（前两次）提交$ git diff HEAD HEAD^^[同HEAD～2]补充说明：一个节点，可以包含多个子节点（checkout 出多个分支）一个节点可以有多个父节点（多个分支合并）是~都是父节点，区别是跟随数字时候，2 是第二个父节点，而~2 是父节点的父节点^和~可以组合使用,例如 HEAD~2^2 3.1.4. 查看日志 git log1234567891011121314# 查看所有分支的历史 git log 等同于它$ git log --all# 查看图形化的 log 地址$ git log --all --graph# 查看单行的简洁历史。$ git log --oneline# 查看最近的四条简洁历史。$ git log --oneline -n4#查看所有分支最近 4 条单行的图形化历史。$ git log --oneline --all -n4 --graph# 跳转到git log 的帮助文档网页$ git help --web log$ git log -1 // 最近一次提交信息 3.1.5. 查看某个文件的版本历史 git show1234// 先查看文件提交历史git log --pretty=oneline [文件名或文件路径] // 例如src/AfterView/common/commonStream.vuegit show [版本号] // 显示具体的某次的改动的修改 3.1.6. 图形化查看提交内容 gitk1234# 在当前目录下输入，弹出图形化界面$ gitk$ gitk --all定制化图形界面 ： view --&gt; new view [勾选 all refs] # 显示全部分支 3.2. 更新使用 git pull 进行更新1234# 按照git branch 设置的默认跟踪的服务器和分支来拉取$ git pull# 实例：拉取远程服务器origin的master分支$ git pull origin master使用 git fetch 进行更新12345678# 将远程仓库的master分支下载到本地当前branch中$ git fetch orgin master# 比较本地的master分支和origin/master分支的差别 $ git log -p master ..origin/master # 进行合并$ git merge origin/master 3.3. 文件重命名先删除文件再添加文件123456# 重命名3步骤 eg: 重命名 readme 为 readme.md$ mv [文件名1] [文件名2] # 重命名文件名1为文件名2$ git add ['文件名'] # 添加新文件 eg: git add readme.md$ git rm ['文件名'] # 删除旧文件 eg: git rm readme# 就可以正常commit直接使用 git 命令123$ git mv ['旧文件名'] ['新文件名'] # git重命名（相当于上面三个步骤）# 就可以正常commit12345# 回滚到对版本号的应提交状态【缺省回滚到最近的一次提交】$ git reset --hard [提交版本号|缺省]# 记录所有HEAD的历史，也就是说当你做reset，checkout等操作的时候，这些操作会被记录在reflog中$ git reflog 3.4. 文件删除先删除文件再添加文件1234$ rm &lt;file&gt; # 删除文件$ git add ['文件名'] # 添加新文件 eg: git add readme.md# 就可以正常commit直接使用 git 命令12# 删除工作区，暂存区 的文件$ git rm &lt;file&gt;如果删除出错 借助 git reset --hard 进行撤销 3.5. 提交1234567891011121314151617181920# 添加新文件$ git add ['文件名' | '.'代表全部]# 查看提交状态【是否有未提交】（不必的） but 能防止你不小心提交了您不想提交的东西# $ git status # 没有未提交的显示 nothing to commit# 提交填写日志$ git commit -m'这里填写提交日志'# 如果发现点问题，那么继续进行了修改# 继续执行 git add . 重新提交，会覆盖上次提交，只以当前为准# $ git commit --amend# 查看日志(不必的)# $ git log# 更新 先更新避免发生冲突$ git pull# 推送到 orgin 远端服务器$ git push 3.6. 撤销&amp;回滚 3.6.1. 简单总结修改了工作区，恢复：git checkoutadd 后，想撤销： git reset HEADcommit 后，想撤销： git reset --hard [需要回退的 commit id] 3.6.2. 撤销 3.6.2.1. 修改文件 尚未提交未执行 git add 操作123# 从暂存区（index） 恢复 文件$ git checkout &lt;fileName&gt;$ git checkout .文件执行了 git add 操作，恢复 文件（index 内回滚）123456789# 取消暂存$ git reset HEAD fileName# 撤销修改$ git checkout &lt; fileName &gt;# 暂存区的 commitid 覆盖工作区修改$ git checkout [commitid] -- &lt;file&gt;# git checkout 5384b04 -- src/pages/AdScreen/components/commonStream.vue // 回退 5384b04 的文件同时对多个文件执行了 git add 操作，本次只想提交其中一部分文件1234$ git add *$ git status# 取消暂存$ git reset HEAD &lt;filename&gt; 3.6.2.2. 修改文件 已经提交（git commit）到 本地仓库修改 git commit 不再产生新的 Commit[ 只能修改最近一次 ]1234# 修改最后一次提交$ git add sample.txt# 代替（或这说修改）上一次提交，不只是修改message。$ git commit --amend -m\"说明\"多次 git commit 撤销到其中某次 Commit1234567891011121314# 修改最后一次提交$ git reset --[soft/hard/mixed] [commit|HEAD]# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit] 3.6.3. 回滚已进行 git push，即已推送到“远程仓库”中。我们将已被提交到“远程仓库”的代码还原操作叫做“回滚”！注意：对远程仓库做回滚操作是有风险的，需提前做好备份和通知其他团队成员！ 3.6.3.1. 还原 远端服务器 提交的代码12345# 根据 tag 还原工作区代码$ git checkout &lt;tag&gt;# 回滚到指定commitID$ git checkout &lt;commitID&gt; &lt;filename&gt; 3.6.3.2. 删除最后一次远程提交使用 revert123$ git revert HEAD$ git push origin master使用 reset123$ git reset --hard HEAD^$ git push origin master -f二者区别：revert 是放弃指定提交的修改，但是会生成一次新的提交，需要填写提交注释，以前的历史记录都在；reset 是指将 HEAD 指针指到指定提交，历史记录中不会出现放弃的提交记录。 3.6.3.3. 回滚某次提交1234# 找到要回滚的 commitID$ git log# 根据 commitID 进行回滚$ git revert commitID 3.6.3.4. 删除某次提交1234567891011# 找到要回滚的 commitID$ git log --oneline -n5# 注意：最后的^号，意思是commit id的前一次提交$ git rebase -i \"commit id\"^ # git rebase -i \"5b3ba7a\"^# 根据交互输入命令修改信息# 合并多个历史版本commit合并$ git rebase -i [父级commit id ]# 合并多个历史版本commit合并$ git rebase -i [开始commit 的父级id] [结束commit id]如果没有指定 结束 commit,那么结束 commit 默认为当前分支最新的 commit，那么 rebase 结束后会自动更新当前分支指向的 commit,如果指定了结束 commit，而且结束 commit 不是当前分支最新的 commit，那么 rebase 后会有生成一个 游离的 head,，而且当前分支指向的 commit 不会更新具体还可参考：Deleting a Git commit在 Git 中，如何『删除』commit？ 3.7. 操作标签标签操作允许为存储库中的特定版本提供有意义的名称。 3.7.1. 创建标签12345678910# 创建标签$ git tag -a 'tag1' -m 'tag1的说明' [HEAD / commit id / 缺省]# -a选项的 标签名称，-m选项的 标签消息。# 缺省：HEAD 要标记特定提交，则使用相应的COMMIT ID而不是HEAD指针# 将 tag1 推送到 origin 远端$ git push origin &lt;tagname&gt;# 一次性推送全部尚未推送到远程的本地标签$ git push origin --tags 3.7.2. 查看标签123456$ git tag# 查看 所有可用的标签$ git tag -l# 查看 tagName标签的 详细信息$ git show tagName 3.7.3. 删除标签1234567891011# 查看 所有可用的标签$ git tag -l# 删除 tagName标签$ git tag -d &lt;tagName&gt;# 删除 远端 tag 标签$ git push origin --delete tag &lt;tagname&gt;# 删除 远端 tag 标签 类似 删除远端分支的做法$ git push origin :refs/tags/标签名 3.8. 操作分支 3.8.1. 查看分支1234# 查看分支git branch -v# 查看本地分支对应的远程分支$ git branch -av 3.8.2. 新建分支1234567891011121314151617# 新建一个名字为 dev2 的分支 (不切换到新分支)$ git branch dev2# 新建一个名字为 dev2 的分支 并切换到该分支$ git checkout -b &lt;branchname&gt;# 从某个版本创建分支 并切换到该分支$ git checkout -b &lt;branchname&gt; [commit号/分支名称]# 创建并切换分支$ git checkout -b &lt;branchname&gt; [commit版本号]# 基于 远端分支 建立 本地分支（远程分支名x） 采用此种方法建立的本地分支会和远程分支建立映射关系$ git checkout -b &lt;本地分支名x&gt; &lt;origin/远程分支名x&gt;/* 相当于分别执行了下面两条命令 */# git branch &lt;branchname&gt;# git checkout &lt;branchname&gt; 3.8.3. 提交到远程分支12345678910$ git push [origin] &lt;分支名称&gt;:&lt;分支名称&gt;# 本地分支push到远程服务器，远程分支与本地分支同名（当然可以随意起名）$ git pull [origin] &lt;分支名称&gt; 更新远程分支到本地# /* 远程分支关联 */$ git branch --set-upstream-to=[origin]/&lt;分支名称&gt;# 接下来就 可以直接pull 或者push 了# 查看关联的分支名称$ git branch -vv[origin] 代指 添加远程裸仓库地址时候，创建的名称 3.8.4. 删除分支123456789# 删除分支 -d是删除 -D 是强制删除$ git branch [-D/-d] &lt;branchname&gt;# 删除远程分支$ git branch -d -r &lt;branchname&gt;$ git push origin :&lt;branchname&gt;# OR$ git branch # 查看分支名称$ git push origin --delete &lt;branchname&gt; 3.8.5. 合并分支fast-forwardfast-forward 方式 合并这种方法相当于直接把 master 分支移动到 test 分支所在的地方，并移动 HEAD 指针1234# 先切换到主分支，为合并分支准备$ git checkout master# 进行合并$ git merge devno-fast-forward 方式 合并这种合并方法会在 master 分支上新建一个提交节点，从而完成合并1234# 先切换到主分支，为合并分支准备$ git checkout master# 进行合并$ git merge –no-ff devsquash 方式 合并squash 和 no-ff 非常类似，区别只有一点不会保留对合入分支的引用12$ git checkout master$ git merge –squash devrebase 方式 合并rebase 与 merge 不同，rebase 会将合入分支上超前的节点在待合入分支上重新提交一遍，变成线性历史1234# 先切换到主分支，为合并分支准备$ git checkout master# 进行合并$ git rebase devcherry-pick 挑拣 合并对已经存在的 commit 进行 再次提交 [选择某些节点进行合并]12$ git cherry-pick &lt;commit id&gt;当执行完 cherry-pick 以后，将会 生成一个新的提交；这个新的提交的哈希值和原来的不同，但标识名 一样；图解 4 种 git 合并分支方法 &gt; git cherry-pick 的使用 3.9. 暂存当收到紧急任务，手里又存在未完成的模块可以先放到暂存区12345678git stash # 暂存git stash list # 查看暂存列表git stash apply [序号/缺省为stash@&#123;0&#125;] # 恢复暂存进度到工作区git stash pop [序号/缺省为stash@&#123;0&#125;] # 恢复暂存进度到工作区并删除# git stash pop = git stash pop stash@&#123;0&#125; 3.10. 分离头【detached HEAD】执行 git checkout [commit 版本号] ，git 会提示显示处于分离头（无分支状态），在此状态下，进行的提交操作不挂到在分支下，直接切换分支，会导致分离头的提交丢失。错误示范：123456789git checkout 15a6686b624 # 检出15a6686b624的提交，到分离头情况git commit -am\"错误示例\" # 创建一次提交git branch -av # 查看分支git checkout marst # 切换到marst 分支 此时git 会提示你，对分离头提交# 最后一次补救git branch [分支名称] [commit版本号]正常使用1234# 使用某个提交创建分支git checkout -b [分支名称] [commit版本号] // 创建并切换分支git checkout -b 本地分支名x origin/远程分支名x // 基于 远端分支 建立 本地分支（远程分支名x） 采用此种方法建立的本地分支会和远程分支建立映射关系 3.11. 操作子仓库12345678910111213141516171819# 添加子仓库$ git submodule add &lt;仓库地址&gt; &lt;本地路径&gt;# 检出子仓库# 初始化本地配置文件$ git submodule init# 检出父仓库列出的commit$ git submodule update# 或者使用组合指令。$ git submodule update --init --recursive# 删除子仓库# 1删除.gitsubmodule里相关部分# 2删除.git/config 文件里相关字段# 3删除子仓库目录。$ git rm -r --cached &lt;本地路径&gt;git submodule 使用小结 4. 常用命令详解 4.1. git pull 详解git pull 相当于从远程获取最新版本并 merge 到本地1234# 按照git branch 设置的默认跟踪的服务器和分支来拉取$ git pull# 实例：拉取远程服务器origin的master分支$ git pull origin mastergit pull 详解12345$ git pull [&lt;options/缺省&gt;] [&lt;远端仓库名称&gt; [&lt;分支名称&gt;…​]]# options : –allow-unrelated-histories 允许无关的历史，这个选项，更多是在更改远程仓库的时候用到# options : –ff 开启fast-forward# options : –no-ff 强行关闭fast-forward方式# options : –ff-only 4.2. git fetch 详解git fetch 相当于是从远程获取最新到本地，不会自动 merge在实际使用中，git fetch 更安全一些使用 git fetch 进行更新12345678# 将远程仓库的master分支下载到本地当前branch中$ git fetch orgin master# 比较本地的master分支和origin/master分支的差别 $ git log -p master ..origin/master # 进行合并$ git merge origin/masterOR123456# 从远程仓库master分支获取最新，在本地建立tmp分支$ git fetch origin master:tmp#將當前分支和tmp進行對比$ git diff tmp#合并tmp分支到当前分支$ git merge tmpgit pull = git fetch + git merge 4.3. git add 详解将修改添加到暂存区12345678910111213141516# 将所有修改添加到暂存区$ git add .# Ant风格添加修改$ git add *# 将文件的修改、文件的删除，添加到暂存区。$ git add -u# 将文件的修改，文件的删除，文件的新建，添加到暂存区$ git add -A# 将以Controller结尾的文件的所有修改添加到暂存区$ git add *Controller# 将所有以Hello开头的文件的修改添加到暂存区 例如:HelloWorld.txt,Hello.java,HelloGit.txt ...$ git add Hello*# 将以Hello开头后面只有一位的文件的修改提交到暂存区 例如:Hello1.txt,HelloA.java 如果是HelloGit.txt或者Hello.java是不会被添加的$ git add Hello? 4.4. git commit 详解用于将更改记录(提交)到存储库1234567891011# 普通提交填写提交信息$ git commit -m \"the commit message\"# 将所有已跟踪文件中的执行修改或删除操作的文件都提交到本地仓库，即使它们没有经过git add添加到暂存区，# 然后提交(有点像svn的一次提交,不用先暂存)。# 对于没有track的文件,还是需要执行`git add &lt;file&gt;` 命令。$ git commit -a$ git commit -a -m \"the commit message\"# 增补提交（修改上次提交），会使用与当前提交节点相同的父节点进行一次新的提交，旧的提交将会被取消。$ git commit --amend 4.5. git remote 详解git remote 命令管理一组跟踪的存储库1234567891011121314151617181920212223242526272829# 查看当前的远程库# 列出已经存在的远程分支$ git remote# 列出详细信息，在每一个名字后面列出其远程url$ git remote [-v | --verbose]# 添加一个名字为 &lt;name&gt; 的 远程服务器# $ git remote add &lt;name&gt; &lt;url&gt;$ git remote add [-t &lt;branch&gt;] [-m &lt;master&gt;] [-f] [--[no-]tags] [--mirror=&lt;fetch|push&gt;] &lt;name&gt; &lt;url&gt;# 重命名 远程链接$ git remote rename &lt;old&gt; &lt;new&gt;# 删除 远程链接$ git remote remove &lt;name&gt;$ git remote set-head &lt;name&gt; (-a | --auto | -d | --delete | &lt;branch&gt;)$ git remote set-branches [--add] &lt;name&gt; &lt;branch&gt;…​# 获取 &lt;name&gt; 远程服务 地址$ git remote get-url [--push] [--all] &lt;name&gt;# 设置 &lt;name&gt; 远程服务 地址$ git remote set-url [--push] &lt;name&gt; &lt;newurl&gt; [&lt;oldurl&gt;]# eg: git remote set-url [ 裸仓库名称/常用origin]$ git remote set-url --add [--push] &lt;name&gt; &lt;newurl&gt;$ git remote set-url --delete [--push] &lt;name&gt; &lt;url&gt;$ git remote [-v | --verbose] show [-n] &lt;name&gt;…​$ git remote prune [-n | --dry-run] &lt;name&gt;…​$ git remote [-v | --verbose] update [-p | --prune] [(&lt;group&gt; | &lt;remote&gt;)…​] 4.6. git push 详解将修改添加到暂存区 4.6.1. 语法12# 命令用于将本地分支的更新，推送到远程主机。与git pull命令相似。$ git push &lt;远程主机名/缺省&gt; &lt;本地分支名/缺省&gt;:&lt;远程分支名/缺省&gt; 4.6.2. 示例origin 可通过 .git config 查看地址 4.6.2.1. 完整示例12# 将本地的master分支推送到origin主机的master分支。如果master不存在，则会被新建。$ git push origin master 4.6.2.2. 本地分支名 缺省表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。1234# 表示删除origin主机的master分支$ git push origin :master# 等同于$ git push origin --delete master 4.6.2.3. 本地分支、远程分支都 缺省表示推送特定主机的对应分支简写方式：如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。12# 将当前分支推送到origin主机的对应分支$ git push origin 4.6.2.4. 远程主机名、本地分支、远程分支都 缺省表示推送origin 主机的对应分支简写方式：如果当前分支只有一个追踪分支，那么主机名都可以省略。12# 将当前分支推送到 预设 主机【默认origin】的对应分支$ git push当前分支与多个主机存在追踪关系，则可以使用-u 选项指定一个默认主机，这样后面就可以不加任何参数使用 git push12# 将本地的master分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用git push了$ git push -u origin master 4.6.2.5. simple 方式 和 matching 方式不带任何参数的 git push，默认只推送当前分支，这叫做 simple 方式matching 方式，会推送所有有对应的远程分支的本地分支Git 2.0 版本之前，默认采用 matching 方法，现在改为默认采用 simple 方式如果要修改这个设置，可以采用 git config 命令123$ git config --global push.default matching# 或者$ git config --global push.default simple12345678910111213141516171819202122232425# 不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机# 所有本地分支都推送到origin主机$ git push --all origin# 使用-–force选项，结果导致在远程主机产生一个”非直进式”的合并(non-fast-forward merge)$ git push --force origin# git push不会推送标签(tag)，除非使用–tags选项$ git push origin --tags# 推送tag$ git push origin tag_name# 删除远程标签$ git push origin :tag_name# 将当前分支推送到远程的同名分支$ git push origin HEAD# 将当前所在指针分支 推送到 远程的master分支$ git push origin HEAD:master# 用本地分支 dev 覆盖远程分支 dev_op$ git push -f origin dev:refs/dev_op# or$ git push origin :refs/dev //删除远程的dev分支$ git push origin dev:refs/dev_op 4.7. git branch 详解用于列出，创建或删除分支 4.7.1. 语法123456789101112# 查看分支$ git branch [-r | -a]# 新建分支$ git branch [-f] &lt;branchname&gt;# 重命名分支 使用-M则表示强制重命名$ git branch (-m | -M) &lt;oldbranch&gt; &lt;newbranch&gt;# 删除分支 使用-D则表示强制删除，相当于 --delete --force$ git branch (-d | -D) &lt;branchname&gt;使用-d 在删除前 Git 会判断在该分支上开发的功能是否被 merge 的其它分支。如果没有，不能删除。如果 merge 到其它分支，但之后又在其上做了开发，使用-d 还是不能删除。-D 会强制删除 4.7.2. 示例12345678910111213141516171819202122232425# 查看分支$ git branch# 列出所有远程分支$ git branch -r# 查看本地和远程分支$ git branch -a# 查看本地分支对应的远程分支$ git branch -vv# 新建一个名字为 dev2 的分支$ git branch dev2# 修改分支的名字#你需要重命名远程分支，推荐的做法是：1.删除远程待修改分支 2.push本地新分支名到远程$ git branch -m dev2# 删除本地分支$ git branch -d &lt;branchname&gt;# 删除远程分支$ git branch -d -r &lt;branchname&gt;$ git push origin :&lt;branchname&gt;# OR$ git branch$ git push origin --delete dev2 4.8. git checkout 详解用于切换分支或恢复工作树文件。这条命令会重写工作区123456789101112131415161718192021222324252627282930313233343536# 切换 &lt;branch&gt; 分支$ git checkout &lt;branch&gt;# 从 &lt;branch&gt; 分支 提交中取出文件$ git checkout &lt;branch&gt; &lt;fileName&gt;# 从暂存区（index） 恢复文件$ git checkout &lt;fileName&gt;# 新建 &lt; branch &gt; 分支 并进行切换$ git checkout -b &lt;branch&gt;$ git checkout -b|-B &lt;new_branch&gt; [&lt;start point&gt;] # 完整版# 相当于 执行# git branch newBranch# git checkout newBranch# 换到newBranch的远程分$ git checkout -b newBranch origin/newBranch# 检出索引中的 fileName文件$ git checkout -- &lt;fileName&gt;# 检出索引中的 fileName文件$ git checkout -- &lt;fileName&gt;# 用于检出某一个指定文件# 不填写commit id，则默认会从暂存区检出该文件，如果暂存区为空，则该文件会回滚到最近一次的提交状态$ git checkout [-q] [&lt;commit id&gt;] [--] &lt;paths&gt;# 当暂存区为空，如果我们想要放弃对某一个文件的修改，可以用这个命令进行撤销$ git checkout [-q] [--] &lt;paths&gt;# 新建的分支，严格意义上说，还不是一个分支，因为HEAD指向的引用中没有commit值，只有在进行一次提交后，它才算得上真正的分支$ git checkout --orphan &lt;new_branch&gt;# 将当前分支修改的内容一起打包带走，同步到切换的分支下 [切换到新分支后，当前分支修改过的内容就丢失了]$ git checkout --merge &lt;branch&gt;$ git checkout -m &lt;branch&gt; 4.8.1. 例子12345678910111213141516171819202122#//取出master版本的head。$ git checkout master#//在当前分支上 取出 tag_name 的版本$ git checkout tag_name#//放弃当前对文件file_name的修改$ git checkout master file_name#//取文件file_name的 在commit_id是的版本。commit_id为 git commit 时的sha值。$ git checkout commit_id file_name# 从远程dev/1.5.4分支取得到本地分支/dev/1.5.4$ git checkout -b dev/1.5.4 origin/dev/1.5.4#这条命令把hello.rb从HEAD中签出.$ git checkout -- hello.rb# 检出索引中的所有C源文件$ git checkout -- '*.c'#这条命令把 当前目录所有修改的文件 从HEAD中签出并且把它恢复成未修改时的样子.#注意：在使用 git checkout 时，如果其对应的文件被修改过，那么该修改会被覆盖掉。$ git checkout . 4.9. git reset 详解123456789$ git reset [ –-soft | -–mixed | -–hard] &lt;commit&gt;# git reset &lt;commit&gt; 的意思就是 把HEAD移到&lt;commit&gt;# --soft 这个只是把 HEAD 指向的 commit 恢复到你指定的 commit，暂存区 工作区不变# --hard 这个是 把 HEAD， 暂存区， 工作区 都修改为 你指定的 commit 的时候的文件状态# --mixed 这个是不加时候的默认参数，把 HEAD，暂存区 修改为 你指定的 commit 的时候的文件状态，工作区保持不变# 取消暂存区 部分文件（files 代表多个）的修改$ git reset HEAD --&lt; files &gt; 4.10. git cherry-pick 详解语法123456789$ git cherry-pick [&lt;options&gt;] &lt;commit-ish&gt;...# 常用options:# --quit 退出当前的chery-pick序列# --continue 继续当前的chery-pick序列# --abort 取消当前的chery-pick序列，恢复当前分支# -n, --no-commit 不自动提交# -e, --edit 编辑提交信息 4.11. git submodule 详解命令用于初始化，更新或检查子模块12345678910111213$ git submodule status [--cached] [--recursive] [--] [&lt;path&gt;…​]# 添加 子模块 路径为 相关信息保存在 .gitmodules 文件$ git submodule add &lt;url&gt; [&lt;path&gt;]# 初始化本地配置文件$ git submodule init [--] [&lt;path&gt;…​]# 检出父仓库列出的commit$ git submodule update# 使用组合指令$ git submodule update --init --recursive 5. git 原理 5.1. git 工作解析图下面这个图展示了工作区、版本库中的暂存区和版本库之间的关系： 5.2. git 文件目录COMMIT_EDITMSGconfig 当前 git 的配置文件description （仓库的描述信息文件）HEAD （指向当前所在的分支），例如当前在 develop 分支，实际指向地址是 refs/heads/develophooks [文件夹]indexinfo [文件夹]logs [文件夹]objects [文件夹] （存放所有的 git 对象，对象哈希值前 2 位作为文件夹名称，后 38 位作为对象文件名, 可通过 git cat-file -p 命令，拼接文件夹名称+文件名查看）ORIG_HEADrefs [文件夹]• heads （存放当前项目的所有分支）• tags (存放的当前项目的所有标签，又叫做里程碑) 5.2.1. commit 与 tree 和 blob 的关系12345commit 对应一个treetree 包含文件[blob]，如果下级还是文件夹，则又是一个treeblob 是tree下面具体文件 【与文件名无关具体到文件内容】 5.3. git 注意事项checkout reset 慎用禁止向集成分支[多人使用分支] 执行 push -f [强制更新到远端 可能会导致远端所在分支回退很多版本]如果单人自行分支，确认是要返回某个节点， 使用 push -f公共分支修改 commit ： git reflog 命令查找历史，然后利用 git reset --hard [提交版本号|缺省] 的方式恢复公共分支 禁止进行 rebase 变基操作对于自己在本地的多次 commit，我想把他合并成一次 commit，还没有 push 的情况下,使用 rebase 5.4. 常见缩写1234567891011121314-d --delete：删除-D --delete --force的快捷键-f --force：强制-m --move：移动或重命名-M --move --force的快捷键-r --remote：远程-a --all：所有","categories":[{"name":"技术帖","slug":"技术帖","permalink":"http://mcdowell8023.github.io/categories/技术帖/"}],"tags":[{"name":"git","slug":"git","permalink":"http://mcdowell8023.github.io/tags/git/"},{"name":"笔记","slug":"笔记","permalink":"http://mcdowell8023.github.io/tags/笔记/"}]},{"title":"git常用命令","slug":"git常用命令","date":"2019-08-21T03:23:21.000Z","updated":"2019-08-30T09:38:03.621Z","comments":true,"path":"2019/08/21/git常用命令/","link":"","permalink":"http://mcdowell8023.github.io/2019/08/21/git常用命令/","excerpt":"","text":"git 常用命令清单转载 阮老师博客 部分修改 说明Workspace：工作区Index / Stage：暂存区Repository：仓库区（或本地仓库）Remote：远程仓库 一、新建代码库12345678# 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url] 二、配置Git 的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。123456789# 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name \"[name]\"$ git config [--global] user.email \"[email address]\" 三、增加/删除文件1234567891011121314151617181920212223# 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p# 移除文件$ git rm -f *# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed] 四、代码提交123456789101112131415161718# 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ... 五、分支123456789101112131415161718192021222324252627282930313233343536373839404142# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -d -r [remote/branch] 六、标签1234567891011121314151617181920212223242526# 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag] 七、查看信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263# 通过图像方式查看提交历史gitk# 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其\"提交说明\"必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat \"@&#123;0 day ago&#125;\"# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog 八、远程同步1234567891011121314151617181920212223# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all 九、撤销123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475# 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 从仓库取出file覆盖当前分支$ git checkout branch|tag|commit -- file_name# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 取消已经暂存的文件$ git reset HEAD *# 同上$ git reset --mixed HEAD *# 重置到指定状态，不会修改索引区和工作树$ git reset --soft HEAD *# 重置到指定状态，会修改索引区和工作树$ git reset --hard HEAD *# 重置index区文件$ git reset -- files#撤销前一次操作$ git revert HEAD#撤销前前一次操作$ git revert HEAD~# 撤销指定操作commit 所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]# 暂时将未提交的变化移除，稍后再移入# 将工作区现场（已跟踪文件）储藏起来，等以后恢复后继续工作。$ git stash# 查看保存的工作现场$ git stash list# 恢复工作现场$ git stash apply# 删除stash内容$ git stash drop# 恢复的同时直接删除stash内容$ git stash pop# 恢复指定的工作现场，当你保存了不只一份工作现场时$ git stash apply stash@&#123;0&#125; 十、子仓库 git submodule12345678910111213141516171819# 添加子仓库$ git submodule add &lt;仓库地址&gt; &lt;本地路径&gt;# 检出子仓库# 初始化本地配置文件$ git submodule init# 检出父仓库列出的commit$ git submodule update# 或者使用组合指令。$ git submodule update --init --recursive# 删除子仓库# 1删除.gitsubmodule里相关部分# 2删除.git/config 文件里相关字段# 3删除子仓库目录。$ git rm -r --cached &lt;本地路径&gt; 十一、其他12# 生成一个可供发布的压缩包$ git archive","categories":[{"name":"技术帖","slug":"技术帖","permalink":"http://mcdowell8023.github.io/categories/技术帖/"}],"tags":[{"name":"git","slug":"git","permalink":"http://mcdowell8023.github.io/tags/git/"},{"name":"命令","slug":"命令","permalink":"http://mcdowell8023.github.io/tags/命令/"},{"name":"速查","slug":"速查","permalink":"http://mcdowell8023.github.io/tags/速查/"}]},{"title":"hexo博客-常见问题","slug":"hexo博客-常见问题","date":"2019-07-17T16:15:05.000Z","updated":"2019-08-30T11:45:08.090Z","comments":true,"path":"2019/07/18/hexo博客-常见问题/","link":"","permalink":"http://mcdowell8023.github.io/2019/07/18/hexo博客-常见问题/","excerpt":"","text":"博客在 github 访问访问慢？在 coding page 上部署实现国内外分流申请 coding 账户，新建项目 同 GitHub添加 ssh key 同 GitHub修改_config.yml12345deploy: type: git repo: github: &lt;github项目地址 url&gt;,master coding: &lt;coding项目地址 url&gt;,master部署12hexo ghexo dcoding 控制台 开启 pages菜单目录中 -&gt; 代码 pages 服务注意：本地电脑之前 没有与 远端托管服务器[ github、coding等 ] 建立过ssh连接，部署会报错[ 即使已经在远端配置好了ssh公钥 ]。可以先用本地电脑与远端进行 ssh -T git@github.com 进行测试 或者 项目克隆。 第三方主题 没有办法上传到自己的项目中？在使用第三方主题的时候，难免要对主题进行微调。但是调整后的主题文件 是无法上传上去的。这时候，你换台电脑来写博客，就还得再来一遍。【别问我，我是怎么知道的 😂】其实第三方主题是别人的项目，你修改后自认是无法提交到别人的项目上。那么针对上面问题，有两个解决办法：删掉 第三方主题 的.git &lt; 好用但不推荐 &gt;git 不能嵌套上传，最好是显示隐藏文件，检查一下有没有，否则上传的时候会出错，导致你的主题文件无法上传使用 Git 的 Submodulefor 主题的仓库到自己的目录下 【喂，for 就不用说了吧】然后先删掉你原来主题文件 【❗️ 备份 ❗ 备份 ️❗️ 备份】1git rm -r --cached themes/&lt; 主题目录 &gt;添加 submodlue1git submodule add &lt; for后的主题仓库地址 &gt; themes/&lt; 主题目录 &gt;当前工程根路径下生成一个名为“.gitmodules”的文件123[submodule \"themes/主题\"]path = themes/主题url = https://github.com/wuchong/jacman.git # 主题地址单独提交修改后的主题【这是你还原主题更改的好时候】12345cd themes/&lt; 主题目录 &gt;git add .git commit -m \"我只是对主题进行了一些调整\"git push origin master //这是提交到fork后主题的仓库然后返回博客项目根目录 进行正常提交就好在新电脑上 clone 后 npm install 之前要去下载 主题123cd themes/&lt; 主题目录 &gt;git submodule initgit submodule update # 获取我的主题的配置注意：一定要切换到对应分支【 同时注意更新下来的版本 】 关于博客版本管理关于 hexo 博客的机制是这样的：由于 hexo d 上传部署到 github 的 pages 服务其实是 hexo 编译后的文件，是用来生成网页的，不包含源文件。那么我们写博客的源文件总要放到网上去托管啊。那么新建仓库，直接上传到 github？这样算上刚刚 for 的主题，再加上 主页的 pages 服务的主页，一个博客用了三个仓库。貌似有点浪费资源。那么。。。可以在主页仓库[pages 服务的仓库]的其他分支上传源码在下面，其实就是 git 的知识了，然而还是贴上吧1234567# 在github仓库上，创建hexo 分支，用于存放源码git remote -v #查看远程版本库信息git remote add github &lt;url&gt; #添加github远程版本库git fetch github hexo #拉取远程版本库git merge -h #查看合并帮助信息git merge --allow-unrelated-histories github/heox # 对github上的heox分支与本地master分支进行合并（两分支不是父子关系，所以合并需要添加 --allow-unrelated-histories）git push github hexo #推送同步到github仓库 的 hexo记得 fetch,pull,push 的时候 一定要 带着分支 相关连接基于 Hexo 的博客同步中的一些问题 相关文章hexo博客-建站","categories":[{"name":"技术帖","slug":"技术帖","permalink":"http://mcdowell8023.github.io/categories/技术帖/"}],"tags":[{"name":"hexoBlog","slug":"hexoBlog","permalink":"http://mcdowell8023.github.io/tags/hexoBlog/"}]},{"title":"hexo博客-建站","slug":"hexo博客-建站","date":"2019-07-17T16:14:13.000Z","updated":"2019-08-30T09:38:03.621Z","comments":true,"path":"2019/07/18/hexo博客-建站/","link":"","permalink":"http://mcdowell8023.github.io/2019/07/18/hexo博客-建站/","excerpt":"","text":"安装启动依赖：Node.js (Should be at least nodejs 6.9) / Git 安装 Hexo1npm install -g hexo-cli 建站123hexo init &lt;blogName&gt;cd &lt;blogName&gt;npm install 目录介绍12345678 .├── _config.yml # 博客项目配置文件├── package.json # 依赖包，不多少├── scaffolds # 文章模版 可以根据现有模版自定义├── source # 存放用户资源的地方| ├── _drafts| └── _posts # 文章存放目录└── themes # 主题source :资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。 修改配置12345678910vim _config.yml# 修改信息# Sitetitle: # 例如 mcdowell博客subtitle: # 例如 博客+笔记description: # 例如 javascript/vue/react/node OR 其他 笔记帖以及日常磨叨keywords: # 例如 web js vue react nodejsauthor: # 例如 mcdowelllanguage: # 例如 zh-CNtimezone:更多详细配置 见 hexo 本地启动12hexo g # g -&gt; generate 生成静态文件hexo s # s -&gt; server 启动项目然后你就见到 你的 项目了 更换主题去 hexo 官网挑选心仪主题找到主题 github 地址12git clone &lt;github 地址&gt; themes/&lt;主题名称&gt;#eg git clone https://github.com/blleng/hexo-theme-lx themes/lx修改配置 _config.yml123vim _config.yml# 修改配置theme: &lt;主题名称&gt; # eg: lx 新建文章 新建默认模版文章1hexo new &lt;title&gt;可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局 新建指定模版文章12hexo new &lt;模版名称&gt; \"文章标题\"# eg: hexo new photo \"My Gallery\" 准备 github GitHub 创建个人仓库准备 github 账号New repository，新建仓库创建一个和你用户名相同的仓库，后面加.github.io只有这样，将来要部署到 GitHub page 的时候，才会被识别，也就是 xxxx.github.io，其中 xxx 就是你注册 GitHub 的用户名。 生成 SSH 添加到 GitHub 本地电脑生成 ssh 密钥初始化 git 信息12git config --global user.name &quot;yourname&quot;git config --global user.email &quot;youremail&quot;生成密钥1ssh-keygen -t rsa -C &quot;youremail&quot;找到.ssh 下的 id_rsa.pub 文件，里面存放的就是密钥信息，可以对应添加到 github生成的 id_rsa 是私钥 生成的 id_rsa.pub 是公钥 将 hexo 部署到 GitHub修改配置 _config.yml123456vim _config.yml# 修改配置deploy:type: gitrepo: https://github.com/YourgithubName/YourgithubName.github.io.git # gitub 地址branch: master安装 deploy-git 用于部署1npm install hexo-deployer-git --save然后 三部曲123456hexo clean # 清理hexo generate # 生成静态文件hexo deploy # 部署推到远端# 缩写hexo g -d # -&gt; hexo generate --deploy然后浏览器打开 https://YourgithubName.github.io 【YourgithubName 是你的 githu 账户名称】 就可以访问了 关于留言功能valine :[https://valine.js.org/]为博客添加 Gitalk 评论插件 :[https://www.jianshu.com/p/78c64d07124d] 推荐相关连接Hexo 博客常用插件及用法GitHub+Hexo 搭建个人网站详细教程hexo 史上最全搭建教程 相关文章hexo博客-常见问题","categories":[{"name":"技术帖","slug":"技术帖","permalink":"http://mcdowell8023.github.io/categories/技术帖/"}],"tags":[{"name":"hexoBlog","slug":"hexoBlog","permalink":"http://mcdowell8023.github.io/tags/hexoBlog/"}]}]}