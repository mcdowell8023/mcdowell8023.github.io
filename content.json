{"meta":{"title":"mcdowell博客","subtitle":"博客+笔记","description":"javascript/vue/react/node OR 其他 笔记帖以及日常磨叨","author":"mcdowell","url":"http://mcdowell8023.github.io"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2019-08-30T09:38:03.620Z","updated":"2019-08-30T09:38:03.620Z","comments":false,"path":"/404.html","permalink":"http://mcdowell8023.github.io//404.html","excerpt":"","text":""},{"title":"书单","date":"2019-08-30T09:38:03.622Z","updated":"2019-08-30T09:38:03.622Z","comments":false,"path":"books/index.html","permalink":"http://mcdowell8023.github.io/books/index.html","excerpt":"","text":""},{"title":"关于","date":"2019-08-30T09:38:03.622Z","updated":"2019-08-30T09:38:03.622Z","comments":false,"path":"about/index.html","permalink":"http://mcdowell8023.github.io/about/index.html","excerpt":"","text":"123456789101112131415161718192021222324252627// initlet me = nullconst timeAxis = ['1991', '2013', '2016', '2017', 'today']const person = function(name, sex) &#123; return &#123; name: name, sex: sex &#125;&#125;// thentimeAxis.map(year =&gt; &#123; if (year === '1991') &#123; me = new person('mcdowell', 'male') &#125; if (year === '2013') &#123; me.college = '邯郸学院' &#125; if (year === '2016') &#123; me.job = 'coder' me.skills = ['html', 'css', 'js', 'JQ'] &#125; if (year === '2017') &#123; me.skills = [...me.skills, 'react', 'vue'] &#125;&#125;)// checkconsole.log(me, '个人简介')"},{"title":"分类","date":"2019-08-30T09:38:03.622Z","updated":"2019-08-30T09:38:03.622Z","comments":false,"path":"categories/index.html","permalink":"http://mcdowell8023.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-08-30T09:38:03.623Z","updated":"2019-08-30T09:38:03.623Z","comments":false,"path":"tags/index.html","permalink":"http://mcdowell8023.github.io/tags/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-08-30T09:38:03.622Z","updated":"2019-08-30T09:38:03.622Z","comments":true,"path":"links/index.html","permalink":"http://mcdowell8023.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2019-08-30T09:38:03.622Z","updated":"2019-08-30T09:38:03.622Z","comments":false,"path":"repository/index.html","permalink":"http://mcdowell8023.github.io/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"Docker笔记(一)","slug":"docker笔记-一","date":"2019-10-28T02:24:19.000Z","updated":"2019-10-28T12:37:23.838Z","comments":true,"path":"2019/10/28/docker笔记-一/","link":"","permalink":"http://mcdowell8023.github.io/2019/10/28/docker笔记-一/","excerpt":"","text":"本文仅以前端视角，接触使用docekr。认识较为肤浅，大神请绕行。关于DockerDocker 是啥Docker 主要用途Docker中的概念安装慢？！修改镜像源地址基本操作镜像操作检索拉取镜像新增 镜像删除 镜像修改 镜像 名称查看 镜像导入、导出、上传 镜像容器操作新增容器删除 容器修改 容器 状态进入 容器查看 容器器与主机之间的数据拷贝导入、导出 容器 关于Docker Docker 是啥Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。它是目前最流行的 Linux 容器解决方案。 Docker 主要用途提供一次性的环境。比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。提供弹性的云服务。因为 Docker 容器可以随开随关，很适合动态扩容和缩容。组建微服务架构。通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。以上摘自阮老师博客 Docker中的概念镜像（image）: 镜像中包含有需要运行的文件。镜像用来创建container，一个镜像可以运行多个container；镜像可以通过Dockerfile创建，也可以从Docker hub/registry上下载。容器（container）: 容器是Docker的运行组件，启动一个镜像就是一个容器，容器是一个隔离环境，多个容器之间不会相互影响，保证容器中的程序运行在一个相对安全的环境中。仓库（repository）: 共享和管理Docker镜像，用户可以上传或者下载上面的镜像，官方地址为 https://registry.hub.docker.com/（类似于github对源代码的管理），也可以搭建自己私有的Docker registry。以上摘自Ant Design Pro 的 Docker 部署方式从我的角度，使用 docker 常常是要解决宿主依赖环境的问题。比如：我是个前端开发从业者，可能有些时候需要在本地 查看 打包编译后的项目真实表现。以前需要本地安装一个Nginx 配好文件，然后启动。现在，只需要编写好dockerfile文件，直接输入命令，就可以在本地查看项目。再者，搭建较为复杂的环境（依赖因为网络等问题过于缓慢），不同开发者需要安装很多东西，不便捷。如，搭建一个gitbook文档项目（支持多个文档），从nodejs ,gitbook, gitbookcli等比较多的依赖全局安装后，还需要安装 gitbook的插件（比较慢，而且还没有较快的国内镜像），才可本地启动。毕竟项目本身只是辅助编写文档，因为环境问题给团队带来困扰，就得不偿失了。 如果，将项目的依赖环境做成镜像，放到自己的内部服务器上，每个需要启动项目的人直接使用docker镜像，那么基本无痛启动项目。 安装安装系统推荐使用 Mac 或者 Linux。Windows不建议使用。《菜鸟教程》的Docker Windows 安装中说的 Docker toolbox（老黄历） 已经无法使用了。官方推荐 安装Docker desktop，需要系统是专业版的。（而且折腾一番，及时能用，跑别人写的Dockerfile 还会碰到问题。过于折腾，本末倒置。）Mac或Windows安装软件地址安装教程：Mac安装ubuntu安装Windows安装1234567# 查看版本 验证成功docker version# 把用户加入 Docker 用户组 避免每次命令都输入sudosudo usermod -aG docker $USER# 启动一个Nginx 验证效果 正常浏览器输入http://localhost/即可访问docker run --detach --publish=80:80 --name=webserver nginx 慢？！修改镜像源地址Docker 修改镜像源地址如果是dockerDesktop 进入设置，找到 Daemon 选项，修改registry-mirrors 选项为：'http://hub-mirror.c.163.com’ [这个是网易的加速镜像]，然后apply &amp;&amp; startinsecure registry 一般 是公司搭建的私服使用 基本操作 镜像操作 检索拉取镜像1234# 1. 检索镜像 或去 &lt;https://hub.docker.com&gt; 进行搜索docker search &lt;Images Name&gt;# 2. 从仓库中拉取 镜像 到本地docker pull &lt;Images Name:tag-缺省为latest&gt;非官方下载 需要加上 仓库地址。如从网易蜂巢的镜像源来下载ubuntu:18.04镜像，可以使用如下命令，此时下载的镜像名称为hub.c.163.com/public/ubuntu:18.04 新增 镜像根据现有容器生成镜像12345678# OPTIONS# -a: 作者信息；# -c: 提交时执行dockerfile指令，包含CMD等# -m: 提交消息# -p: 提交暂停容器运行docker commit [OPTIONS] CONTAINER [镜像名称[:TAG]]# 常用方式 填写信息 作者 镜像名称（不包含大写）docker commit -m'提交消息' -a '作者' &lt;容器ID&gt; &lt;Images Name:tag&gt;本地模版导入123456# OPTIONS# -c: 提交时执行dockerfile指令，包含CMD等# -m: 提交消息docker import [OPTIONS] file|URL|- &lt;Images Name:tag&gt;# eg:cat exampleimage.tgz | docker import - exampleimagelocal:new基于dockerfile创建12345678910# 编写好 dockerfile 后 进行build# OPTIONS# --file , -f Dockerfile的名称（默认为“ PATH / Dockerfile”）# --tag , -t 名称以及“ name：tag”格式的标签（可选）docker build [OPTIONS] &lt;Dockerfile的 PATH | URL | - &gt;# eg:# 使用URL github.com/creack/docker-firefox 的 Dockerfile 创建镜像。docker build github.com/creack/docker-firefox# 使用根目录下的 Dockerfile 创建名称为 lanjiang/gitbook 的镜像docker build -t lanjiang/gitbook . 删除 镜像docker rmi 删除123456# 删除 镜像 (没有使用该镜像的容器 才可删除，不推荐强制删除)docker rmi [-f: 强制删除] &lt;Images Name/ids&gt;# 筛选包含 none 的镜像删除docker rmi $(docker images | grep \"none\" | awk '&#123;print $3&#125;')# 删除全部镜像docker rmi $(docker images -a -q)docker image prune 清除没有被使用的镜像123456# 清除没有被使用的镜像# OPTIONS:# -a 删除所有无用镜像（不光临时镜像）；# -filter filter:只清理给定过滤的镜像；# -f,-force:强制删除docker image prune [OPTIONS] 修改 镜像 名称12# 给镜像添加标签docekr tag &lt;Images Name/id&gt; &lt;new Images Name&gt; 查看 镜像12345# 查看 本地镜像docker images / docker image ls# 查看 本地全部镜像（包含临时镜像）docker images -a 导入、导出、上传 镜像123456# 镜像 导出 和 载入docker save -o &lt;导出名称&gt; &lt;Images Name:tag&gt;# 将镜像 node 生成 /Users/mcdowell/Downloads/ 下的dockderApp.tardocker save -o /Users/mcdowell/Downloads/dockderApp.tar node# ordocker save node &gt; /Users/mcdowell/Downloads/dockderApp11.tar1234# 将/Users/mcdowell/Downloads/ 下的tf-keras.tar 镜像 导入镜像docker load -i /Users/mcdowell/Downloads/tf-keras.tar# ordocker load &lt; /Users/mcdowell/Downloads/tf-keras.tar12# 上传镜像docker push [OPTIONS] NAME[:TAG]123456789# eg:# 本地生成镜像docker commit c16378f943fe rhel-httpd# 给刚生成的镜像打上 源标签docker tag rhel-httpd registry-host:5000/myadmin/rhel-httpd# 上传镜像docker push registry-host:5000/myadmin/rhel-httpd# 如果是官网仓库 （官方仓库省略源地址）docker push myadmin/rhel-httpd 容器操作 新增容器新建123456789101112131415161718192021222324252627# 新建 容器（默认是停止的）docker create &lt;Images Name:version /ID&gt;# 用 XX镜像 新建容器 并启动 （ docker create + docker start ）# OPTIONS 常用说明# -d: 后台运行容器，并返回容器ID；# -i: 以交互模式运行容器，通常与 -t 同时使用；# -P: 随机端口映射，容器内部端口随机映射到主机的高端口# -p: 指定端口映射，格式为：主机(宿主)端口:容器端口# -t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；docker run [OPTIONS] &lt;Images Name:version&gt; [COMMAND] [ARG...]# 用 node 镜像 以交互模式终端 新建容器 并启动docker run -it node bash# 用 ubuntu:18.04 镜像 以交互模式终端 新建容器 并启动docker run -it ubuntu:18.04 /bin/bash# 进入交互模式 使用ctrl+d 或者 exit 退出# 用 lanjiang/gitbook镜像 新建容器 并启动 映射到 80 端口docker run -p 80:80 lanjiang/gitbook# 用 nginx镜像 以守护进行（后台运行）的方式 新建容器 并启动 映射到 80 端口 --默认返回ID号docker run -d -p 80:80 nginx# 使用docker镜像nginx:latest 以后 随机端口 台模式 启动一个容器,并将容器命名为mynginx【需要使用docker port 才可访问】docker run -P -d --name mynginx nginx:latest 删除 容器docker rm 删除1234567# 删除容器 id可以是多个 （容器必须终止才能删除）docker rm &lt;IDs&gt;# 筛选包含 gitbook 的容器删除docker rm $(docker ps -a|grep gitbook|awk '&#123;print $1&#125;')# 删除 全部容器docker rm $(docker ps -a -q)docker container prune 删除12345# 删除暂停的容器# OPTIONS# --filter 提供过滤器值（例如'until ='）# --force , -f 强制删除，不提示docker container prune [OPTIONS] 修改 容器 状态启动、重启12345# 启动 容器docker start &lt;Images Name:version /ID&gt;# 重启 容器docker restart &lt;ID&gt;暂停\\恢复 容器 (保存容器状态）1234# 暂停 容器docker pause &lt;ID&gt;# 恢复 容器docker unpause &lt;ID&gt;终止容器1234# 终止容器 id可以是多个 kill 也可以docker stop &lt;IDs&gt; # 筛选包含 gitbook 的容器终止docker stop $(docker ps -a|grep gitbook|awk '&#123;print $1&#125;') 进入 容器docker attach 进入 容器12345# 默认 CTRL-c不退出当前终端而是 给容器内 程序执行docker attach [OPTIONS] &lt;container Name/ID&gt;# 使用 --sig-proxy=false 避免上述问题docker attach --sig-proxy=false mynginx# 缺点：多个窗口执行时，一个窗口阻塞，其他窗口无法执行docker exec 进入 容器1234567891011# 使用 exec 进入容器#OPTIONS说明：# -d :分离模式: 在后台运行# -i :即使没有附加也保持STDIN 打开# -t :分配一个伪终端docker exec [OPTIONS] &lt;container Name/ID&gt; [\b命令] [ARG...]# 在容器 mynginx 中以交互模式执行容器内 /root/blue.sh 脚本:docker exec -it mynginx /bin/sh /root/blue.sh# 在运行的容器中 以 以交互模式终端 执行 bash 命令docker exec -it &lt;container Name/ID&gt; /bin/bash 查看 容器查看本地容器1234567# 输出 ID容器的 日志docker logs &lt;ID&gt;# 查看 运行的 容器docker ps# 查看全部容器（包含运行和暂停的）docker ps -a # -q:只显示ID查看容器内部信息123456789101112# 查看容器详情docker inspect &lt;container Name/ID&gt;# 查看容器内 进程（容器需要启动）docker top &lt;container Name/ID&gt;# 查看统计信息 （cpu 内存 存储 网络使用情况）docker stats &lt;container Name/ID&gt;# 查看系统变更docker diff &lt;container Name/ID&gt;# 查看 容器 端口映射docker port &lt;container Name/ID&gt; 器与主机之间的数据拷贝12345678# 容器与主机之间的数据拷贝docker cp &lt;path&gt; &lt;path&gt;# 将主机/www/blue目录拷贝到容器63d47d7c0d4c的/www目录下。docker cp /www/blue 63d47d7c0d4c:/www/# 将主机/www/blue目录拷贝到容器 63d47d7c0d4c中，目录重命名为www(此处无斜杠))docker cp /www/blue 63d47d7c0d4c:/www# 将容器 63d47d7c0d4c 的 /www 目录拷贝到主机的 /tmp 目录中。docker cp 63d47d7c0d4c:/www /tmp/ 导入、导出 容器123456# 容器导出docker export -o tf-keras-33f6c8359187.tar &lt;container Name/ID&gt;# ordocker export 33f6c8359187 &gt; tf-keras-33f6c8359187.tar# 导入docker import tf-keras-33f6c8359187.tar与镜像导出（docker save）比较：容器快照文件 将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积更大","categories":[{"name":"技术帖","slug":"技术帖","permalink":"http://mcdowell8023.github.io/categories/技术帖/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://mcdowell8023.github.io/tags/Docker/"},{"name":"笔记","slug":"笔记","permalink":"http://mcdowell8023.github.io/tags/笔记/"}]},{"title":"浏览器全屏api--fullScreen","slug":"浏览器全屏api-fullScreen","date":"2019-09-24T07:40:35.000Z","updated":"2019-10-25T12:02:37.931Z","comments":true,"path":"2019/09/24/浏览器全屏api-fullScreen/","link":"","permalink":"http://mcdowell8023.github.io/2019/09/24/浏览器全屏api-fullScreen/","excerpt":"","text":"fullScreen 浏览器 全屏api本文转载 Fullscreen API工作开发中遇到需要浏览器 全屏。查询api 后，决定使用 requestFullscreen，但是api 存在兼容问题。借助大佬的总结： 启动全屏模式12345678910111213141516// 处理兼容性 调用 全屏apifunction launchIntoFullscreen(element) &#123; if(element.requestFullscreen) &#123; element.requestFullscreen(); &#125; else if(element.mozRequestFullScreen) &#123; element.mozRequestFullScreen(); &#125; else if(element.webkitRequestFullscreen) &#123; element.webkitRequestFullscreen(); &#125; else if(element.msRequestFullscreen) &#123; element.msRequestFullscreen(); &#125;&#125;// 开启全屏 模式 谷歌浏览器 、安卓手机 亲测可用launchIntoFullscreen(document.documentElement); // 整个页面launchIntoFullscreen(document.getElementById(\"videoElement\")); // 或者任意对象 退出全屏模式12345678910// 退出全屏function exitFullscreen() &#123; if(document.exitFullscreen) &#123; document.exitFullscreen(); &#125; else if(document.mozCancelFullScreen) &#123; document.mozCancelFullScreen(); &#125; else if(document.webkitExitFullscreen) &#123; document.webkitExitFullscreen(); &#125;&#125; 全屏属性和事件document.fullScreenElement：已推送到全屏状态的元素。document.fullScreenEnabled：说明当前是否启用了全屏。123/* 兼容写法 */var fullscreenElement = document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement;var fullscreenEnabled = document.fullscreenEnabled || document.mozFullScreenEnabled || document.webkitFullscreenEnabled;实际使用12345678910111213 // 添加事件监听document.addEventListener(\"fullscreenchange\", function(e) &#123; console.log(\"fullscreenchange event! \", e);&#125;);document.addEventListener(\"mozfullscreenchange\", function(e) &#123; console.log(\"mozfullscreenchange event! \", e);&#125;);document.addEventListener(\"webkitfullscreenchange\", function(e) &#123; console.log(\"webkitfullscreenchange event! \", e);&#125;);document.addEventListener(\"msfullscreenchange\", function(e) &#123; console.log(\"msfullscreenchange event! \", e);&#125;); 全屏CSS123456789101112131415161718192021222324252627282930313233:-webkit-full-screen &#123;/* properties */&#125;:-moz-full-screen &#123; /* properties */&#125;:-ms-fullscreen &#123; /* properties */&#125;:full-screen &#123; /*pre-spec */ /* properties */&#125;:fullscreen &#123; /* spec */ /* properties */&#125;/* deeper elements */:-webkit-full-screen video &#123; width: 100%; height: 100%;&#125;/* styling the backdrop*/::backdrop &#123; /* properties */&#125;::-ms-backdrop &#123; /* properties */&#125; 实例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;全屏api测试页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div style=\"padding:20px;\"&gt; &lt;button onclick=\"launchFullscreen(document.documentElement);\" class=\"sexyButton\"&gt;启动全屏&lt;/button&gt; &lt;button onclick=\"exitFullscreen();\" class=\"sexyButton\"&gt;关闭全屏&lt;/button&gt; &lt;button onclick=\"dumpFullscreen();\" class=\"sexyButton\"&gt;转储全屏属性数据&lt;/button&gt; &lt;/div&gt; &lt;!-- 谷歌浏览器 、安卓手机 亲测可用 --&gt;&lt;style&gt;/* 全屏后 样式 */:-webkit-full-screen &#123; background: pink;&#125;:-moz-full-screen &#123; background: pink;&#125;:-ms-fullscreen &#123; background: pink;&#125;:full-screen &#123; /*pre-spec */ background: pink;&#125;:fullscreen &#123; /* spec */ background: pink;&#125;&lt;/style&gt;&lt;script&gt; // 处理兼容性 调用 全屏api function launchFullscreen(element) &#123; if(element.requestFullscreen) &#123; element.requestFullscreen(); &#125; else if(element.mozRequestFullScreen) &#123; element.mozRequestFullScreen(); &#125; else if(element.webkitRequestFullscreen) &#123; element.webkitRequestFullscreen(); &#125; else if(element.msRequestFullscreen) &#123; element.msRequestFullscreen(); &#125; &#125; // 退出全屏 function exitFullscreen() &#123; if(document.exitFullscreen) &#123; document.exitFullscreen(); &#125; else if(document.mozCancelFullScreen) &#123; document.mozCancelFullScreen(); &#125; else if(document.webkitExitFullscreen) &#123; document.webkitExitFullscreen(); &#125; &#125; function dumpFullscreen() &#123; console.log(\"document.fullscreenElement is: \", document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement); console.log(\"document.fullscreenEnabled is: \", document.fullscreenEnabled || document.mozFullScreenEnabled || document.webkitFullscreenEnabled || document.msFullscreenEnabled); &#125; // 添加事件监听 document.addEventListener(\"fullscreenchange\", function(e) &#123; console.log(\"fullscreenchange event! \", e); &#125;); document.addEventListener(\"mozfullscreenchange\", function(e) &#123; console.log(\"mozfullscreenchange event! \", e); &#125;); document.addEventListener(\"webkitfullscreenchange\", function(e) &#123; console.log(\"webkitfullscreenchange event! \", e); &#125;); document.addEventListener(\"msfullscreenchange\", function(e) &#123; console.log(\"msfullscreenchange event! \", e); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"技术帖","slug":"技术帖","permalink":"http://mcdowell8023.github.io/categories/技术帖/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://mcdowell8023.github.io/tags/浏览器/"},{"name":"api","slug":"api","permalink":"http://mcdowell8023.github.io/tags/api/"}]},{"title":"ant-design踩坑：Cascader级联选择","slug":"ant-design踩坑-Cascader级联选择","date":"2019-09-03T11:33:33.000Z","updated":"2019-09-03T16:15:04.137Z","comments":true,"path":"2019/09/03/ant-design踩坑-Cascader级联选择/","link":"","permalink":"http://mcdowell8023.github.io/2019/09/03/ant-design踩坑-Cascader级联选择/","excerpt":"","text":"Cascader 级联选择 遇到的问题 要点级联选择 数据中 isLeaf: false 可以控制是否选中【false 表示不选中】，触发 loadData 函数级联选择 数据中 如果当前层不是最终级【就是你要 id 的那层】，children 一定不能为[],否则会导致组件选中错误层级，不会触发 loadData 函数 详细 交代说明 公司开发后台管理系统，涉及一个地级区域选择的功能，实现效果如下 后台给的接口是根据参数查询省，然后市…,如下 查看官网文档通过官网示例，了解到 采用 动态加载选项 示例的方式，使用 loadData 实现动态加载选项。按照官网的介绍，结合实际接口，我们需要 每次动态修改 根据返回 数据进行 数据拼接。 编码当然后台数据返回的字段与组件预制不同，我们可以借助 fieldNames 属性进行自定义字段。编码 测试组件 时候，你会发现点击第一层的数据就会直接选中【我们要的是最后一层，通信商的 id】。查阅属性说明未果。但是通过示例后发现，数据中 isLeaf: false 可以控制是否选中，从而触发 loadData。貌似准备就绪。然后，愉快的编码点击非 type 是 3 的一层，进行接口调用1234567891011121314151617// Cascader loadData 事件 函数 查询数据const cascaderLoadData = selectedOptions =&gt; &#123; // 点击得到的 一级 或 二级 数据 const targetOption = selectedOptions[selectedOptions.length - 1] const &#123; id, type &#125; = targetOption targetOption.loading = true const newType = type + 1 if (type !== 3) &#123; // 一级 或 二级 数据 // 这里是调用 查询地区接口的函数 getDict(&#123; [newType === 2 ? 'regionId' : 'cityId']: id, webId: id, type: newType &#125;) &#125;&#125;数据拼接,上代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// 这里是 得到后台返回数据 在 reducers 的 数据动态拼接处理// 提供 Cascader optionssaveVPNAddressDict(state, action) &#123; const &#123; params: &#123; type, webId &#125;, res, &#125; = action.payload; const &#123; VPNAddressDict &#125; = state; const pushList = (arr, typeNum) =&gt; &#123; return arr ? arr .map(item =&gt; &#123; if (!item) &#123; return null; &#125; return &#123; ...item, loading: false, isLeaf: typeNum === 3, // 用于控制非 第三层 不能选 children: null, &#125;; &#125;) .filter(item =&gt; item) : []; &#125;; let dicts = []; const dict = pushList(res, type); // 基本思路就是： 根据type 确定层级 当前数据该是第几层 根据 webId 找到应该对应的 数据对象 switch (type) &#123; case 1: // 查询省数据 dicts = [...dict]; break; case 2: // 查询市数据 dicts = VPNAddressDict.map(item =&gt; &#123; if (item.id === webId) &#123; return &#123; ...item, loading: false, children: [...dict], &#125;; &#125; return item; &#125;); break; case 3: // 运营商数据 dicts = VPNAddressDict.map(items =&gt; &#123; const list = items &amp;&amp; items.children ? items.children : []; const children = list.map(item =&gt; &#123; if (item.id === webId) &#123; return &#123; ...item, loading: false, children: [...dict], &#125;; &#125; return item; &#125;); return &#123; ...items, loading: false, isLeaf: false, children, &#125;; &#125;); break; default: dicts = []; break; &#125; return &#123; ...state, VPNAddressDict: dicts, &#125;;然后按照示例使用组件基本完成后。测试发现，如果你依次点击 【 广东 &gt; 广州 &gt; 移动 】（ 选中最后一层），再次选择 【北京】 组件直接选中了 【北京】（直接选中第一层）。多次测试发现只要不点击最后一层，那么不会出现这个问题。分析：根据 bug 出现的情况，可以判断，是执行了 saveVPNAddressDict 动态拼接函数 type= 3 的运营商数据拼接出现的问题。检查代码未发现明显错误。通过打印数据发现，【北京】数据的 children 是个空数组。 凭借多年开发的直觉[🤦‍ 好吧，我也不知道我是怎么知道的]，推测 children 数据问题。验证：自造一条假数据，直接给组件测试使用。数据如下1234567891011121314const options = [ &#123; value: '北京', label: '北京', isLeaf: false, children: [] &#125;, &#123; value: '广东', label: '广东', isLeaf: false, children: [] &#125;]验证结果发现，children 字段如果是数组，会导致直接选中，不会触发 loadData。8.修正。那么在函数执行时候，如果没被选中的 children 显示为 null。 修正如下1234567891011121314151617181920212223// saveVPNAddressDict case 3的代码片段case 3: // 运营商数据 dicts = VPNAddressDict.map(items =&gt; &#123; const list = items &amp;&amp; items.children ? items.children : []; const children = list.map(item =&gt; &#123; if (item.id === webId) &#123; return &#123; ...item, loading: false, children: [...dict], &#125;; &#125; return item; &#125;); return &#123; ...items, loading: false, isLeaf: false, children:children.length?children:null, &#125;; &#125;); break; 总结级联选择 数据中 isLeaf，children 两个字段直接影响 是否被选中，loadData 是否会触发。","categories":[{"name":"技术帖","slug":"技术帖","permalink":"http://mcdowell8023.github.io/categories/技术帖/"}],"tags":[{"name":"ant-design","slug":"ant-design","permalink":"http://mcdowell8023.github.io/tags/ant-design/"},{"name":"踩坑","slug":"踩坑","permalink":"http://mcdowell8023.github.io/tags/踩坑/"},{"name":"react","slug":"react","permalink":"http://mcdowell8023.github.io/tags/react/"}]},{"title":"git 学习笔记","slug":"git-学习笔记","date":"2019-08-28T08:37:24.000Z","updated":"2020-03-23T05:50:30.128Z","comments":true,"path":"2019/08/28/git-学习笔记/","link":"","permalink":"http://mcdowell8023.github.io/2019/08/28/git-学习笔记/","excerpt":"","text":"目录目录安装 git初始化基本配置配置帐号信息配置别名查看配置参数说明生成 shh 密钥获取 Git 仓库在现有目录中初始化仓库克隆现有的仓库本地已有构建的项目不进行版本控制添加不进行版本控制的文件目录提交 commit 后，想再忽略一些已经提交的文件常见操作查看信息查看帮助 git help查看状态 git status查看变化 git diff查看日志 git log查看某个文件的版本历史 git show图形化查看提交内容 gitk更新文件重命名文件删除提交撤销&amp;回滚简单总结撤销修改文件 尚未提交修改文件 已经提交（git commit）到 本地仓库回滚还原 远端服务器 提交的代码删除最后一次远程提交回滚某次提交删除某次提交操作标签创建标签查看标签删除标签操作分支查看分支新建分支提交到远程分支删除分支合并分支暂存分离头【detached HEAD】操作子仓库常用命令详解git pull 详解git fetch 详解git add 详解git commit 详解git remote 详解git push 详解语法示例完整示例本地分支名 缺省本地分支、远程分支都 缺省远程主机名、本地分支、远程分支都 缺省simple 方式 和 matching 方式git branch 详解语法示例git checkout 详解例子git reset 详解git cherry-pick 详解git submodule 详解git 原理git 工作解析图git 文件目录commit 与 tree 和 blob 的关系git 注意事项常见缩写 安装 git已有？请跳过git 文档地址git 下载地址查看 git 版本1git --version 初始化 基本配置 配置帐号信息1234# 设置 [本仓库 | 全局 | 系统 ] 的 用户名称$ git config [--local | --global | --system] user.name 'Your name'# 设置 [本仓库 | 全局 | 系统 ] 的 用户邮箱$ git config [--local | --global | --system] user.email 'Your email'当然你也可以通过修改 .git 文件目录下面的 config 文件进行修改 配置别名12345# 配置别名$ git config --global alias.st status # git st$ git config --global alias.co checkout # git co$ git config --global alias.br branch # git br$ git config --global alias.ci commit # git ci 查看配置1234# 查看配置git config --list [--local | --global | --system]# 根据git哈希值 查看内容 / 查看类型git cat-flie [-p / -t] 参数说明local：区域为本仓库global: 当前用户的所有仓库system: 本系统的所有用户缺省等同于 local优先级：local &gt; global &gt; system 生成 shh 密钥如果你想通过 https 的方式 每次提交输入密码，当然可以跳过此节检查是否已经存在公私钥1234# 查看.ssh目录下是否有密钥 如列表中包含 id_rsa和id_rsa.pub 说明电脑中已经存在公私钥ls -al ~/.ssh# cat ~/.ssh/id_rsa.pub生成密钥123456# 生成秘钥（根据电脑主机）$ ssh-keygen -t rsa# 根据邮箱生成 密钥$ ssh-keygen -t rsa -C \"youremail\"# 执行后 ：建议不要输入，一路回车，生成的 id_rsa 是私钥 生成的 id_rsa.pub 是公钥添加 密钥在对应服务器增加密钥。【github -&gt; setting -&gt; SSH and GPG keys】如果公司是自己搭建的 git 服务（未使用 gitlab），则交给管理员添加。如果使用 gitlab 在设置增加密钥 获取 Git 仓库 在现有目录中初始化仓库12345678910111213# 初始化本地仓库 缺省 为当前目录$ git init ['your_project'/缺省]# git init --bare 建立裸仓库【中心仓库】# 获取状态$ git status# .或*代表全部添加$ git add [file1] [file2] ...# 提交$ git commit -m \"提交message\"# 添加远程源$ git remote add origin [远程地址]# push 同时 设置默认跟踪分支$ git push -u origin master 克隆现有的仓库1234# 克隆远程仓库到本地 fileName 的文件夹内 【缺省-默认远端名称】$ git clone [url] &lt;fileName/缺省&gt;# 克隆 为 裸仓库【中心仓库】$ git clone --bare [ 连接地址 ] &lt; file bf名称 &gt;从裸仓库 clone 下来的本地仓库可以进行正常的 push 操作， 但是从一般仓库 clone 下来的本地仓库却不行。 这也正是裸仓库存在的意义。 裸仓库一般情况下是作为远端的中心仓库而存在的。 本地已有构建的项目12345678$ git remote -v #查看远程版本库信息$ git remote add github &lt;url&gt; #添加github远程版本库$ git fetch github #拉取远程版本库$ git merge -h #查看合并帮助信息$ git merge --allow-unrelated-histories github/master# or git pull origin master --allow-unrelated-histories# 对github上的master分支与本地master分支进行合并（两分支不是父子关系，所以合并需要添加 --allow-unrelated-histories）$ git push github #推送同步到github仓库 不进行版本控制 添加不进行版本控制的文件目录项目目录下 新建 .gitignore 文件 ，写入不需要进行版本控制的文件名或文件夹1234567891011121314# 文件示例node_modules # 对 node_modules文件夹及其文件 及 node_modules文件 不进行版本控制doc # 对 [doc文件夹及其子文件 和 名称为doc的文件] 不进行版本控制*doc # 不允许 任何 包含doc字符的 文件夹及其子文件 和 文件（包括.扩展名）不进行版本控制doc/ # 对 [doc文件夹及其下文件] 不进行版本控制*doc/ # 对 [任何 包含doc字符的文件夹及其下文件] 不进行版本控制*.md // 对 .md结尾的文件 不进行版本控制# /* 复合示例 */doc!doc/* # git管doc文件夹，不管doc文件 提交 commit 后，想再忽略一些已经提交的文件把忽略的文件添加到 .gitignore;通过 git rm – cached &lt; file &gt; 的方式删除掉 git 仓库里面无需跟踪的文件。git commit -m ‘delete git remote somefile’git push 常见操作 查看信息 查看帮助 git help12345678# 所有可用的命令都将打印在标准输出上$ git help [--all/-a]# 在标准输出中也会列出有用的Git指南$ git help [--guide/-g]# 显示 git 手册页$ git help git 查看状态 git statusgit status 命令用于显示工作目录和暂存区的状态。git status 不显示已经 commit 到项目历史中去的信息。看项目历史的信息要使用 git log常用于 git commit 之前, 这样能防止你不小心提交了您不想提交的东西。1234567# 显示工作目录和暂存区的状态$ git status# 只列出所有已经被git管理的且被修改但没提交的文件$ git status -uno# 紧凑的格式输出$ git status -s # or $ git status --short 查看变化 git diff对比 修改之后还没有暂存起来的内容变化123456789101112131415161718192021222324252627282930313233343536# 工作树中的更改尚未分段进行下一次提交$ git diff# 比较当前文件和暂存区文件差异 git diff$ git diff &lt;file&gt;$ git diff &lt;id1&gt;&lt;id1&gt;&lt;id2&gt; # 比较两次提交之间的差异$ git diff &lt;branch1&gt; &lt;branch2&gt; # 在两个分支之间比较$ git diff --staged # 比较暂存区和版本库差异$ git diff --cached # 比较暂存区和版本库差异$ git diff --stat # 仅仅比较统计信息$ git diff HEAD # 显示工作版本(Working tree)和HEAD的差别$ git diff test # 查看当前目录和另外一个分支(test)的差别# 假定：HEAD、缓存区、工作区中的readme.md文件内容均不相同。# 比较 工作区 &lt;===&gt; HEAD$ git diff HEAD -- readme.md# 比较 工作区 &lt;===&gt; 缓存区$ git diff -- readme.md# 比较 缓存区 &lt;===&gt; HEAD$ git diff --cached -- readme.md# 比较两个提交或分支的差异$ gti diff [分支名称/commit-id] [分支名称/commit-id] --&lt; file &gt;# 对比两个版本的不同$ git diff [commit号] [commit号]# 对比 当前提交版本与上次提交$ git diff HEAD HEAD^[同 HEAD～1]# 对比当前提交版本与上上次（前两次）提交$ git diff HEAD HEAD^^[同HEAD～2]补充说明：一个节点，可以包含多个子节点（checkout 出多个分支）一个节点可以有多个父节点（多个分支合并）是~都是父节点，区别是跟随数字时候，2 是第二个父节点，而~2 是父节点的父节点^和~可以组合使用,例如 HEAD~2^2 查看日志 git log1234567891011121314# 查看所有分支的历史 git log 等同于它$ git log --all# 查看图形化的 log 地址$ git log --all --graph# 查看单行的简洁历史。$ git log --oneline# 查看最近的四条简洁历史。$ git log --oneline -n4#查看所有分支最近 4 条单行的图形化历史。$ git log --oneline --all -n4 --graph# 跳转到git log 的帮助文档网页$ git help --web log$ git log -1 // 最近一次提交信息 查看某个文件的版本历史 git show1234// 先查看文件提交历史git log --pretty=oneline [文件名或文件路径] // 例如src/AfterView/common/commonStream.vuegit show [版本号] // 显示具体的某次的改动的修改 图形化查看提交内容 gitk1234# 在当前目录下输入，弹出图形化界面$ gitk$ gitk --all定制化图形界面 ： view --&gt; new view [勾选 all refs] # 显示全部分支 更新使用 git pull 进行更新1234# 按照git branch 设置的默认跟踪的服务器和分支来拉取$ git pull# 实例：拉取远程服务器origin的master分支$ git pull origin master使用 git fetch 进行更新12345678# 将远程仓库的master分支下载到本地当前branch中$ git fetch orgin master# 比较本地的master分支和origin/master分支的差别 $ git log -p master ..origin/master # 进行合并$ git merge origin/master 文件重命名先删除文件再添加文件123456# 重命名3步骤 eg: 重命名 readme 为 readme.md$ mv [文件名1] [文件名2] # 重命名文件名1为文件名2$ git add ['文件名'] # 添加新文件 eg: git add readme.md$ git rm ['文件名'] # 删除旧文件 eg: git rm readme# 就可以正常commit直接使用 git 命令123$ git mv ['旧文件名'] ['新文件名'] # git重命名（相当于上面三个步骤）# 就可以正常commit12345# 回滚到对版本号的应提交状态【缺省回滚到最近的一次提交】$ git reset --hard [提交版本号|缺省]# 记录所有HEAD的历史，也就是说当你做reset，checkout等操作的时候，这些操作会被记录在reflog中$ git reflog 文件删除先删除文件再添加文件1234$ rm &lt;file&gt; # 删除文件$ git add ['文件名'] # 添加新文件 eg: git add readme.md# 就可以正常commit直接使用 git 命令12# 删除工作区，暂存区 的文件$ git rm &lt;file&gt;如果删除出错 借助 git reset --hard 进行撤销 提交1234567891011121314151617181920# 添加新文件$ git add ['文件名' | '.'代表全部]# 查看提交状态【是否有未提交】（不必的） but 能防止你不小心提交了您不想提交的东西# $ git status # 没有未提交的显示 nothing to commit# 提交填写日志$ git commit -m'这里填写提交日志'# 如果发现点问题，那么继续进行了修改# 继续执行 git add . 重新提交，会覆盖上次提交，只以当前为准# $ git commit --amend# 查看日志(不必的)# $ git log# 更新 先更新避免发生冲突$ git pull# 推送到 orgin 远端服务器$ git push 撤销&amp;回滚 简单总结修改了工作区，恢复：git checkoutadd 后，想撤销： git reset HEADcommit 后，想撤销： git reset --hard [需要回退的 commit id] 撤销 修改文件 尚未提交未执行 git add 操作123# 从暂存区（index） 恢复 文件$ git checkout &lt;fileName&gt;$ git checkout .文件执行了 git add 操作，恢复 文件（index 内回滚）123456789# 取消暂存$ git reset HEAD fileName# 撤销修改$ git checkout &lt; fileName &gt;# 暂存区的 commitid 覆盖工作区修改$ git checkout [commitid] -- &lt;file&gt;# git checkout 5384b04 -- src/pages/AdScreen/components/commonStream.vue // 回退 5384b04 的文件同时对多个文件执行了 git add 操作，本次只想提交其中一部分文件1234$ git add *$ git status# 取消暂存$ git reset HEAD &lt;filename&gt; 修改文件 已经提交（git commit）到 本地仓库修改 git commit 不再产生新的 Commit[ 只能修改最近一次 ]1234# 修改最后一次提交$ git add sample.txt# 代替（或这说修改）上一次提交，不只是修改message。$ git commit --amend -m\"说明\"多次 git commit 撤销到其中某次 Commit1234567891011121314# 修改最后一次提交$ git reset --[soft/hard/mixed] [commit|HEAD]# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit] 回滚已进行 git push，即已推送到“远程仓库”中。我们将已被提交到“远程仓库”的代码还原操作叫做“回滚”！注意：对远程仓库做回滚操作是有风险的，需提前做好备份和通知其他团队成员！ 还原 远端服务器 提交的代码12345# 根据 tag 还原工作区代码$ git checkout &lt;tag&gt;# 回滚到指定commitID$ git checkout &lt;commitID&gt; &lt;filename&gt; 删除最后一次远程提交使用 revert123$ git revert HEAD$ git push origin master使用 reset123$ git reset --hard HEAD^$ git push origin master -f二者区别：revert 是放弃指定提交的修改，但是会生成一次新的提交，需要填写提交注释，以前的历史记录都在；reset 是指将 HEAD 指针指到指定提交，历史记录中不会出现放弃的提交记录。 回滚某次提交1234# 找到要回滚的 commitID$ git log# 根据 commitID 进行回滚$ git revert commitID 删除某次提交1234567891011# 找到要回滚的 commitID$ git log --oneline -n5# 注意：最后的^号，意思是commit id的前一次提交$ git rebase -i \"commit id\"^ # git rebase -i \"5b3ba7a\"^# 根据交互输入命令修改信息# 合并多个历史版本commit合并$ git rebase -i [父级commit id ]# 合并多个历史版本commit合并$ git rebase -i [开始commit 的父级id] [结束commit id]如果没有指定 结束 commit,那么结束 commit 默认为当前分支最新的 commit，那么 rebase 结束后会自动更新当前分支指向的 commit,如果指定了结束 commit，而且结束 commit 不是当前分支最新的 commit，那么 rebase 后会有生成一个 游离的 head,，而且当前分支指向的 commit 不会更新具体还可参考：Deleting a Git commit在 Git 中，如何『删除』commit？ 操作标签标签操作允许为存储库中的特定版本提供有意义的名称。 创建标签12345678910# 创建标签$ git tag -a 'tag1' -m 'tag1的说明' [HEAD / commit id / 缺省]# -a选项的 标签名称，-m选项的 标签消息。# 缺省：HEAD 要标记特定提交，则使用相应的COMMIT ID而不是HEAD指针# 将 tag1 推送到 origin 远端$ git push origin &lt;tagname&gt;# 一次性推送全部尚未推送到远程的本地标签$ git push origin --tags 查看标签123456$ git tag# 查看 所有可用的标签$ git tag -l# 查看 tagName标签的 详细信息$ git show tagName 删除标签1234567891011# 查看 所有可用的标签$ git tag -l# 删除 tagName标签$ git tag -d &lt;tagName&gt;# 删除 远端 tag 标签$ git push origin --delete tag &lt;tagname&gt;# 删除 远端 tag 标签 类似 删除远端分支的做法$ git push origin :refs/tags/标签名 操作分支 查看分支1234# 查看分支git branch -v# 查看本地分支对应的远程分支$ git branch -av 新建分支1234567891011121314151617# 新建一个名字为 dev2 的分支 (不切换到新分支)$ git branch dev2# 新建一个名字为 dev2 的分支 并切换到该分支$ git checkout -b &lt;branchname&gt;# 从某个版本创建分支 并切换到该分支$ git checkout -b &lt;branchname&gt; [commit号/分支名称]# 创建并切换分支$ git checkout -b &lt;branchname&gt; [commit版本号]# 基于 远端分支 建立 本地分支（远程分支名x） 采用此种方法建立的本地分支会和远程分支建立映射关系$ git checkout -b &lt;本地分支名x&gt; &lt;origin/远程分支名x&gt;/* 相当于分别执行了下面两条命令 */# git branch &lt;branchname&gt;# git checkout &lt;branchname&gt; 提交到远程分支12345678910$ git push [origin] &lt;分支名称&gt;:&lt;分支名称&gt;# 本地分支push到远程服务器，远程分支与本地分支同名（当然可以随意起名）$ git pull [origin] &lt;分支名称&gt; 更新远程分支到本地# /* 远程分支关联 */$ git branch --set-upstream-to=[origin]/&lt;分支名称&gt;# 接下来就 可以直接pull 或者push 了# 查看关联的分支名称$ git branch -vv[origin] 代指 添加远程裸仓库地址时候，创建的名称 删除分支123456789# 删除分支 -d是删除 -D 是强制删除$ git branch [-D/-d] &lt;branchname&gt;# 删除远程分支$ git branch -d -r &lt;branchname&gt;$ git push origin :&lt;branchname&gt;# OR$ git branch # 查看分支名称$ git push origin --delete &lt;branchname&gt; 合并分支fast-forwardfast-forward 方式 合并这种方法相当于直接把 master 分支移动到 test 分支所在的地方，并移动 HEAD 指针1234# 先切换到主分支，为合并分支准备$ git checkout master# 进行合并$ git merge devno-fast-forward 方式 合并这种合并方法会在 master 分支上新建一个提交节点，从而完成合并1234# 先切换到主分支，为合并分支准备$ git checkout master# 进行合并$ git merge –no-ff devsquash 方式 合并squash 和 no-ff 非常类似，区别只有一点不会保留对合入分支的引用12$ git checkout master$ git merge –squash devrebase 方式 合并rebase 与 merge 不同，rebase 会将合入分支上超前的节点在待合入分支上重新提交一遍，变成线性历史1234# 先切换到主分支，为合并分支准备$ git checkout master# 进行合并$ git rebase devcherry-pick 挑拣 合并对已经存在的 commit 进行 再次提交 [选择某些节点进行合并]12$ git cherry-pick &lt;commit id&gt;当执行完 cherry-pick 以后，将会 生成一个新的提交；这个新的提交的哈希值和原来的不同，但标识名 一样；图解 4 种 git 合并分支方法 &gt; git cherry-pick 的使用 暂存当收到紧急任务，手里又存在未完成的模块可以先放到暂存区12345678git stash # 暂存git stash list # 查看暂存列表git stash apply [序号/缺省为stash@&#123;0&#125;] # 恢复暂存进度到工作区git stash pop [序号/缺省为stash@&#123;0&#125;] # 恢复暂存进度到工作区并删除# git stash pop = git stash pop stash@&#123;0&#125; 分离头【detached HEAD】执行 git checkout [commit 版本号] ，git 会提示显示处于分离头（无分支状态），在此状态下，进行的提交操作不挂到在分支下，直接切换分支，会导致分离头的提交丢失。错误示范：123456789git checkout 15a6686b624 # 检出15a6686b624的提交，到分离头情况git commit -am\"错误示例\" # 创建一次提交git branch -av # 查看分支git checkout marst # 切换到marst 分支 此时git 会提示你，对分离头提交# 最后一次补救git branch [分支名称] [commit版本号]正常使用1234# 使用某个提交创建分支git checkout -b [分支名称] [commit版本号] // 创建并切换分支git checkout -b 本地分支名x origin/远程分支名x // 基于 远端分支 建立 本地分支（远程分支名x） 采用此种方法建立的本地分支会和远程分支建立映射关系 操作子仓库12345678910111213141516171819# 添加子仓库$ git submodule add &lt;仓库地址&gt; &lt;本地路径&gt;# 检出子仓库# 初始化本地配置文件$ git submodule init# 检出父仓库列出的commit$ git submodule update# 或者使用组合指令。$ git submodule update --init --recursive# 删除子仓库# 1删除.gitsubmodule里相关部分# 2删除.git/config 文件里相关字段# 3删除子仓库目录。$ git rm -r --cached &lt;本地路径&gt;git submodule 使用小结 常用命令详解 git pull 详解git pull 相当于从远程获取最新版本并 merge 到本地1234# 按照git branch 设置的默认跟踪的服务器和分支来拉取$ git pull# 实例：拉取远程服务器origin的master分支$ git pull origin mastergit pull 详解12345$ git pull [&lt;options/缺省&gt;] [&lt;远端仓库名称&gt; [&lt;分支名称&gt;…​]]# options : –allow-unrelated-histories 允许无关的历史，这个选项，更多是在更改远程仓库的时候用到# options : –ff 开启fast-forward# options : –no-ff 强行关闭fast-forward方式# options : –ff-only git fetch 详解git fetch 相当于是从远程获取最新到本地，不会自动 merge在实际使用中，git fetch 更安全一些使用 git fetch 进行更新12345678# 将远程仓库的master分支下载到本地当前branch中$ git fetch orgin master# 比较本地的master分支和origin/master分支的差别 $ git log -p master ..origin/master # 进行合并$ git merge origin/masterOR123456# 从远程仓库master分支获取最新，在本地建立tmp分支$ git fetch origin master:tmp#將當前分支和tmp進行對比$ git diff tmp#合并tmp分支到当前分支$ git merge tmpgit pull = git fetch + git merge git add 详解将修改添加到暂存区12345678910111213141516# 将所有修改添加到暂存区$ git add .# Ant风格添加修改$ git add *# 将文件的修改、文件的删除，添加到暂存区。$ git add -u# 将文件的修改，文件的删除，文件的新建，添加到暂存区$ git add -A# 将以Controller结尾的文件的所有修改添加到暂存区$ git add *Controller# 将所有以Hello开头的文件的修改添加到暂存区 例如:HelloWorld.txt,Hello.java,HelloGit.txt ...$ git add Hello*# 将以Hello开头后面只有一位的文件的修改提交到暂存区 例如:Hello1.txt,HelloA.java 如果是HelloGit.txt或者Hello.java是不会被添加的$ git add Hello? git commit 详解用于将更改记录(提交)到存储库1234567891011# 普通提交填写提交信息$ git commit -m \"the commit message\"# 将所有已跟踪文件中的执行修改或删除操作的文件都提交到本地仓库，即使它们没有经过git add添加到暂存区，# 然后提交(有点像svn的一次提交,不用先暂存)。# 对于没有track的文件,还是需要执行`git add &lt;file&gt;` 命令。$ git commit -a$ git commit -a -m \"the commit message\"# 增补提交（修改上次提交），会使用与当前提交节点相同的父节点进行一次新的提交，旧的提交将会被取消。$ git commit --amend git remote 详解git remote 命令管理一组跟踪的存储库1234567891011121314151617181920212223242526272829# 查看当前的远程库# 列出已经存在的远程分支$ git remote# 列出详细信息，在每一个名字后面列出其远程url$ git remote [-v | --verbose]# 添加一个名字为 &lt;name&gt; 的 远程服务器# $ git remote add &lt;name&gt; &lt;url&gt;$ git remote add [-t &lt;branch&gt;] [-m &lt;master&gt;] [-f] [--[no-]tags] [--mirror=&lt;fetch|push&gt;] &lt;name&gt; &lt;url&gt;# 重命名 远程链接$ git remote rename &lt;old&gt; &lt;new&gt;# 删除 远程链接$ git remote remove &lt;name&gt;$ git remote set-head &lt;name&gt; (-a | --auto | -d | --delete | &lt;branch&gt;)$ git remote set-branches [--add] &lt;name&gt; &lt;branch&gt;…​# 获取 &lt;name&gt; 远程服务 地址$ git remote get-url [--push] [--all] &lt;name&gt;# 设置 &lt;name&gt; 远程服务 地址$ git remote set-url [--push] &lt;name&gt; &lt;newurl&gt; [&lt;oldurl&gt;]# eg: git remote set-url [ 裸仓库名称/常用origin]$ git remote set-url --add [--push] &lt;name&gt; &lt;newurl&gt;$ git remote set-url --delete [--push] &lt;name&gt; &lt;url&gt;$ git remote [-v | --verbose] show [-n] &lt;name&gt;…​$ git remote prune [-n | --dry-run] &lt;name&gt;…​$ git remote [-v | --verbose] update [-p | --prune] [(&lt;group&gt; | &lt;remote&gt;)…​] git push 详解将修改添加到暂存区 语法12# 命令用于将本地分支的更新，推送到远程主机。与git pull命令相似。$ git push &lt;远程主机名/缺省&gt; &lt;本地分支名/缺省&gt;:&lt;远程分支名/缺省&gt; 示例origin 可通过 .git config 查看地址 完整示例12# 将本地的master分支推送到origin主机的master分支。如果master不存在，则会被新建。$ git push origin master 本地分支名 缺省表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。1234# 表示删除origin主机的master分支$ git push origin :master# 等同于$ git push origin --delete master 本地分支、远程分支都 缺省表示推送特定主机的对应分支简写方式：如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。12# 将当前分支推送到origin主机的对应分支$ git push origin 远程主机名、本地分支、远程分支都 缺省表示推送origin 主机的对应分支简写方式：如果当前分支只有一个追踪分支，那么主机名都可以省略。12# 将当前分支推送到 预设 主机【默认origin】的对应分支$ git push当前分支与多个主机存在追踪关系，则可以使用-u 选项指定一个默认主机，这样后面就可以不加任何参数使用 git push12# 将本地的master分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用git push了$ git push -u origin master simple 方式 和 matching 方式不带任何参数的 git push，默认只推送当前分支，这叫做 simple 方式matching 方式，会推送所有有对应的远程分支的本地分支Git 2.0 版本之前，默认采用 matching 方法，现在改为默认采用 simple 方式如果要修改这个设置，可以采用 git config 命令123$ git config --global push.default matching# 或者$ git config --global push.default simple12345678910111213141516171819202122232425# 不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机# 所有本地分支都推送到origin主机$ git push --all origin# 使用-–force选项，结果导致在远程主机产生一个”非直进式”的合并(non-fast-forward merge)$ git push --force origin# git push不会推送标签(tag)，除非使用–tags选项$ git push origin --tags# 推送tag$ git push origin tag_name# 删除远程标签$ git push origin :tag_name# 将当前分支推送到远程的同名分支$ git push origin HEAD# 将当前所在指针分支 推送到 远程的master分支$ git push origin HEAD:master# 用本地分支 dev 覆盖远程分支 dev_op$ git push -f origin dev:refs/dev_op# or$ git push origin :refs/dev //删除远程的dev分支$ git push origin dev:refs/dev_op git branch 详解用于列出，创建或删除分支 语法123456789101112# 查看分支$ git branch [-r | -a]# 新建分支$ git branch [-f] &lt;branchname&gt;# 重命名分支 使用-M则表示强制重命名$ git branch (-m | -M) &lt;oldbranch&gt; &lt;newbranch&gt;# 删除分支 使用-D则表示强制删除，相当于 --delete --force$ git branch (-d | -D) &lt;branchname&gt;使用-d 在删除前 Git 会判断在该分支上开发的功能是否被 merge 的其它分支。如果没有，不能删除。如果 merge 到其它分支，但之后又在其上做了开发，使用-d 还是不能删除。-D 会强制删除 示例12345678910111213141516171819202122232425# 查看分支$ git branch# 列出所有远程分支$ git branch -r# 查看本地和远程分支$ git branch -a# 查看本地分支对应的远程分支$ git branch -vv# 新建一个名字为 dev2 的分支$ git branch dev2# 修改分支的名字#你需要重命名远程分支，推荐的做法是：1.删除远程待修改分支 2.push本地新分支名到远程$ git branch -m dev2# 删除本地分支$ git branch -d &lt;branchname&gt;# 删除远程分支$ git branch -d -r &lt;branchname&gt;$ git push origin :&lt;branchname&gt;# OR$ git branch$ git push origin --delete dev2 git checkout 详解用于切换分支或恢复工作树文件。这条命令会重写工作区123456789101112131415161718192021222324252627282930313233343536# 切换 &lt;branch&gt; 分支$ git checkout &lt;branch&gt;# 从 &lt;branch&gt; 分支 提交中取出文件$ git checkout &lt;branch&gt; &lt;fileName&gt;# 从暂存区（index） 恢复文件$ git checkout &lt;fileName&gt;# 新建 &lt; branch &gt; 分支 并进行切换$ git checkout -b &lt;branch&gt;$ git checkout -b|-B &lt;new_branch&gt; [&lt;start point&gt;] # 完整版# 相当于 执行# git branch newBranch# git checkout newBranch# 换到newBranch的远程分$ git checkout -b newBranch origin/newBranch# 检出索引中的 fileName文件$ git checkout -- &lt;fileName&gt;# 检出索引中的 fileName文件$ git checkout -- &lt;fileName&gt;# 用于检出某一个指定文件# 不填写commit id，则默认会从暂存区检出该文件，如果暂存区为空，则该文件会回滚到最近一次的提交状态$ git checkout [-q] [&lt;commit id&gt;] [--] &lt;paths&gt;# 当暂存区为空，如果我们想要放弃对某一个文件的修改，可以用这个命令进行撤销$ git checkout [-q] [--] &lt;paths&gt;# 新建的分支，严格意义上说，还不是一个分支，因为HEAD指向的引用中没有commit值，只有在进行一次提交后，它才算得上真正的分支$ git checkout --orphan &lt;new_branch&gt;# 将当前分支修改的内容一起打包带走，同步到切换的分支下 [切换到新分支后，当前分支修改过的内容就丢失了]$ git checkout --merge &lt;branch&gt;$ git checkout -m &lt;branch&gt; 例子12345678910111213141516171819202122#//取出master版本的head。$ git checkout master#//在当前分支上 取出 tag_name 的版本$ git checkout tag_name#//放弃当前对文件file_name的修改$ git checkout master file_name#//取文件file_name的 在commit_id是的版本。commit_id为 git commit 时的sha值。$ git checkout commit_id file_name# 从远程dev/1.5.4分支取得到本地分支/dev/1.5.4$ git checkout -b dev/1.5.4 origin/dev/1.5.4#这条命令把hello.rb从HEAD中签出.$ git checkout -- hello.rb# 检出索引中的所有C源文件$ git checkout -- '*.c'#这条命令把 当前目录所有修改的文件 从HEAD中签出并且把它恢复成未修改时的样子.#注意：在使用 git checkout 时，如果其对应的文件被修改过，那么该修改会被覆盖掉。$ git checkout . git reset 详解123456789$ git reset [ –-soft | -–mixed | -–hard] &lt;commit&gt;# git reset &lt;commit&gt; 的意思就是 把HEAD移到&lt;commit&gt;# --soft 这个只是把 HEAD 指向的 commit 恢复到你指定的 commit，暂存区 工作区不变# --hard 这个是 把 HEAD， 暂存区， 工作区 都修改为 你指定的 commit 的时候的文件状态# --mixed 这个是不加时候的默认参数，把 HEAD，暂存区 修改为 你指定的 commit 的时候的文件状态，工作区保持不变# 取消暂存区 部分文件（files 代表多个）的修改$ git reset HEAD --&lt; files &gt; git cherry-pick 详解语法123456789$ git cherry-pick [&lt;options&gt;] &lt;commit-ish&gt;...# 常用options:# --quit 退出当前的chery-pick序列# --continue 继续当前的chery-pick序列# --abort 取消当前的chery-pick序列，恢复当前分支# -n, --no-commit 不自动提交# -e, --edit 编辑提交信息 git submodule 详解命令用于初始化，更新或检查子模块12345678910111213$ git submodule status [--cached] [--recursive] [--] [&lt;path&gt;…​]# 添加 子模块 路径为 相关信息保存在 .gitmodules 文件$ git submodule add &lt;url&gt; [&lt;path&gt;]# 初始化本地配置文件$ git submodule init [--] [&lt;path&gt;…​]# 检出父仓库列出的commit$ git submodule update# 使用组合指令$ git submodule update --init --recursive git 原理 git 工作解析图下面这个图展示了工作区、版本库中的暂存区和版本库之间的关系： git 文件目录COMMIT_EDITMSGconfig 当前 git 的配置文件description （仓库的描述信息文件）HEAD （指向当前所在的分支），例如当前在 develop 分支，实际指向地址是 refs/heads/develophooks [文件夹]indexinfo [文件夹]logs [文件夹]objects [文件夹] （存放所有的 git 对象，对象哈希值前 2 位作为文件夹名称，后 38 位作为对象文件名, 可通过 git cat-file -p 命令，拼接文件夹名称+文件名查看）ORIG_HEADrefs [文件夹]• heads （存放当前项目的所有分支）• tags (存放的当前项目的所有标签，又叫做里程碑) commit 与 tree 和 blob 的关系12345commit 对应一个treetree 包含文件[blob]，如果下级还是文件夹，则又是一个treeblob 是tree下面具体文件 【与文件名无关具体到文件内容】 git 注意事项checkout reset 慎用禁止向集成分支[多人使用分支] 执行 push -f [强制更新到远端 可能会导致远端所在分支回退很多版本]如果单人自行分支，确认是要返回某个节点， 使用 push -f公共分支修改 commit ： git reflog 命令查找历史，然后利用 git reset --hard [提交版本号|缺省] 的方式恢复公共分支 禁止进行 rebase 变基操作对于自己在本地的多次 commit，我想把他合并成一次 commit，还没有 push 的情况下,使用 rebase 常见缩写1234567891011121314-d --delete：删除-D --delete --force的快捷键-f --force：强制-m --move：移动或重命名-M --move --force的快捷键-r --remote：远程-a --all：所有","categories":[{"name":"技术帖","slug":"技术帖","permalink":"http://mcdowell8023.github.io/categories/技术帖/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://mcdowell8023.github.io/tags/笔记/"},{"name":"git","slug":"git","permalink":"http://mcdowell8023.github.io/tags/git/"}]},{"title":"git常用命令","slug":"git常用命令","date":"2019-08-21T03:23:21.000Z","updated":"2019-08-30T09:38:03.621Z","comments":true,"path":"2019/08/21/git常用命令/","link":"","permalink":"http://mcdowell8023.github.io/2019/08/21/git常用命令/","excerpt":"","text":"git 常用命令清单转载 阮老师博客 部分修改 说明Workspace：工作区Index / Stage：暂存区Repository：仓库区（或本地仓库）Remote：远程仓库 一、新建代码库12345678# 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url] 二、配置Git 的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。123456789# 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name \"[name]\"$ git config [--global] user.email \"[email address]\" 三、增加/删除文件1234567891011121314151617181920212223# 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p# 移除文件$ git rm -f *# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed] 四、代码提交123456789101112131415161718# 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ... 五、分支123456789101112131415161718192021222324252627282930313233343536373839404142# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -d -r [remote/branch] 六、标签1234567891011121314151617181920212223242526# 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag] 七、查看信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263# 通过图像方式查看提交历史gitk# 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其\"提交说明\"必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat \"@&#123;0 day ago&#125;\"# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog 八、远程同步1234567891011121314151617181920212223# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all 九、撤销123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475# 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 从仓库取出file覆盖当前分支$ git checkout branch|tag|commit -- file_name# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 取消已经暂存的文件$ git reset HEAD *# 同上$ git reset --mixed HEAD *# 重置到指定状态，不会修改索引区和工作树$ git reset --soft HEAD *# 重置到指定状态，会修改索引区和工作树$ git reset --hard HEAD *# 重置index区文件$ git reset -- files#撤销前一次操作$ git revert HEAD#撤销前前一次操作$ git revert HEAD~# 撤销指定操作commit 所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]# 暂时将未提交的变化移除，稍后再移入# 将工作区现场（已跟踪文件）储藏起来，等以后恢复后继续工作。$ git stash# 查看保存的工作现场$ git stash list# 恢复工作现场$ git stash apply# 删除stash内容$ git stash drop# 恢复的同时直接删除stash内容$ git stash pop# 恢复指定的工作现场，当你保存了不只一份工作现场时$ git stash apply stash@&#123;0&#125; 十、子仓库 git submodule12345678910111213141516171819# 添加子仓库$ git submodule add &lt;仓库地址&gt; &lt;本地路径&gt;# 检出子仓库# 初始化本地配置文件$ git submodule init# 检出父仓库列出的commit$ git submodule update# 或者使用组合指令。$ git submodule update --init --recursive# 删除子仓库# 1删除.gitsubmodule里相关部分# 2删除.git/config 文件里相关字段# 3删除子仓库目录。$ git rm -r --cached &lt;本地路径&gt; 十一、其他12# 生成一个可供发布的压缩包$ git archive","categories":[{"name":"技术帖","slug":"技术帖","permalink":"http://mcdowell8023.github.io/categories/技术帖/"}],"tags":[{"name":"git","slug":"git","permalink":"http://mcdowell8023.github.io/tags/git/"},{"name":"命令","slug":"命令","permalink":"http://mcdowell8023.github.io/tags/命令/"},{"name":"速查","slug":"速查","permalink":"http://mcdowell8023.github.io/tags/速查/"}]},{"title":"hexo博客-常见问题","slug":"hexo博客-常见问题","date":"2019-07-17T16:15:05.000Z","updated":"2019-08-30T11:45:08.090Z","comments":true,"path":"2019/07/18/hexo博客-常见问题/","link":"","permalink":"http://mcdowell8023.github.io/2019/07/18/hexo博客-常见问题/","excerpt":"","text":"博客在 github 访问访问慢？在 coding page 上部署实现国内外分流申请 coding 账户，新建项目 同 GitHub添加 ssh key 同 GitHub修改_config.yml12345deploy: type: git repo: github: &lt;github项目地址 url&gt;,master coding: &lt;coding项目地址 url&gt;,master部署12hexo ghexo dcoding 控制台 开启 pages菜单目录中 -&gt; 代码 pages 服务注意：本地电脑之前 没有与 远端托管服务器[ github、coding等 ] 建立过ssh连接，部署会报错[ 即使已经在远端配置好了ssh公钥 ]。可以先用本地电脑与远端进行 ssh -T git@github.com 进行测试 或者 项目克隆。 第三方主题 没有办法上传到自己的项目中？在使用第三方主题的时候，难免要对主题进行微调。但是调整后的主题文件 是无法上传上去的。这时候，你换台电脑来写博客，就还得再来一遍。【别问我，我是怎么知道的 😂】其实第三方主题是别人的项目，你修改后自认是无法提交到别人的项目上。那么针对上面问题，有两个解决办法：删掉 第三方主题 的.git &lt; 好用但不推荐 &gt;git 不能嵌套上传，最好是显示隐藏文件，检查一下有没有，否则上传的时候会出错，导致你的主题文件无法上传使用 Git 的 Submodulefor 主题的仓库到自己的目录下 【喂，for 就不用说了吧】然后先删掉你原来主题文件 【❗️ 备份 ❗ 备份 ️❗️ 备份】1git rm -r --cached themes/&lt; 主题目录 &gt;添加 submodlue1git submodule add &lt; for后的主题仓库地址 &gt; themes/&lt; 主题目录 &gt;当前工程根路径下生成一个名为“.gitmodules”的文件123[submodule \"themes/主题\"]path = themes/主题url = https://github.com/wuchong/jacman.git # 主题地址单独提交修改后的主题【这是你还原主题更改的好时候】12345cd themes/&lt; 主题目录 &gt;git add .git commit -m \"我只是对主题进行了一些调整\"git push origin master //这是提交到fork后主题的仓库然后返回博客项目根目录 进行正常提交就好在新电脑上 clone 后 npm install 之前要去下载 主题123cd themes/&lt; 主题目录 &gt;git submodule initgit submodule update # 获取我的主题的配置注意：一定要切换到对应分支【 同时注意更新下来的版本 】 关于博客版本管理关于 hexo 博客的机制是这样的：由于 hexo d 上传部署到 github 的 pages 服务其实是 hexo 编译后的文件，是用来生成网页的，不包含源文件。那么我们写博客的源文件总要放到网上去托管啊。那么新建仓库，直接上传到 github？这样算上刚刚 for 的主题，再加上 主页的 pages 服务的主页，一个博客用了三个仓库。貌似有点浪费资源。那么。。。可以在主页仓库[pages 服务的仓库]的其他分支上传源码在下面，其实就是 git 的知识了，然而还是贴上吧1234567# 在github仓库上，创建hexo 分支，用于存放源码git remote -v #查看远程版本库信息git remote add github &lt;url&gt; #添加github远程版本库git fetch github hexo #拉取远程版本库git merge -h #查看合并帮助信息git merge --allow-unrelated-histories github/heox # 对github上的heox分支与本地master分支进行合并（两分支不是父子关系，所以合并需要添加 --allow-unrelated-histories）git push github hexo #推送同步到github仓库 的 hexo记得 fetch,pull,push 的时候 一定要 带着分支 相关连接基于 Hexo 的博客同步中的一些问题 相关文章hexo博客-建站","categories":[{"name":"技术帖","slug":"技术帖","permalink":"http://mcdowell8023.github.io/categories/技术帖/"}],"tags":[{"name":"hexoBlog","slug":"hexoBlog","permalink":"http://mcdowell8023.github.io/tags/hexoBlog/"}]},{"title":"hexo博客-建站","slug":"hexo博客-建站","date":"2019-07-17T16:14:13.000Z","updated":"2019-08-30T09:38:03.621Z","comments":true,"path":"2019/07/18/hexo博客-建站/","link":"","permalink":"http://mcdowell8023.github.io/2019/07/18/hexo博客-建站/","excerpt":"","text":"安装启动依赖：Node.js (Should be at least nodejs 6.9) / Git 安装 Hexo1npm install -g hexo-cli 建站123hexo init &lt;blogName&gt;cd &lt;blogName&gt;npm install 目录介绍12345678 .├── _config.yml # 博客项目配置文件├── package.json # 依赖包，不多少├── scaffolds # 文章模版 可以根据现有模版自定义├── source # 存放用户资源的地方| ├── _drafts| └── _posts # 文章存放目录└── themes # 主题source :资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。 修改配置12345678910vim _config.yml# 修改信息# Sitetitle: # 例如 mcdowell博客subtitle: # 例如 博客+笔记description: # 例如 javascript/vue/react/node OR 其他 笔记帖以及日常磨叨keywords: # 例如 web js vue react nodejsauthor: # 例如 mcdowelllanguage: # 例如 zh-CNtimezone:更多详细配置 见 hexo 本地启动12hexo g # g -&gt; generate 生成静态文件hexo s # s -&gt; server 启动项目然后你就见到 你的 项目了 更换主题去 hexo 官网挑选心仪主题找到主题 github 地址12git clone &lt;github 地址&gt; themes/&lt;主题名称&gt;#eg git clone https://github.com/blleng/hexo-theme-lx themes/lx修改配置 _config.yml123vim _config.yml# 修改配置theme: &lt;主题名称&gt; # eg: lx 新建文章 新建默认模版文章1hexo new &lt;title&gt;可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局 新建指定模版文章12hexo new &lt;模版名称&gt; \"文章标题\"# eg: hexo new photo \"My Gallery\" 准备 github GitHub 创建个人仓库准备 github 账号New repository，新建仓库创建一个和你用户名相同的仓库，后面加.github.io只有这样，将来要部署到 GitHub page 的时候，才会被识别，也就是 xxxx.github.io，其中 xxx 就是你注册 GitHub 的用户名。 生成 SSH 添加到 GitHub 本地电脑生成 ssh 密钥初始化 git 信息12git config --global user.name &quot;yourname&quot;git config --global user.email &quot;youremail&quot;生成密钥1ssh-keygen -t rsa -C &quot;youremail&quot;找到.ssh 下的 id_rsa.pub 文件，里面存放的就是密钥信息，可以对应添加到 github生成的 id_rsa 是私钥 生成的 id_rsa.pub 是公钥 将 hexo 部署到 GitHub修改配置 _config.yml123456vim _config.yml# 修改配置deploy:type: gitrepo: https://github.com/YourgithubName/YourgithubName.github.io.git # gitub 地址branch: master安装 deploy-git 用于部署1npm install hexo-deployer-git --save然后 三部曲123456hexo clean # 清理hexo generate # 生成静态文件hexo deploy # 部署推到远端# 缩写hexo g -d # -&gt; hexo generate --deploy然后浏览器打开 https://YourgithubName.github.io 【YourgithubName 是你的 githu 账户名称】 就可以访问了 关于留言功能valine :[https://valine.js.org/]为博客添加 Gitalk 评论插件 :[https://www.jianshu.com/p/78c64d07124d] 推荐相关连接Hexo 博客常用插件及用法GitHub+Hexo 搭建个人网站详细教程hexo 史上最全搭建教程 相关文章hexo博客-常见问题","categories":[{"name":"技术帖","slug":"技术帖","permalink":"http://mcdowell8023.github.io/categories/技术帖/"}],"tags":[{"name":"hexoBlog","slug":"hexoBlog","permalink":"http://mcdowell8023.github.io/tags/hexoBlog/"}]}]}