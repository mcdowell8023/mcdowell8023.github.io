{"meta":{"title":"mcdowell博客","subtitle":"博客+笔记","description":"javascript/vue/react/node OR 其他 笔记帖以及日常磨叨","author":"mcdowell","url":"http://mcdowell8023.github.io"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2019-08-30T09:38:03.620Z","updated":"2019-08-30T09:38:03.620Z","comments":false,"path":"/404.html","permalink":"http://mcdowell8023.github.io//404.html","excerpt":"","text":""},{"title":"书单","date":"2019-08-30T09:38:03.622Z","updated":"2019-08-30T09:38:03.622Z","comments":false,"path":"books/index.html","permalink":"http://mcdowell8023.github.io/books/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-03-31T01:34:44.107Z","updated":"2020-03-31T01:34:44.107Z","comments":false,"path":"about/index.html","permalink":"http://mcdowell8023.github.io/about/index.html","excerpt":"","text":"123456789101112131415161718192021222324252627// initlet me = nullconst timeAxis = ['1991', '2013', '2016', '2017', 'today']const person = function(name, sex) &#123; return &#123; name: name, sex: sex &#125;&#125;// thentimeAxis.map(year =&gt; &#123; if (year === '1991') &#123; me = new person('mcdowell', 'male') &#125; if (year === '2013') &#123; me.college = '邯郸学院' &#125; if (year === '2016') &#123; me.job = 'coder' me.skills = ['html', 'css', 'js', 'JQ'] &#125; if (year === '2017') &#123; me.skills = [...me.skills, 'react', 'vue'] &#125;&#125;)// checkconsole.log(me, '个人简介')"},{"title":"分类","date":"2019-08-30T09:38:03.622Z","updated":"2019-08-30T09:38:03.622Z","comments":false,"path":"categories/index.html","permalink":"http://mcdowell8023.github.io/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2019-08-30T09:38:03.622Z","updated":"2019-08-30T09:38:03.622Z","comments":false,"path":"repository/index.html","permalink":"http://mcdowell8023.github.io/repository/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-08-30T09:38:03.622Z","updated":"2019-08-30T09:38:03.622Z","comments":true,"path":"links/index.html","permalink":"http://mcdowell8023.github.io/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-08-30T09:38:03.623Z","updated":"2019-08-30T09:38:03.623Z","comments":false,"path":"tags/index.html","permalink":"http://mcdowell8023.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"HarmonyOS学习笔记-开发杂记","slug":"HarmonyOS学习笔记/HarmonyOS学习笔记-开发杂记","date":"2025-03-03T12:33:27.000Z","updated":"2025-03-02T17:23:20.269Z","comments":true,"path":"2025/03/03/HarmonyOS学习笔记/HarmonyOS学习笔记-开发杂记/","link":"","permalink":"http://mcdowell8023.github.io/2025/03/03/HarmonyOS学习笔记/HarmonyOS学习笔记-开发杂记/","excerpt":"","text":"网络请求 配置权限鸿蒙中发起网络请求 需要 配置权限应用需要在module.json5配置文件的requestPermissions标签中声明权限。​1234567891011121314151617181920\"requestPermissions\": [&#123; \"name\": \"ohos.permission.INTERNET\", \"usedScene\": &#123; \"abilities\": [ \"entryability\" ], \"when\":\"inuse\" &#125; &#125;, &#123; \"name\": \"ohos.permission.GET_NETWORK_INFO\", \"usedScene\": &#123; \"abilities\": [ \"entryability\" ], \"when\":\"inuse\" &#125; &#125;, ]还有，每次发起请求 每一个httpRequest对应一个HTTP请求任务，不可复用​还需要及时清理12345678910111213141516import &#123; http &#125; from \"@kit.NetworkKit\";// 每一个httpRequest对应一个HTTP请求任务，不可复用let httpRequest = http.createHttp(); httpRequest .request(url, requestOption) .then(async (res: http.HttpResponse) =&gt; &#123; // do something &#125;).catch((res) =&gt; &#123; // do something &#125;)// 取消订阅HTTP响应头事件httpRequest.off(\"headersReceive\");// 当该请求使用完毕时，调用destroy方法主动销毁httpRequest.destroy();简单封装了一个请求 源码‍ 文件相关‍ 文件下载12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import &#123; BusinessError, request &#125; from \"@kit.BasicServicesKit\";/** * @description: 下载文件 * @param &#123;string&#125; downloadUrl: 要下载的文件的url * @param &#123;string&#125; savePath: 保存路径 * @return &#123;*&#125; */export async function downloadFile( downloadUrl: string, savePath: string, context): Promise&lt;BusinessError&gt; &#123; return new Promise(async (resolve, reject) =&gt; &#123; // 下载文件 try &#123; request .downloadFile(context, &#123; url: downloadUrl, filePath: savePath, &#125;) .then((downloadTask: request.DownloadTask) =&gt; &#123; downloadTask.on(\"complete\", () =&gt; &#123; console.log( \"fileTools/file &gt;&gt; downloadFile ::log:: complete 文件下载成功，保存路径：\", savePath ); resolve(&#123; code: 200, message: \"文件下载成功\", name: \"downloadFile\", &#125;); &#125;); &#125;) .catch((err: BusinessError) =&gt; &#123; console.error( `fileTools/file &gt;&gt; downloadFile ::log:: catch:Invoke downloadTask failed, code is $&#123;err.code&#125;, message is $&#123;err.message&#125;` ); reject(err); &#125;); &#125; catch (error) &#123; let err: BusinessError = error as BusinessError; console.error( `fileTools/file &gt;&gt; downloadFile ::log:: try-catch:Invoke downloadFile failed, code is $&#123;err.code&#125;, message is $&#123;err.message&#125;` ); reject(err); &#125; &#125;);&#125; gizp 解压你往往发现 下载下来的文件 乱码 大小与 浏览器下载的大小不一致还不一致？？往往，服务器默认会对文件 进行 gzip 处理， 浏览器下载自动进行解压处理了 ，这里 我们需要 自己借助 pako 进行 gizp 解压‍使用 pako 进行 gizp 解压123456789101112131415161718192021222324252627282930313233343536373839404142import pako from \"pako\";import &#123; fileIo as fs &#125; from \"@kit.CoreFileKit\";/** * 解压gz文件方法 * * @since 7 * @permission N * @param &#123;string&#125; src - 解压缩的.gz文件的路径和名称. * @param &#123;string&#125; target - 解压缩的目标文件路径. * @returns &#123;void | Promise&lt;boolean&gt;&#125; return返回Promise否则返回true或false */export async function unGzipFile( src: string, target: string): Promise&lt;boolean&gt; &#123; try &#123; const reader = fs.openSync(src, fs.OpenMode.READ_ONLY); const stat = fs.statSync(src); const buf = new ArrayBuffer(stat.size); await fs.read(reader.fd, buf); const data: string | Uint8Array | undefined = pako.ungzip( new Uint8Array(buf) ); if (typeof data == \"string\") &#123; console.error(`fileTools/gzip &gt;&gt; unGzipFile ::log:: unGzipFile [src: $\\&#123;src&#125;,target: $\\&#123;target&#125;] data: $&#123;data&#125;`); return false; &#125; const writer = fs.openSync( target, fs.OpenMode.READ_WRITE | fs.OpenMode.CREATE ); fs.writeSync(writer.fd, data?.buffer); fs.closeSync(writer); fs.closeSync(reader); return true; &#125; catch (error) &#123; console.error( `fileTools/gzip &gt;&gt; unGzipFile ::log:: unGzipFile [src: $&#123;src&#125;,target: $&#123;target&#125;] error: $&#123;error&#125;` ); return false; &#125;&#125;‍ zip 解压如果文件是 压缩包，需要用到 zlib123456789101112131415161718192021222324252627282930313233343536373839404142import &#123; zlib, BusinessError &#125; from \"@kit.BasicServicesKit\";export async function unZipFile( inFile: string, outFile: string, opt?: zlib.Options): Promise&lt;boolean&gt; &#123; // 代码中使用的路径需为应用的沙箱路径，如/data/storage/el2/base/haps,也可以通过context获取。 // let inFile = '/xxx/filename.zip'; // let outFile = '/xxx/xxx'; let options: zlib.Options = opt || &#123; level: zlib.CompressLevel.COMPRESS_LEVEL_DEFAULT_COMPRESSION, memLevel: zlib.MemLevel.MEM_LEVEL_DEFAULT, strategy: zlib.CompressStrategy.COMPRESS_STRATEGY_DEFAULT_STRATEGY, &#125;; return new Promise((resolve, reject) =&gt; &#123; try &#123; // zlib.unzipFile zlib .decompressFile(inFile, outFile, options) .then((data: void) =&gt; &#123; console.info( \"fileTools/zipFile &gt;&gt; unZipFile ::log:: zipFile result is \" + JSON.stringify(data) ); resolve(true); &#125;) .catch((err: BusinessError) =&gt; &#123; console.error( \"fileTools/zipFile &gt;&gt; unZipFile ::log:: error is \" + JSON.stringify(err) ); reject(false); &#125;); &#125; catch (err) &#123; console.error( \"fileTools/zipFile &gt;&gt; unZipFile ::log:: error is \" + JSON.stringify(err) ); reject(false); &#125; &#125;);&#125; rawfile目录读取rawfile下的资源会打成一个hap包，没有对外暴露的文件路径，且没有获取文件绝对路径的api‍ Native侧读取rawfile目录文件Native Rawfile接口操作Rawfile目录和文件如果需要通过沙箱路径或绝对路径获取rawfile资源，就只能先将rawfile下资源拷贝进应用沙箱目录再进行操作。 ArkTS元应用侧读取rawfile目录文件getRawFileContentSyncgetRawFileContent下面是几个 arkTS rawfile 的操作实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148 /** * @description: 拷贝 zip 文件到沙箱路径, 并自动解压 * @param &#123;string&#125; fileName: 要拷贝的文件 '2001.zip' * @param &#123;string&#125; san的boxPath: 拷贝后的文件保存路径 'filesDir/2001' * @return &#123;*&#125; * @example copyRawFileZip('2001.zip', this.getDirPathTheme(), applicationContext); copyRawFileZip('2001.zip', '/data/storage/el2/base/files/Fmap/theme', applicationContext); */ public copyRawFileZip(fileName: string, sandBoxPath: string): Promise&lt;boolean&gt; &#123; return new Promise(async (resolve, reject) =&gt; &#123; try &#123; this.context.resourceManager.getRawFd(fileName, async (err, data) =&gt; &#123; if (err != null) &#123; console.error(`FMResourceManager.ts@copyRawFileZip &gt;&gt; getRawFd error : $&#123;JSON.stringify(&#123; fileName:fileName, sandboxPath:sandBoxPath,err:err &#125;)&#125; ` ); resolve(false); return; &#125; console.log(`FMResourceManager.ts@copyRawFileZip &gt;&gt; getRawFd : `, &#123; fileName:fileName, sandboxPath:sandBoxPath &#125;); await checkDir(sandBoxPath); await this.copyFile(fileName,sandBoxPath,data); // 此处依赖了一zip 解压函数 const isCompled = await unZipFile(sandBoxPath+'/'+fileName, sandBoxPath); this.context.resourceManager.closeRawFd(fileName, (err, data) =&gt; &#123; if (err != null) &#123; console.error(`FMResourceManager.ts@copyRawFileZip &gt;&gt; closeRawFd -&gt;:$&#123;JSON.stringify(err)&#125;`); &#125; &#125;); return resolve(isCompled ? true : false); &#125;); &#125; catch (error) &#123; let code = (error as BusinessError).code; let message = (error as BusinessError).message; console.error(`FMResourceManager.ts@copyRawFileZip &gt;&gt; catch -&gt;:$&#123;JSON.stringify(&#123;code:code,message:message&#125;)&#125;`, ); return(false); &#125; &#125;); &#125; /** * 拷贝rawfile到沙箱，md5验证文件，文件已经存在，返回已存在的文件名称 * @param fileName rawfile静态资源名称 * @param sandboxPath 沙箱目录 * @returns 复制后的文件名称,可能和传入的文件名不同 | null 拷贝失败 */ public async copyRawFile(fileName: string,sandboxPath: string) : Promise&lt;string&gt; &#123; console.log(`FMResourceManager.ts@copyRawFile &gt;&gt; 沙箱路径: $&#123;JSON.stringify(&#123;fileName,sandboxPath&#125;)&#125;`); try &#123; let data = await this.context.resourceManager.getRawFdSync(fileName); //先将文件复制到临时目录,然后校验md5,如果已有文件，则删除临时文件，返回已有文件的 文件名，如果没有相同文件，则从临时目录移动到最终目录 let tempPath = sandboxPath+\"/temp\"; let tempFileName = tempPath +\"/\" + fileName; console.log(`FMResourceManager.ts@copyRawFile &gt;&gt; 复制临时文件 $&#123;JSON.stringify(&#123;tempPath&#125;)&#125;`); await this.copyFile(fileName,tempPath,data); console.log(`FMResourceManager.ts@copyRawFile &gt;&gt; 计算文件 Md5 $&#123;JSON.stringify(&#123;tempFileName&#125;)&#125;`); let rawFdFileMd5 = await calFileMd5(tempFileName); if(rawFdFileMd5 == null)&#123; return; &#125; //校验文件 md5判断是否有重复文件 let filenames = await fileIo.listFileSync(sandboxPath); for (let i = 0; i &lt; filenames.length; i++) &#123; let path = sandboxPath +\"/\"+filenames[i]; if(filenames[i] === 'temp')continue; let fileMd5 = await calFileMd5(path); if(fileMd5 == null) continue; console.log(`FMResourceManager.ts@copyRawFile &gt;&gt; 计算目标目录下文件md5-&gt;$&#123;JSON.stringify(&#123;path,fileMd5&#125;)&#125;`); if(fileMd5 === rawFdFileMd5)&#123; //将临时文件删除 console.log(`FMResourceManager.ts@copyRawFile &gt;&gt; 找到md5相同的文件，返回该文件名-&gt;$&#123;JSON.stringify(&#123;path,fileMd5,rawFdFileMd5&#125;)&#125;`); fileIo.unlink(tempFileName); return filenames[i]; &#125; &#125; //未找到md5同一的文件，则移动临时文件到最终目录 console.log(`FMResourceManager.ts@copyRawFile &gt;&gt; 没有重复文件，拷贝文件到指定目录 -&gt;$&#123;JSON.stringify(&#123;tempFileName,dest:sandboxPath+\"/\"+fileName&#125;)&#125;`); await fileIo.copyFile(tempFileName, sandboxPath+\"/\"+fileName); console.log(`FMResourceManager.ts@copyRawFile &gt;&gt; 删除临时文件-&gt;$&#123;JSON.stringify(&#123;tempFileName&#125;)&#125;`); await fileIo.unlink(tempFileName); return fileName; &#125; catch (error) &#123; let code = (error as BusinessError).code; let message = (error as BusinessError).message; console.error(`FMResourceManager.ts@copyRawFile catch error :-&gt;$&#123;JSON.stringify(&#123;code:code,message:message&#125;)&#125;`); return; &#125; &#125;/** * 计算文件 md5 * @param fileUrl 文件路径 * @returns 文件md5 */export async function calFileMd5(fileUrl: string): Promise&lt;string | null&gt; &#123; try&#123; return await hash.hash(fileUrl, \"md5\"); &#125;catch (e)&#123; FMLog.i(\"file.ts@calFileMd5 &gt;&gt; calFileMd5 : \",e); &#125; return null;&#125; /** * 将传入文件拷贝到指定目录 * @param fileName 文件资源名称 * @param sandboxPath 沙箱目录 * @returns */ public async copyFile(fileName: string, sandboxPath: string,data:any)&#123; try&#123; await checkDir(sandboxPath); let destFilePath = sandboxPath+'/'+fileName; console.log(`FMResourceManager.ts@copyFile &gt;&gt; copyFile `,&#123;destFilePath&#125;); let dest = fileIo.openSync(destFilePath,fileIo.OpenMode.CREATE | fileIo.OpenMode.READ_WRITE); let bufsize = 4096; let buf = new ArrayBuffer(bufsize); let off = 0,len = 0,readedLen = 0; /** * 通过buffer将rawfile文件内容copy到沙箱路径 */ while (len = fileIo.readSync(data.fd, buf, &#123; offset: data.offset + off, length: bufsize &#125;)) &#123; readedLen += len fileIo.writeSync(dest.fd, buf, &#123; offset: off, length: len &#125;) off = off + len if ((data.length - readedLen) &lt; bufsize) &#123; bufsize = data.length - readedLen &#125; &#125; fileIo.close(dest.fd); &#125;catch (e) &#123; console.error(`FMResourceManager.ts@copyFile &gt;&gt; copyFile catch error-&gt;: $&#123;JSON.stringify(e)&#125; `); &#125; &#125;‍ 根据传入的字符串生成图片实现思路：使用 @Builder​ 函数组件 作为 截图对象。（函数组件如果为全局，可能会报错）使用 componentSnapshot.createFromBuilder​ 进行离屏渲染截图截图后得到包装图片包装对象，使用 pixelMap.readPixelsToBufferSync​ 或者 image.createImagePacker​ 的packToData​ 进行解码代码‍","categories":[{"name":"客户端","slug":"客户端","permalink":"http://mcdowell8023.github.io/categories/客户端/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://mcdowell8023.github.io/tags/笔记/"},{"name":"HarmonyOS","slug":"HarmonyOS","permalink":"http://mcdowell8023.github.io/tags/HarmonyOS/"},{"name":"拓展","slug":"拓展","permalink":"http://mcdowell8023.github.io/tags/拓展/"}]},{"title":"HarmonyOS学习笔记 - har 包构建&&发布","slug":"HarmonyOS学习笔记/HarmonyOS学习笔记 - har 包构建&&发布","date":"2025-03-02T10:26:47.000Z","updated":"2025-03-02T10:26:56.506Z","comments":true,"path":"2025/03/02/HarmonyOS学习笔记/HarmonyOS学习笔记 - har 包构建&&发布/","link":"","permalink":"http://mcdowell8023.github.io/2025/03/02/HarmonyOS学习笔记/HarmonyOS学习笔记 - har 包构建&&发布/","excerpt":"","text":"‍ HAR 的介绍HAR（Harmony Archive）是静态共享包，可以包含代码、C++ 库、资源和配置文件。通过 HAR 可以实现多个模块或多个工程共享 ArkUI 组件、资源等相关代码。‍ 使用用场景作为二方库，发布到 OHPM 私仓，供公司内部其他应用使用。作为三方库，发布到 OHPM 中心仓，供其他应用使用。 HAR 约束限制‍不支持在设备上单独安装/运行，只能作为应用模块的依赖项被引用。不支持在配置文件中声明​**UIAbility​组件与​ExtensionAbility​组件**。不支持在配置文件中声明​**pages​页面**，但是可以包含 pages 页面，并通过命名路由的方式进行跳转。不支持引用 AppScope 目录中的资源。在编译构建时，AppScope 中的内容不会打包到 HAR 中，因此会导致 HAR 资源引用失败。可以依赖其他 HAR，但不支持循环依赖，也不支持依赖传递。‍ 构建 HAR‍ 工具准备ide : devEoc-studio [ 安装到华为官网自行下载 ]ohpm 命令行工具： 使用手册下载 Command Line Tools 解压后 拷贝到 ～/ 目录下 ,重新命名为 .ohpm_tools​ 「 ps 如果 .ohpm 不冲突也可以 不修改 」cd 进入 .ohpm_tools/bin​ 目录下 执行 ./init​将 ohpm 配置到环境变量中:1234567export OHPM_HOME=/home/xx/Downloads/ohpm #本处路径请替换为ohpm的安装路径export PATH=$&#123;OHPM_HOME&#125;/bin:$&#123;PATH&#125;## 例如export OHPM_HOME=\"$HOME/.ohpm_tools\" #本处路径请替换为ohpm的安装路径export PATH=$&#123;OHPM_HOME&#125;/bin:$&#123;PATH&#125;%‍‍ 1、创建库模块 1）新建一个鸿蒙项目（或者使用原有项目也可以），以新建的鸿蒙项目 fengmap_harmony_sdk​ 为例，鼠标移到工程目录顶部，单击右键，选择 New &gt; Module，在工程中添加模块：‍​​‍2）在 Choose Your Ability Template 界面中，选择 Static Library，并单击 Next：‍‍ 3）在 Configure New Module 界面中，设置新添加的模块信息（以新增模块 fengmap_harmony_sdk​ 为例），设置完成后，单击 Finish 完成创建。Module name：新增模块的名称。比如：fengmap_harmony_sdk​。Device type：支持的设备类型。Enable native：是否创建一个用于调用 C++ 代码的模块。‍​​​‍ ？？已经存在模块如果已经有了要打包的模块，那么 选中模块 shift+F6 弹出菜单 选择《重命名模块》修改名称即可，devEoc-studio 会自动帮你修改所有相关名称‍‍ 2、HAR 包的构建将要发布使用的代码放在 src/main/ets/components 目录下，比如新增一个 ets 文件 index.ets。 随便写些功能，如增加 FMMapViewComponent 页面。在模块包根目录下 Index.ets 如 fengmap_harmony_sdk/Index.ets​ 导出页面1export &#123; FMMapViewComponent &#125; from './src/main/ets/components/FMMapViewComponent'‍在模块的 fengmap_harmony_sdk/oh-package.json5​ 文件修改希望使用的 引用名称。 如：@fengmap/sdk​ 根据官方名规范 为 @+组织名称/名称​ 当然在该文件可以修改某些 包的关键信息，如： 版本 version​ 、描述 description​ 、入口 main​、开源仓库检索关键字 keywords​、作者 author​、开源协议 license​如现在命名为：@fengmap/sdk 那么用户在 引入调用的 名称 与此一致实际使用 import { FMMapViewComponent } from '@fengmap/sdk';​12345678910&#123; \"name\": \"@fengmap/sdk\", \"version\": \"1.0.0\", \"description\": \"XXXX\", \"main\": \"Index.ets\", \"author\": \"wxq24\", \"license\": \"Apache-2.0\", \"dependencies\": &#123;&#125;, \"compatibleSdkType\": \"HarmonyOS\"&#125;‍‍开发完库模块后，选中模块名，然后通过 DevEco Studio 菜单栏的 Build &gt; **Make Module '**​fengmap_harmony_sdk​ ’ 进行编译构建，生成 HAR。HAR 可用于工程其它模块的引用，或将 HAR 上传至 ohpm 仓库，供其他开发者下载使用。若部分源码文件不需要打包至 HAR 中，可通过创建.ohpmignore 文件，配置打包时要忽略的文件/文件夹。使用 release 模式构建 HAR 具体看。 其他构建方式 具体看 官方构建文档点击 DevEco Studio 右上角图标 Build Mode 中选择 release。 默认为 &lt;Default&gt; 模式：在编译 App 时使用 release 模式，编译 HAP/HSP/HAR 时使用 debug 模式。​​在使用 release 模式 为保护代码资产，建议开启混淆。 在模块级 build-profile.json5 文件 配置如下：1234567891011121314151617181920212223242526272829303132&#123; \"apiType\": \"stageMode\", \"buildOption\": &#123; &#125;, \"buildOptionSet\": [ &#123; \"name\": \"release\", \"arkOptions\": &#123; // 混淆相关参数 \"obfuscation\": &#123; \"ruleOptions\": &#123; // true表示进行混淆，false表示不进行混淆。5.0.3.600及以上版本默认为false \"enable\": true, // 混淆规则文件 \"files\": [ \"./obfuscation-rules.txt\" ] &#125;, // consumerFiles中指定的混淆配置文件会在构建依赖这个library的工程或library时被应用 \"consumerFiles\": [ \"./consumer-rules.txt\" ] &#125; &#125;, &#125;, ], \"targets\": [ &#123; \"name\": \"default\" &#125; ]&#125;最外层工程级 build-profile.json5 ​中的 useNormalizedOHMUrl 字段设置为 false。12345678910111213&#123; \"app\": &#123; \"products\": [ &#123; \"buildOption\": &#123; \"strictMode\": &#123; \"useNormalizedOHMUrl\": false &#125; &#125; &#125; ] &#125;&#125;构建成功后，会生成一个包 fengmap_harmony_sdk​.har，在 build/default/outputs/default/fengmap_harmony_sdk​.har 路径下。​​​‍‍ 3、HAR 包的导入和使用1）验证下本地构建好的 HAR 包是否可以在项目中导入和使用，首先新建一个测试项目 maptest​ ，工程目录下新建文件夹 libs，并将 fengmap_harmony_sdk​.har 包拷贝到该目录下，打开项目的 oh-package.json5​ 添加 har 包的依赖，最后执行同步操作 Sync Now​​‍​maptest​ 项目 下的 oh-package.json5​ 示例如下：1234567891011&#123; \"name\": \"entry\", \"version\": \"1.0.0\", \"description\": \"Please describe the basic information.\", \"main\": \"\", \"author\": \"\", \"license\": \"\", \"dependencies\": &#123; \"@fengmap/sdk\": \"file:../libs/fengmap_harmony_sdk.har\" &#125;&#125;‍‍2）导入成功后，会生成一个文件 oh-package-lock.json5​，里面详细记录导入的包的信息​​‍3）在 ets/pages Index.ets ​中导入包的头文件，调用 har 包中的相关代码。123456789101112import &#123; FMMapViewComponent &#125; from '@fengmap/sdk';@Entry@Componentstruct Index &#123; build() &#123; Column() &#123; FMMapViewComponent() &#125; .height('100%') .width('100%') &#125;&#125;4）接下来运行项目，查看效果。没有问题 至此 结束。 「 如果不准备 上传到 开源仓库 让用户通过命令使用，此处构建已经结束。 直接本地分发使用即可」‍ 发布 HAR 包 1. 在库模块 fengmap_harmony_sdk ​中（与 src 文件夹同一级目录下），修改 oh-package.json5 文件内容，如下：12345678910111213141516171819202122232425262728&#123; \"name\": \"@fengmap/sdk\", \"version\": \"1.0.0\", \"description\": \"XXXXXXXXXXXX\", \"main\": \"Index.ets\", \"keywords\": ['map','fengmap','mapSDK','室内地图','地图SDK'], \"author\": \"fengmap\", \"license\": \"Apache-2.0\", \"dependencies\": &#123; \"liblibrary.so\": \"file:./src/main/cpp/types/liblibrary\", \"pako\": \"^2.1.0\" &#125;, \"devDependencies\": &#123; \"@types/pako\": \"^2.0.0\" &#125;, \"dynamicDependencies\": &#123;&#125;, \"compatibleSdkVersion\": \"12\", \"compatibleSdkType\": \"HarmonyOS\", \"obfuscated\": false, \"nativeComponents\": [ &#123; \"name\": \"liblibrary.so\", \"compatibleSdkVersion\": \"12\", \"compatibleSdkType\": \"HarmonyOS\" &#125; ]&#125;name：HAR 包名。在 ohpm 中包的命名格式为 @&lt;group&gt;/&lt;package_name&gt; 或者 &lt;package_name&gt; 。其中 group 是组织，package_name 是包名。当想要上传一个含有组织（例如 @fengmap/map）的包时，在 ohpm-repo 中需要先创建出该组织（例如 fengmap）才能进行上传。该组织名称需要审核，只有审核通过后，才能在该组织下发布包，所以要提前申请。具体的申请，请参考官方文档：组织管理。version：包的版本号，一般从 1.0.0 开始。description：包的描述。main: 定义包的主入口文件。author：开发者名称。license: 包的许可证类型。dependencies: 列出项目运行时必需的依赖包及其版本。其他配置具体看官方文档配置以上信息中的 name、author、description，会在 OpenHarmony 三方库中心仓中展示。⚠️ 注意：在后面的 README.md 文件或者 CHANGELOG.md 中如果介绍包信息，其中包名一定要和 name 中设置的包名（@wxqos/wxqcolor）一致，否则有审核失败的风险！！！‍ 2. 添加其他必要文件新建 README.md 文件： 在 README.md 文件中必须包含包的介绍和引用方式，还可以根据包的内容添加更详细介绍。​​新建 CHANGELOG.md 文件：填写 HAR 的版本更新记录。​​‍添加 LICENSE 文件：LICENSE 许可文件。 可以去 Apache License, Version 2.0 直接粘贴 具体格式 进行修改‍12345678910111213Copyright 发布年份 应用组织Licensed under the Apache License, Version 2.0 (the \"License\");you may not use this file except in compliance with the License.You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0Unless required by applicable law or agreed to in writing, softwaredistributed under the License is distributed on an \"AS IS\" BASIS,WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.See the License for the specific language governing permissions andlimitations under the License.⚠️ 注意：以上内容要保证文件不缺失、内容正确且真实，不然之后的审核有可能会通不过！‍ 3、修改完以上信息后，需要重新执行下 Make Module ‘fengmap_harmony_sdk​’ 编译构建一个新的 fengmap_harmony_sdk​.har 包。‍ 4、开始发布利用工具 ssh-keygen 生成公、私钥，可通过执行以下命令来生成公钥和私钥：1234ssh-keygen -m PEM -t RSA -b 4096 -f ~/.ssh_ohpm/mykey## 例如ssh-keygen -m PEM -t RSA -b 4096 -f ~/.ssh_ohpm/fengmapKey‍❗️ 前提： 如果没有~/.ssh_ohpm 目录需要先创建 mkdir .ssh_ohpm⚠️ 注意：OHPM 包管理器只支持加密密钥认证，请在生成公私钥时输入密码, ❗️ 并要记住密码，发布时候会使用OHPM 包管理器只支持加密密钥认证，请在生成公私钥时输入密码。【解释：就是上面说的密码，后面上传包的时候会用】‍登录 OpenHarmony 三方库中心仓官网，单击主页右上角的个人中心，新增 OHPM 公钥，将公钥文件（XXX.pub）的内容粘贴到公钥输入框中。​​​使用 命令行 配置私钥路径：（ 此处需要 使用 ohpm 工具包 ）123ohpm config set key_path your-keypath## 例如ohpm config set key_path ~/.ssh_ohpm/fengmapKey～/.ohpm/.ohpmrc 隐藏文件 中会填充一条内容，表示命令执行成功 :12&gt; key_path=/Users/xxx/.ssh_ohpm/fengmapKey&gt;配置登录用户发布码：登录 OpenHarmony 三方库中心仓官网，单击主页右上角的个人中心，复制发布码​​获取发布码并配置到 .ohpmrc 文件中，可执行如下命令：1234ohpm config set publish_id your_publish_id## 如：ohpm config set publish_id VC2A1KN4Y8此处 亦会 在 ～/.ohpm/.ohpmrc 进行追加:123&gt; key_path=/Users/mcdowell/.ssh_ohpm/fengmapKe&gt; publish_id=VC2A1KN4Y8&gt;‍‍‍执行如下命令发布 HAR，&lt;HAR 路径&gt;需指定为.har 文件的绝对路径1ohpm publish /Users/mcdowell/project/HarmonyProject/fengmap_harmony/fengmap_harmony_sdk/build/default/outputs/default/fengmap_harmony_sdk.har⚠️ 注意：其中会让你输入一个密码，就是上面说的上传包的密码。‍如果在输入密码后，见到这句 Thanks for your contribution, the submitted OHPM library is under review, you can check the package status from https://ohpm.openharmony.cn/#/cn/personalCenter/package​ 那么就表示成功。‍❗️ 报错：ohpm ERROR: The “paths[1]” argument must be of type string. Received undefined — &gt; 注意 ohpm 版本，低版会出现该问题，尝试升级到最新版本‍‍在 OpenHarmony 三方库中心仓的消息中能查看到你提交的信息，以及审核结果的信息：​​​​审核通过后，就可以在 OpenHarmony 三方库中心仓中搜索到了：‍​​‍​​‍ 发布成功 HAR 包的导入和使用‍ 在项目的 Terminal 执行导入命令：1ohpm install @fengmap/sdk‍ 具体的使用和上面本地 har 包使用一样：1import &#123; FMMapViewComponent &#125; from '@fengmap/sdk'开始使用 食用即可。‍","categories":[{"name":"客户端","slug":"客户端","permalink":"http://mcdowell8023.github.io/categories/客户端/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://mcdowell8023.github.io/tags/笔记/"},{"name":"HarmonyOS","slug":"HarmonyOS","permalink":"http://mcdowell8023.github.io/tags/HarmonyOS/"},{"name":"拓展","slug":"拓展","permalink":"http://mcdowell8023.github.io/tags/拓展/"}]},{"title":"HarmonyOS学习笔记-初识","slug":"HarmonyOS学习笔记/HarmonyOS学习笔记-初识","date":"2025-01-16T00:26:17.000Z","updated":"2025-03-02T10:36:39.835Z","comments":true,"path":"2025/01/16/HarmonyOS学习笔记/HarmonyOS学习笔记-初识/","link":"","permalink":"http://mcdowell8023.github.io/2025/01/16/HarmonyOS学习笔记/HarmonyOS学习笔记-初识/","excerpt":"","text":"1.1 准备 1.1.1 前置了解 1.1.1.1 开发套件一套开发多端部署devEcoStudio 统一开发编辑器ArkTs 编程语言 类TypeScriptArkUI： 官方提供的 声明式UI开发框架编辑器汉化 [ 不推荐]settings &gt; plugins &gt; “ installed ” tab 下搜索 chinese , 然后勾选重启 变为 中文 1.1.1.2 UI框架HarmonyOS提供了一套UI开发框架，即方舟开发框架（ArkUI框架），提供了两种开发范式，分别是基于ArkTS的声明式开发范式（简称“声明式开发范式”）数据驱动更新，使用 ArkTS语言 适用于 复杂度较大、系统应用（基于ArkUI进行页面构造布局，并用封装属性来进行页面渲染和布局优化）兼容JS的类Web开发范式（简称“类Web开发范式”）数据驱动更新， 使用 JS语言 来开发 界面较为简单的程序应用和卡片，适用于Web前端开发人员 （对于web开发人员只是一个新的框架）更多UI框架的开发内容及指导，详见UI开发。 1.1.1.3 应用模型‍应用模型是HarmonyOS为开发者提供的应用程序所需能力的抽象提炼，它提供了应用程序必备的组件和运行机制。有了应用模型，开发者可以基于一套统一的模型进行应用开发，使应用开发更简单、高效。‍Stage模型： HarmonyOS API 9开始新增的模型，是目前主推且会长期演进的模型。在该模型中，由于提供了AbilityStage、WindowStage等类作为应用组件和Window窗口的“舞台”，因此称这种应用模型为Stage模型。Stage模型开发可见Stage模型开发概述。快速入门以此为例提供开发指导。FA（Feature Ability）模型： HarmonyOS API 7开始支持的模型，已经不再主推。FA模型开发可见FA模型开发概述。快速入门章节不再对此展开提供开发指导。FA模型和Stage模型的整体架构和设计思想等更多区别，请见应用模型。 1.2 开始开发 1.2.1 下载安装开发工具请[安装最新版DevEco Studio](https://developer.huawei.com/consumer/cn/download/)。 注意：5.X以后 不要配置 配置nodejs 【 建议本地开发使用18.x , 镜像源使用 华为，避免后面编译、调试报错 。如报错：Only files in a module can be previewed. 】修改npm 镜像源 npm config set registry https://repo.huaweicloud.com/repository/npm/​一键安装； mac X86 系统 新版已经不再支持 模拟器‍ 1.2.2 创建开发若首次打开DevEco Studio，请点击Create Project创建工程。如果已经打开了一个工程，请在菜单栏选择File &gt; New &gt; Create Project来创建一个新工程。选择Application应用开发（本文以应用开发为例，Atomic Service对应为元服务开发），选择模板“Empty Ability”，点击Next进行下一步配置。若开发者需要进行Native相关工程的开发，请选择“Native C++ ”模板，更多模板的使用和说明请见工程模板介绍。​​进入配置工程界面，Compatible SDK表示兼容的最低API Version，此处以选择“5.0.0(12) ”为例，其他参数保持默认设置即可。​​点击Finish，工具会自动生成示例代码和相关资源，等待工程创建完成。 目录介绍AppScope &gt; app.json5：应用的全局配置信息，打包编译阶段使用的配置。详见app.json5配置文件。entry：HarmonyOS工程模块，编译构建生成一个HAP包。src &gt; main &gt; ets：【类似原来项目的src】 用于存放ArkTS源码 ,可以存在多个。src &gt; main &gt; ets &gt; entryability：应用/服务的入口, 一个 entryability 对应一个程序的基本单元（窗口），承载用户信息，可以存在多个。src &gt; main &gt; ets &gt; entrybackupability：应用提供扩展的备份恢复能力。src &gt; main &gt; ets &gt; pages：应用页面。src &gt; main &gt; resources： [ 相当于 assest ] 存放应用/服务所用到的资源文件，如图形、多媒体、字符串、布局文件等。关于资源文件，详见资源分类与访问。src &gt; main &gt; resources &gt; base &gt; profile &gt; main_pages.json : 路由配置 【通过 ide 增加 页面，会自动增加页面路由】src &gt; main &gt; module.json5：模块配置文件。主要包含HAP包的配置信息、应用/服务在具体设备上的配置信息以及应用/服务的全局配置信息。具体的配置文件说明，详见module.json5配置文件。build-profile.json5：当前的模块信息 、编译信息配置项，包括buildOption、targets配置等。hvigorfile.ts：模块级编译构建任务脚本。obfuscation-rules.txt：混淆规则文件。混淆开启后，在使用Release模式进行编译时，会对代码进行编译、混淆及压缩处理，保护代码资产。详见开启代码混淆。oh-package.json5：用来描述包名、版本、入口文件（类型声明文件）和依赖项等信息。oh_modules：用于存放三方库依赖信息。build-profile.json5：工程级配置信息，包括签名signingConfigs、产品配置products等。其中products中可配置当前运行环境，默认为HarmonyOS。hvigorfile.ts：工程级编译构建任务脚本。oh-package.json5：【类似node项目的 package.json】主要用来描述全局配置，如：依赖覆盖（overrides）、依赖关系重写（overrideDependencyMap）和参数化配置（parameterFile）等。‍ 常用开发目录创建entry &gt; src &gt; main &gt; ets:apis : 用于接口请求开发 声明utils : 工具函数目录view : 组件目录viewModel : 存放数据和约束pages：页面开发目录lib： 存放三方插件‍ 创建页面在 pages 页面开发目录 , 右键 新建 &gt; page &gt; Empty Page ( ide 会自动增加页面路由) ;或者 ArkTS File， 但是此种方式需要 手动增加路由‍ 创建组件在 view 组件目录 , 右键 新建 &gt; ArkTS File123456789101112@Preview // 预览组件// @Entry // 组件不该使用@Entry; 页面才使用@Compoentexport struct Header &#123; build()&#123; Column()&#123; Text('这是一个Header组件' ) &#125; .width('100%') .height('100%') &#125;&#125; 创建工具类在 utils 组件目录 , 右键 新建 &gt; ArkTS File1234567891011121314151617181920// 示例创建一个名称为 dataFormat.est 文件// 用于数据格式化// 公用函数 需要使用class 方式呈现export class DataFormat &#123; // 日期格式化函数 dateFormat(value:Date)&#123; const year = value.getFullyer(); const month = value.gerMonth() + 1; const day = value.getDate(); return `$&#123;year&#125;-$&#123;month&#125;-$&#123;day&#125;` &#125;&#125;export default new DataFormat();//******** 使用 ***********// 引入import DataFormat from \"@../utils/dataFormat\"// 调用const dateString = DataFormat.dateFormat(new Date());‍ 预览器运行选择pages 下的页面 ets 页面，选择右侧 **Previewer 预览 按钮，进行预览「 支持热更新」; 预览器工具说明一览：​​调试： 顶部 检查按钮点开调试 类似浏览器，可以进行页面调试刷新： 顶部刷新按钮点击，可以更新页面预览 预览页面 预览组件​​ 可以切换设备尺寸 进行预览​​设备模拟窗口上面 三个按钮依次 是 返回 、横屏、 更多更多 ：中可以 切换语言、设置分辨率、显示安全区 预览器debugger 调试：增加代码断点后，在编辑窗口选择设备为 previewer ，点击 进行 debugger 调试。 使用真机运行应用需要 搭载HarmonyOS 5.X 系统的手机手机端点击系统版本，开启开发者模式。将真机与电脑连接。使用无线方式需要开启服务，需要安装 hdc 工具包，且官方文档 提到tcp 连接方式存在不稳定情况。推荐线连具体指导及要求，可查看使用本地真机运行应用/服务。ide 自动签名： 点击File &gt; Project Structure… &gt; Project &gt; SigningConfigs界面勾选“Support HarmonyOS”和“Automatically generate signature”，点击界面提示的“Sign In”，使用华为账号登录。 【此处需要 完成签名部分，具体看 应用/元服务签名】 等待自动签名完成后，点击“OK”即可。如下图所示：​‍‍在不签名情况，运行手机在报错日志中的链接也可跳转 如下图所示：​在编辑窗口右上角的工具栏，点击 按钮运行。debugger 调试： 增加代码断点后，在编辑窗口右上角的工具栏，点击 进行 debugger 调试。debugger 调试 说明F8：单步跳过。代表 进入下一段代码。 如果当前代码是函数调用，默认不会关注函数内部，只会得到结果F7: 单步调试。代表进行 下一段代码调试。 如果当前代码是函数调用，默认进入函数内部调试‍","categories":[{"name":"客户端","slug":"客户端","permalink":"http://mcdowell8023.github.io/categories/客户端/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://mcdowell8023.github.io/tags/笔记/"},{"name":"HarmonyOS","slug":"HarmonyOS","permalink":"http://mcdowell8023.github.io/tags/HarmonyOS/"},{"name":"拓展","slug":"拓展","permalink":"http://mcdowell8023.github.io/tags/拓展/"}]},{"title":"直播动画方案","slug":"直播/直播动画方案","date":"2023-03-22T01:38:07.000Z","updated":"2025-03-02T10:32:53.125Z","comments":true,"path":"2023/03/22/直播/直播动画方案/","link":"","permalink":"http://mcdowell8023.github.io/2023/03/22/直播/直播动画方案/","excerpt":"","text":"首先梳理web场景下，动画播放的几种方式。‍ 方案对比目前较常见的动画实现方案有原生动画、帧动画、gif/webp、lottie/SVGA，对于复杂动画特效的实现做个简单对比方案优势劣势css动画使用方便还原程度 取决工程师和 动画复杂程度； 复杂动画实现成本高序列帧动画实现成本低还原程度中，比较固定，部分复杂特效不支持，且资源消耗大gif实现成本低还原度低，只支持8位（256）颜色，且资源消耗大，质量较大。最重要的 不能交互webp实现成本低还原程度中，资源消耗大；考虑IOS兼容问题，最重要的 不能交互Lottie/SVGA实现成本低部分复杂特效不支持透明mp4视频性能好，一次接入永久使用还原度高css动画在实现简单页面交互上是比较常用，当设计师提供较高要求的 动画效果，就比较挠头了。gif实现简单，质量较大。最重要的 不能交互。WebpWebp相比PNG和JPEG格式体积可以减少25%，在移动端的平台支持上也很全面，支持24位RGB色；缺点是资源体积比较大，而且使用的软解效率低下，低端机上有明显卡顿问题。且在比较低版本的ios 机型存在 比较大的兼容问题。 最重要的 不能交互。Lottie​/​SVGA在不涉及mask和mattes等特性时性能非常优秀，主要耗时基本集中在Canvas#draw()上而已。然而在设计实现复杂遮罩、光影渐变上效果一般且异常消耗性能。对于直播场景的复杂特效动画而言，他们就不是一个很合适的实现方案了。‍ 透明mp4视频 方案透明视频 由于出色的还原度和良好的性能，非常适合 复杂直播场景。 又详细分为以下几类：方案优势劣势video + css 滤色(cssmix-blend-mode: screen;​)工作量小、体积小只适用于黑色背景视频webm透明视频原生支持兼容性差（透明只在Chrome和Opera中得到支持）canvas 绘制透明视频动画效果好CPU占用高webgl绘制透明视频动画效果好，CPU占用小学习成本 video + css 滤色 实现透明实现过程： 一个黑色背景的 **特效图片** 或者 **视频** 覆盖在目标 层上，加上 `mix-blend-mode: screen;`​ css 样式，即可实现 透明 图片或视频 播放动画的效果。 ‍其实现逻辑基于 混色计算方式：C = 255 - (255-A) ✖️ (255-B) / 255如： A 是 红色 RGB(255,0,0); B 是 蓝色 RGB(0,0,255) 那么： R = 255 - (255 - 255) * (255 - 0) / 255 = 255 G = 255 - (255 - 0) * (255 - 0) / 255 = 0 B = 255 - (255 - 0) * (255 - 255) / 255 = 255 直观特性：任何颜色和黑色执行滤色，还是呈现原来的颜色；任何颜色和白色执行滤色得到的是白色；任何颜色和其他颜色执行滤色模式混合后的颜色会更浅，有点类似漂白的效果。详细讲解 戳 深入理解CSS mix-blend-mode滤色screen混合模式‍其实这种 过于简单粗暴了，如果我们的动画 背景是 黑色透明度的呢？ 上面的计算可是 没有 Alpha 通道的。这时候就要说到 绘制透明视频了‍ webgl绘制透明视频 原理首先看段 视频, 这是我们设计师 实际导出 的动画视频（别误会，右侧 不是出了问题）。​​​ ‍我们会发现视频播放 右侧 类似高度曝光的视频，其实 记录的 Alpha 通道 的值，通常被放在 R通道。所以 我们取出 右侧视频区域的R通道的值，与左侧原视频的RGB值 进行重新组合，绘制 RGBA 的 图片即可。然后 一帧一帧的播放 绘制即可。即可实现 上面的 第二张图的 透明视频的动画效果。‍ 基本原理如果还有不明白 可以看下 这里的解释主要有两个部分，一个是视频播放器，负责视频解码；另一个是绘制器，负责将解析出来的每一帧画面进行透明度 混合，再绘制到 Canvas 画布上。视频播放器 ： 在素材是 MP4 的情况下，其实使用 浏览器的 video 就完全可以胜任了【 毕竟使用其他播放器解码又要增加代码体积了 】绘制器： 至于 到底使用canvs 还是 webGL 其实就是看性能了。毕竟 webGL直接使用 GPU硬件，性能上要高上不少。 实现 视频播放器：12345678910111213141516171819202122232425262728293031323334const src = `https://s3.amazonaws.com/liveme.storage.test/liveglb/202004171204/gifts/resource_manage/f8d6b_md5_f71ec37a5350a219500fef89335c3be9_.mp4`let playing = false;const video = document.createElement(\"video\");video.autoplay = false;video.mute = true;video.volume = 0;video.muted = true;video.loop = loop;video.setAttribute(\"x-webkit-airplay\", \"true\");video.setAttribute(\"webkit-playsinline\", \"true\");video.setAttribute(\"playsinline\", \"true\");video.style.display = \"none\";video.src = src;video.crossOrigin = \"anonymous\";video.addEventListener(\"play\", () =&gt; &#123;// 使用 requestAnimationFrame 开始绘制 window.requestAnimationFrame(() =&gt; &#123; drawFrame(); &#125;);&#125;);document.body.appendChild(video);// 绘制 函数function drawFrame() &#123; if (playing) &#123; // webGL 绘制 drawWebglFrame(); &#125; // 下一帧继续绘制 window.requestAnimationFrame(() =&gt; &#123; drawFrame(); &#125;);&#125;‍‍ 绘制器在使用 webGL 绘制前 ，我们需要了解一些概念。WebGL 主要是 低级光栅化 API, 不是 3D API。要使用 WebGL 绘制图像，您必须传递表示 图像的向量。然后，它使用 OpenGL SL 将给定的 矢量 转换为 像素格式，并在屏幕上显示图像。着色器着色器 是使用 OpenGL ES 着色语言(GLSL) 编写的程序，它携带着 记录着像素点的位置和颜色 的信息。GLSL编写 着色器程序，并将代码文本传递给 WebGL，在 GPU 执行时编译​着色器 分为： 顶点着色器和片段着色器顶点着色器 ： 主要记录着像素点的位置， 决定了 3D 物体在屏幕上的位置和形状​每次渲染一个形状时，顶点着色器 会在形状中的 每个顶点运行。它的工作是将 输入顶点 从原始坐标系转换到 WebGL 使用的 裁剪空间 坐标系，其中每个轴的坐标范围从 -1.0 到 1.0，并且不考虑纵横比，实际尺寸或任何其他因素；顶点着色器根据需要，也可以完成其他工作。例如，决定哪个包含 texel 面部纹理的坐标，可以应用于顶点；通过 法线 来确定 应用到顶点的光照因子等。 然后将这些信息存储在 变量（varyings)或属性 (attributes)属性中，以便与片段着色器共享。片段着色器： 主要记录着像素点的颜色​片段着色器在 顶点着色器 处理完图形 的顶点后，会被要绘制的每个图形的每个像素点调用一次。它的职责是 确定像素的颜色，通过指定应用到像素的纹理元素（也就是图形纹理中的像素），获取纹理元素的颜色，然后将 适当的光照应用于颜色。之后颜色存储在特殊变量 gl_FragColor 中，返回到 WebGL 层。该颜色将最终绘制到屏幕上图形对应像素的对应位置。基本过程1234创建着色器（顶点、片段）程序 ====&gt; 绘制创建缓冲区并绑定 ｜｜ ｜｜ 读取黄缓冲区变量 ====&gt; 赋值给顶点着色器的变量（片段着色器 从顶点着色器读取 ） ====&gt; 绘制那么我们的思路就是 在着色器上 使用 左侧的视频帧 为底 + 右侧视频帧 的R通道最为 A通道， 那么1234567891011121314151617181920212223242526272829303132333435 // 位置缓冲区（Position Buffer）初始化： // [具体看 裁剪空间] 中心是0，0，0 左侧 xyz 分别在 -1单位。 右侧 xyz 分别在 1 单位。都是向量单位 const positionVertice = new Float32Array([-1.0, 1.0, 1.0, 1.0, -1.0, -1.0, 1.0, -1.0 ]); const positionBuffer = gl.createBuffer(); // 创建buffer gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer); // 把缓冲区对象绑定到目标 gl.bufferData(gl.ARRAY_BUFFER, positionVertice, gl.STATIC_DRAW); // 向缓冲区对象写入刚定义的顶点数据 // 纹理缓冲区（Texture Buffer）初始化： const textureBuffer = gl.createBuffer(); /*** 定义纹理区域 ***/ // 这里将纹理 右侧 部分映射到整个画布上 给着色器 读取使用 const textureVertice = new Float32Array([ 0.0,1.0, // 左上角 0.5,1.0, // 右上角 0.0,0.0, // 左下角 0.5,0.0, // 右下角 ]); // 这部分根据 direction 选项（left 或 right）设置纹理坐标，用于将视频帧映射到矩形上。 gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer);// 片元着色器， gl_FragColor 即为每像素的颜色const vShader = ` precision lowp float; // 设置浮点数精度 varying vec2 v_texCoord; // 从顶点着色器接收的纹理坐标 uniform sampler2D u_sampler; // 纹理采样器 void main(void) &#123; // 设置像素颜色： // RGB 从当前纹理坐标采样 gl_FragColor = vec4(texture2D(u_sampler, v_texCoord).rgb, // Alpha 从偏移后的纹理坐标采样 R 通道 texture2D(u_sampler, v_texcoord+vec(0.5, 0)).r); &#125;`;‍如果 ，我们的资源 反过来呢？ 右侧的视频帧 为底 + 左侧视频帧 的R通道最为 A通道。 如何处理？对坐标转换下。1234567891011121314151617181920212223.... // 这里将纹理 右侧 部分映射到整个画布上 给着色器 读取使用 const textureVertice = new Float32Array([ 0.5, 1.0, 1.0, 1.0, 0.5, 0.0, 1.0, 0.0 ]);....// 片元着色器， gl_FragColor 即为每像素的颜色const vShader = ` precision lowp float; // 设置浮点数精度 varying vec2 v_texCoord; // 从顶点着色器接收的纹理坐标 uniform sampler2D u_sampler; // 纹理采样器 void main(void) &#123; // 设置像素颜色： // RGB 从当前纹理坐标采样 gl_FragColor = vec4(texture2D(u_sampler, v_texCoord).rgb, // Alpha 从偏移后的纹理坐标采样 R 通道 texture2D(u_sampler, v_texcoord+vec(-0.5, 0)).r); &#125;`;‍当然别忘了， canvas 在 高清屏幕 绘制模糊的问题，canvas-更正分辨率​ 当然要修正下。好上完整代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272// alpha-video-webgl.jsclass AlphaVideo &#123; constructor(option) &#123; const defaultOption = &#123; src: \"\", autoplay: true, loop: true, canvas: null, // 默认透明视频展示大小 width: 375, height: 300, // 动画视频 所在位置，left 左，right 右 direction: \"left\", onError: function () &#123;&#125;, onPlay: function () &#123;&#125;, &#125;; this.options = &#123; ...defaultOption, ...option, &#125;; this.radio = window.devicePixelRatio; this.directionOption = &#123; // 纹理坐标 left: &#123; // 纹理坐标 textureVertice: [ 0.0,1.0, // 左上角 0.5,1.0, // 右上角 0.0,0.0, // 左下角 0.5,0.0, // 右下角 ], // 纹理 偏移 fsSourceRadio: '0.5' &#125;, right: &#123; // 纹理坐标 textureVertice: [ 0.5, 1.0, 1.0, 1.0, 0.5, 0.0, 1.0, 0.0 ], // 纹理 偏移 fsSourceRadio: '-0.5' &#125; &#125;; this.initVideo(); this.initWebgl(); if (this.options.autoplay) &#123; this.video.play(); &#125; &#125; initVideo() &#123; const &#123; onPlay, onError, loop, src &#125; = this.options; const video = document.createElement(\"video\"); video.autoplay = false; video.mute = true; video.volume = 0; video.muted = true; video.loop = loop; video.setAttribute(\"x-webkit-airplay\", \"true\"); video.setAttribute(\"webkit-playsinline\", \"true\"); video.setAttribute(\"playsinline\", \"true\"); video.style.display = \"none\"; video.src = src; video.crossOrigin = \"anonymous\"; video.addEventListener(\"canplay\", () =&gt; &#123; this.playing = true; onPlay &amp;&amp; onPlay(); &#125;); video.addEventListener(\"error\", () =&gt; &#123; onError &amp;&amp; onError(); &#125;); video.addEventListener(\"play\", () =&gt; &#123; window.requestAnimationFrame(() =&gt; &#123; this.drawFrame(); &#125;); &#125;); document.body.appendChild(video); this.video = video; &#125; drawFrame() &#123; if (this.playing) &#123; this.drawWebglFrame(); &#125; window.requestAnimationFrame(() =&gt; &#123; this.drawFrame(); &#125;); &#125; drawWebglFrame() &#123; const gl = this.gl; // 配置纹理图像 gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, this.video ); // 绘制 gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4); &#125; play() &#123; this.playing = true; this.video.play(); &#125; pause() &#123; this.playing = false; this.video.pause(); &#125; initWebgl() &#123; // 设置 canvas 尺寸和点击事件 this.canvas = this.options.canvas; this.canvas.width = this.options.width * this.radio; this.canvas.height = this.options.height * this.radio; this.canvas.addEventListener(\"click\", () =&gt; &#123; this.play(); &#125;); if (!this.canvas) &#123; this.canvas = document.createElement(\"canvas\"); document.body.appendChild(this.canvas); &#125; const gl = this.canvas.getContext(\"webgl\"); // 设置视口大小 gl.viewport( 0,0, this.options.width * this.radio, this.options.height * this.radio ); // 着色器程序设置 const program = this._initShaderProgram(gl); gl.linkProgram(program); gl.useProgram(program); const buffer = this._initBuffer(gl); // 绑定缓冲 gl.bindBuffer(gl.ARRAY_BUFFER, buffer.position); // 顶点位置 a_position 读取 绑定缓冲区 const aPosition = gl.getAttribLocation(program, \"a_position\"); // 允许属性读取，将缓冲区的值分配给特定的属性 gl.enableVertexAttribArray(aPosition); gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0); gl.bindBuffer(gl.ARRAY_BUFFER, buffer.texture); const aTexCoord = gl.getAttribLocation(program, \"a_texCoord\"); gl.enableVertexAttribArray(aTexCoord); gl.vertexAttribPointer(aTexCoord, 2, gl.FLOAT, false, 0, 0); // 绑定纹理 const texture = this._initTexture(gl); gl.bindTexture(gl.TEXTURE_2D, texture); const scaleLocation = gl.getUniformLocation(program, \"u_scale\"); gl.uniform2fv(scaleLocation, [this.radio, this.radio]); this.gl = gl; &#125; // 根据类型创建着色器 _createShader(gl, type, source) &#123; const shader = gl.createShader(type); gl.shaderSource(shader, source); gl.compileShader(shader); if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) &#123; console.error(gl.getShaderInfoLog(shader)); &#125; return shader; &#125; _initShaderProgram(gl) &#123; // 顶点 着色器glsl代码 const vsSource = ` attribute vec2 a_position; // 接收顶点位置 attribute vec2 a_texCoord; // 接收纹理坐标 varying vec2 v_texCoord; // 传递给片段着色器的纹理坐标 uniform vec2 u_scale; // 缩放因子 void main(void) &#123; gl_Position = vec4(a_position, 0.0, 1.0); // 设置顶点位置 v_texCoord = a_texCoord; // 传递纹理坐标 &#125; `; // 片段 着色器 glsl 代码 const fsSource = ` precision lowp float; // 设置浮点数精度， 必须指明float的精度，因为计算过程中片段着色器的精度没有默认 varying vec2 v_texCoord; // 从顶点着色器接收的纹理坐标 uniform sampler2D u_sampler; // 纹理采样器 void main(void) &#123; // 设置像素颜色： // RGB 从当前纹理坐标采样 gl_FragColor = vec4(texture2D(u_sampler, v_texCoord).rgb, // Alpha 从偏移后的纹理坐标采样 R 通道 texture2D(u_sampler, v_texCoord+vec2($&#123;this.directionOption[ this.options.direction].fsSourceRadio&#125;, 0)).r); &#125; `; // 创建 顶点着色器 const vsShader = this._createShader(gl, gl.VERTEX_SHADER, vsSource); // 创建 片段着色器 const fsShader = this._createShader(gl, gl.FRAGMENT_SHADER, fsSource); // 创建 着色器程序 const program = gl.createProgram(); // 将 顶点着色器程序附着到webgl gl.attachShader(program, vsShader); // 将 片段 着色器程序附着到webgl gl.attachShader(program, fsShader); // 关联着色器程序到整个绘制对象中 gl.linkProgram(program); return program; &#125; _initBuffer(gl) &#123; // 位置缓冲区（Position Buffer）初始化： // 这部分定义了一个矩形的四个顶点坐标，范围在 -1 到 1 之间，这是 WebGL 的标准化设备坐标系（NDC）。 const positionVertice = new Float32Array([ -1.0, 1.0, 1.0, 1.0, -1.0, -1.0, 1.0, -1.0, ]); const positionBuffer = gl.createBuffer(); // 创建buffer gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer); // 把缓冲区对象绑定到目标 gl.bufferData(gl.ARRAY_BUFFER, positionVertice, gl.STATIC_DRAW); // 向缓冲区对象写入刚定义的顶点数据 // 纹理缓冲区（Texture Buffer）初始化： const textureBuffer = gl.createBuffer(); // 这里将纹理 部分映射到整个画布上 const textureVertice = new Float32Array(this.directionOption[ this.options.direction].textureVertice); // 这部分根据 direction 选项（left 或 right）设置纹理坐标，用于将视频帧映射到矩形上。 gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer); // gl.STATIC_DRAW 表示数据不会频繁更改，适合静态几何形状 gl.bufferData(gl.ARRAY_BUFFER, textureVertice, gl.STATIC_DRAW); // 位置和纹理坐标都使用 Float32Array 是因为 WebGL 需要类型化数组 // 返回的两个 buffer 会在后续的渲染过程中被使用 // 这段代码是实现透明视频效果的基础，通过合理设置纹理坐标来实现 alpha 通道的映射。 return &#123; position: positionBuffer, texture: textureBuffer, &#125;; &#125; _initTexture(gl) &#123; const texture = gl.createTexture(); gl.bindTexture(gl.TEXTURE_2D, texture); // 对纹理图像进行y轴反转，因为WebGL纹理坐标系统的t轴（分为t轴和s轴）的方向和图片的坐标系统Y轴方向相反。因此将Y轴进行反转。 gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1); // 配置纹理参数 gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE); return texture; &#125;&#125;‍调用测试下：1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;透明视频&lt;/title&gt; &lt;style&gt; .canvas &#123; width: 414px; height: 896px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body style=\"background-color: black;\"&gt; &lt;canvas class=\"canvas\" id=\"AlphaVideoCanvas\" width=\"414\" height=\"896\"&gt;&lt;/canvas&gt; &lt;script src=\"./alpha-video-webgl.js\" inline&gt;&lt;/script&gt; &lt;script&gt; // 动画视频 在左侧 const url_left = `https://s3.amazonaws.com/liveme.storage.test/liveglb/202004171204/gifts/resource_manage/f8d6b_md5_f71ec37a5350a219500fef89335c3be9_.mp4` // 动画视频 在右侧 const url_right = `https://dlied5sdk.myapp.com/music/release/upload/t_mm_file_publish/2868412.mp4`; this.headMv = new AlphaVideo(&#123; src: url_left, width: 414, height: 896 * 375/400, loop: true, // 是否循环播放 canvas: document.getElementById('AlphaVideoCanvas'), // direction: \"right\", // 动画视频的播放方向，left:原来视频在左侧 ；right: 原视频在右侧 &#125;); this.headMv.play(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"技术帖","slug":"技术帖","permalink":"http://mcdowell8023.github.io/categories/技术帖/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://mcdowell8023.github.io/tags/笔记/"},{"name":"直播","slug":"直播","permalink":"http://mcdowell8023.github.io/tags/直播/"},{"name":"动画","slug":"动画","permalink":"http://mcdowell8023.github.io/tags/动画/"}]},{"title":"JavaScript从头来5-拨开迷雾，从浏览器说起","slug":"JavaScript从头来5-拨开迷雾，从浏览器说起","date":"2020-08-27T11:58:53.000Z","updated":"2020-08-27T12:00:56.055Z","comments":true,"path":"2020/08/27/JavaScript从头来5-拨开迷雾，从浏览器说起/","link":"","permalink":"http://mcdowell8023.github.io/2020/08/27/JavaScript从头来5-拨开迷雾，从浏览器说起/","excerpt":"","text":"","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://mcdowell8023.github.io/categories/基础知识/"}],"tags":[{"name":"js基础","slug":"js基础","permalink":"http://mcdowell8023.github.io/tags/js基础/"},{"name":"追本溯源","slug":"追本溯源","permalink":"http://mcdowell8023.github.io/tags/追本溯源/"},{"name":"笔记","slug":"笔记","permalink":"http://mcdowell8023.github.io/tags/笔记/"}]},{"title":"JavaScript从头来4-基石作用域和闭包","slug":"JavaScript从头来4-基石作用域和闭包","date":"2020-08-27T11:56:26.000Z","updated":"2020-08-27T12:00:49.073Z","comments":true,"path":"2020/08/27/JavaScript从头来4-基石作用域和闭包/","link":"","permalink":"http://mcdowell8023.github.io/2020/08/27/JavaScript从头来4-基石作用域和闭包/","excerpt":"","text":"","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://mcdowell8023.github.io/categories/基础知识/"}],"tags":[{"name":"js基础","slug":"js基础","permalink":"http://mcdowell8023.github.io/tags/js基础/"},{"name":"追本溯源","slug":"追本溯源","permalink":"http://mcdowell8023.github.io/tags/追本溯源/"},{"name":"笔记","slug":"笔记","permalink":"http://mcdowell8023.github.io/tags/笔记/"}]},{"title":"JavaScript从头来3-面向对象","slug":"JavaScript从头来3-面向对象","date":"2020-08-27T11:54:41.000Z","updated":"2020-08-27T12:00:43.390Z","comments":true,"path":"2020/08/27/JavaScript从头来3-面向对象/","link":"","permalink":"http://mcdowell8023.github.io/2020/08/27/JavaScript从头来3-面向对象/","excerpt":"","text":"","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://mcdowell8023.github.io/categories/基础知识/"}],"tags":[{"name":"js基础","slug":"js基础","permalink":"http://mcdowell8023.github.io/tags/js基础/"},{"name":"追本溯源","slug":"追本溯源","permalink":"http://mcdowell8023.github.io/tags/追本溯源/"},{"name":"笔记","slug":"笔记","permalink":"http://mcdowell8023.github.io/tags/笔记/"}]},{"title":"JavaScript从头来2.3-其他引用类型","slug":"JavaScript从头来2.3-其他引用类型","date":"2020-08-27T11:53:21.000Z","updated":"2020-08-27T12:00:38.547Z","comments":true,"path":"2020/08/27/JavaScript从头来2.3-其他引用类型/","link":"","permalink":"http://mcdowell8023.github.io/2020/08/27/JavaScript从头来2.3-其他引用类型/","excerpt":"","text":"","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://mcdowell8023.github.io/categories/基础知识/"}],"tags":[{"name":"js基础","slug":"js基础","permalink":"http://mcdowell8023.github.io/tags/js基础/"},{"name":"追本溯源","slug":"追本溯源","permalink":"http://mcdowell8023.github.io/tags/追本溯源/"},{"name":"笔记","slug":"笔记","permalink":"http://mcdowell8023.github.io/tags/笔记/"}]},{"title":"JavaScript从头来2.2-对象","slug":"JavaScript从头来2.2-对象","date":"2020-08-27T11:52:35.000Z","updated":"2020-10-22T11:47:16.393Z","comments":true,"path":"2020/08/27/JavaScript从头来2.2-对象/","link":"","permalink":"http://mcdowell8023.github.io/2020/08/27/JavaScript从头来2.2-对象/","excerpt":"","text":"javascript 中 万物皆对象。对象只是带有属性和方法的特殊数据类型对象只是一种特殊的数据。对象拥有属性和方法js 中的引用类型都派生自 对象（Object），如 Array Function Math 等等包括 常见的 基本类型(值类型) string 、 number 的值 均为对应的 String 、 Number 调用 valueOf 或者 toString 得到的可见，对象在 javascript 中的地位。 在 javascript 的世界里，对象就是属性的集合 对象从形式上来定义 JavaScript 的对象，是一种属性的集合。【 属性值可以是 函数（function）】 创建对象使用 对象字面量 创建对象1234567var person = &#123; name: 'mcdowell', age: 29,&#125;person.sayName = function () &#123; alert(this.name)&#125;使用{}创建对象，等同于 new Object();使用 new 借助 Object 函数 创建对象123456var person = new Object()person.name = 'mcdowell'person.age = 29person.sayName = function () &#123; alert(this.name)&#125;问题：1.代码冗余； 2.对象中的方法不能共享，每个对象中的方法都是独立的使用 工厂模式 创建对象12345678910111213141516171819function createPerson(name, age) &#123; var person = new Object() person.name = name person.age = age person.sayName = function () &#123; alert(this.name) &#125; return person&#125;var p1 = createPerson('mcdowell', 29)var p2 = createPerson('bart', 31)console.log(p1, 'p1,p2', p2)console.log(p1.constructor === p2.constructor) //trueconsole.log(p1.constructor === createPerson) //falseconsole.log(p1 instanceof Object) //trueconsole.log(p2 instanceof Object) //trueconsole.log(p1.sayName === p2.sayName) //false工厂函数每执行一次，都会创建一个对象。每个创建的 对象都拥有各自独立的方法和属性。对象的 constructor 构造函数共同指向 Object 方法优点：避免部分代码重复，减少冗余缺点：每个对象 调用的还是不同的方法 ( 方法没有实现复用 )通过构造函数创建对象1234567891011121314151617function Person(name, age) &#123; this.name = name this.age = age this.sayName = function () &#123; alert(this.name) &#125;&#125;var p1 = new Person('mcdowell', 29)var p2 = new Person('bart', 31)//console.log(p1, 'p1,p2', p2)console.log(p1.constructor === p2.constructor) //trueconsole.log(p1.constructor === Person) //trueconsole.log(p1 instanceof Object) //trueconsole.log(p2 instanceof Object) //trueconsole.log(p1.sayName === p2.sayName) //false每 new 一次 构造函数，都会创建一个对象每个创建的 对象都拥有各自独立的方法和属性。对象的 constructor 构造函数共同指向 Person 方法优点：进一步优化，避免部分代码重复，减少冗余缺点：每个对象 调用的还是不同的方法 ( 方法没有实现复用 )通过 原型模式 创建对象1234567891011121314151617function Person() &#123;&#125;Person.prototype.name = 'person'Person.prototype.sayName = function () &#123; console.log(this.name, 'name')&#125;var p1 = new Person()var p2 = new Person()p1.sayName()console.log(p1.sayName === p2.sayName) // trueconsole.log(Person.prototype.constructor) // function Person()&#123;&#125;console.log(Person.prototype.constructor == Person) // trueconsole.log(p1.__proto__ === p2.__proto__) // true每 new 一次 构造函数，都会创建一个对象每个创建的 对象都 都通过 proto 指向 Person.prototype 对象，从而实现 属性方法共享。对象的 constructor 构造函数共同指向 Person 方法优点： 真正意义实现了复用缺点： 各对象 也需要自己特有属性 方法通过 原型模式 + 构造函数 创建对象123456789101112131415161718function createPerson(name, age) &#123; this.name = name this.age = age&#125;createPerson.protoType.sayName = function () &#123; alert(this.name)&#125;；var p1 = new createPerson('mcdowell', 29)var p2 = new createPerson('bart', 31)//console.log(p1, 'p1,p2', p2)console.log(p1.constructor === p2.constructor) //trueconsole.log(p1.constructor === createPerson) //trueconsole.log(p1 instanceof Object) //trueconsole.log(p2 instanceof Object) //trueconsole.log(p1.sayName === p2.sayName) //false优点：每个对象 都会有自己的一份 属性的副本，但又同时共享着对方法的引用，最大限度地节省了内存。继承：需要复用的放在 protoType 属性指向的对象下 ，通过 原型链 的方式 实现复用多态：不同对象 的特殊属性（多态） 借助构造函数完成通过 Object.create 创建对象语法：Object.create(proto, [propertiesObject])proto:必须。表示新建对象的原型对象，即该参数会被赋值到目标对象(即新对象，或说是最后返回的对象)的原型上。该参数可以是 null、对象、函数的 prototype 属性可选。 添加到新创建对象的可枚举属性（即其自身的属性，而不是原型链上的枚举属性）对象的属性描述符以及相应的属性名称。这些属性对应 Object.defineProperties 的第二个参数。123456789101112131415161718192021var object = Object.create(null) // &#123;&#125; 创建了一个空对象// 创建一个人// 自带 头发，皮肤 属性// 人类 类型无法改变// 用第二个参数创建非空对象的属性描述符默认是为false的，// 不可写,不可枚举,不可配置var p1 = Object.create( &#123; hair: 'black', skin: 'yellow' &#125;, &#123; type: &#123; value: 'person', writable: false, enumerable: false, configurable: false, &#125;, &#125;)// 给上名字 和 年龄p1.name = 'mcdowell'p1.age = '20'console.log(p1)与 new Object 创建方式不同；new Object 创建的对象 原型 指向的原型对象一直都存在Object.create(null) 创建的对象 为真正意义上的空对象，原型 为 undefinedObject.create 直接以 传入对象 作为 原型 进行创建的Object.create 创建的对象 的 constructor 与 new Object 创建的对象 的 constructor 都指向 Object 构造函数通过 class 创建对象类 不会像函数一样 去进行变量提升123456789101112131415161718192021222324252627282930313233343536// 父类class Person &#123; // 公有属性 type = 'human' // 私有属性，外部无法访问（会报错） // 读取私有属性的方法 this.#study #study = 'true' constructor(name, age) &#123; // constructor 上来就执行，相当于 构造函数 本身属性 this.name = name this.age = age &#125; // 定义静态 属性 同 静态方法，无法在实例中 读取，仅在 构造函数 属性说明 static description = 'person' // static 关键字用来定义一个类的一个静态方法。 // 调用静态方法不需要实例化该类，但不能通过一个类实例调用静态方法。 // 静态方法通常用于为一个应用程序创建工具函数。 static create(name, age) &#123; var person = new Person(name, age) console.log('创建了一个人', person) return person &#125; // 相当于 构造函数 的 原型对象 中 进行声明 函数方法 sayName() &#123; console.log('说出自己的名字：', this.name) &#125; speak() &#123; console.log('介绍自己：', this, '私有属性 #study', this.#study) &#125;&#125;// 直接访问 外侧静态属性console.log('输出静态属性description：', Person.description)var p1 = Person.create('mcdowell', 20)p1.sayName()p1.speak() extends 继承继承 class12345678910111213141516// 子类class Man extends Person &#123; constructor(...props) &#123; // 调用超类构造函数并传入参数 // 如果子类中定义了构造函数，那么它必须先调用 super() 才能使用 this super(...props) this.sex = 'man' &#125; sayName() &#123; console.log('我叫', this.name, '我是个男的') &#125;&#125;var man = new Man('bart', 22)man.sayName()man.speak()继承 传统 函数类1234567891011121314151617function Animal() &#123; this.name = name&#125;Animal.prototype.speak = function () &#123; console.log(this.name + ' 发出声音')&#125;class Dog extends Animal &#123; speak() &#123; // 使用 super 关键字 调用 对象的父对象上的函数 super.speak() console.log(this.name + ' 汪汪叫') &#125;&#125;var dog = new Dog('阿福')dog.speak()类不能继承常规对象（不可构造的）12345678910111213141516var Animal = &#123; speak: function () &#123; console.log(this.name + ' 发出声音') &#125;,&#125;class Dog &#123; constructor(name) &#123; this.name = name &#125;&#125;// 通过 Object.setPrototypeOf 继承常规对象Object.setPrototypeOf(Dog.prototype, Animal)var dog = new Dog('阿福')dog.speak()首先，我肯定是需要你告诉我，什么是面向对象，面向对象有哪些特点，以及这些特点的解释。JavaScript 如何实现这些特点，比如封装、继承、多态。如果关于上述三点，你能够解释到有多少种实现方式、优缺点是什么。以及近几年流行的解决方案是什么。这就是加分 ，比如对于继承吧。类式继承、构造函数继承、组合继承、原型继承、寄生组合继承等等，说出大概的实现思路和优缺点，再介绍下 extends 或者 mixin 的实现甚至你可以衍生到 JavaScript 的模块化发展甚至到为什么现在 TS 如此流行。那么可以说到这一环节解答的就非常棒了。回答完 JavaScript 的面向对象，是不是可以从此衍生下为什么需要面向对象。以及当先对于软件设计的高内聚、低耦合的思考？来个对此题一个提纲挈领的总结？","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://mcdowell8023.github.io/categories/基础知识/"}],"tags":[{"name":"js基础","slug":"js基础","permalink":"http://mcdowell8023.github.io/tags/js基础/"},{"name":"追本溯源","slug":"追本溯源","permalink":"http://mcdowell8023.github.io/tags/追本溯源/"},{"name":"笔记","slug":"笔记","permalink":"http://mcdowell8023.github.io/tags/笔记/"}]},{"title":"透视http协议笔记2-基础概念","slug":"透视http协议笔记2-基础概念","date":"2020-05-25T01:38:07.000Z","updated":"2020-05-25T21:59:52.221Z","comments":true,"path":"2020/05/25/透视http协议笔记2-基础概念/","link":"","permalink":"http://mcdowell8023.github.io/2020/05/25/透视http协议笔记2-基础概念/","excerpt":"","text":"HTTP 是什么HyperText Transfer Protocol, 超文本传输协议 超文本传输协议 超文本“超文本”，就是“超越了普通文本的文本”，包含文字、图片、音频和视频等的混合体最关键的是含有“超链接”，能够从一个“超文本”跳跃到另一个“超文本”，形成复杂的非线性、网状的结构关系。 传输是一个“双向协议”数据虽然是在 A 和 B 之间传输，但并没有限制只有 A 和 B 这两个角色，允许中间有“中转”或者“接力”HTTP 是一个在计算机世界里专门用来在两点之间传输数据的约定和规范。 协议两个或多个参与者是对参与者的一种行为约定和规范HTTP 是一个用在计算机世界里的协议。它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范，以及相关的各种控制和错误处理方式。 总结下来 具体说HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范. HTTP 不是什么 HTTP 不是互联网HTTP 是构建互联网的一块重要拼图，而且是占比最大的那一块。但是构建互联网还包含其他，超文本资源使用 HTTP，普通文件使用 FTP，电子邮件使用 SMTP 和 POP3 等。使用浏览器访问的 是万维网（www）,只是互联网的一部分 HTTP 不是编程语言编程语言是人与计算机沟通交流所使用的语言，而HTTP 是计算机与计算机沟通交流的语言，是要通过 编程语言实现 http 进行与其他计算机通信的。HTTP 和 HTML 不可混为一谈HTML 是超文本的载体，是一种标记语言，使用各种标签描述文字、图片、超链接等资源，并且可以嵌入 CSS、JavaScript 等技术实现复杂的动态效果。虽然通常，我们使用 http 传输 html 但是，http 还可以传输其他文本、文件。 HTTP 不是一个孤立的协议HTTP 通常跑在 TCP/IP 协议栈之上：依靠 IP 协议实现寻址和路由、TCP 协议实现可靠数据传输、DNS 协议实现域名查找、SSL/TLS 协议实现安全通信。还有一些协议依赖于 HTTP，例如 WebSocket、HTTPDNS 等。这些协议相互交织，构成了一个协议网，而 HTTP 则处于中心地位。 与 HTTP 相关的各种概念互联网的正式名称是 Internet，里面存储着无穷无尽的信息资源，我们通常所说的“上网”实际上访问的只是互联网的一个子集“万维网”（World Wide Web），它基于 HTTP 协议，传输 HTML 等超文本资源，能力也就被限制在 HTTP 协议之内。互联网上还有许多万维网之外的资源，例如常用的电子邮件、BT 和 Magnet 点对点下载、FTP 文件下载、SSH 安全登录、各种即时通信服务等等，它们需要用各自的专有协议来访问。 浏览器浏览器的正式名字叫“Web Browser”，顾名思义，就是检索、查看互联网上网页资源的应用程序，名字里的 Web，实际上指的就是“World Wide Web”，也就是万维网。浏览器本质上是一个 HTTP 协议中的请求方，使用 HTTP 协议获取网络上的各种资源。在 HTTP 协议里，浏览器的角色被称为“User Agent”即“用户代理”，意思是作为访问者的“代理”来发起 HTTP 请求。不过在不引起混淆的情况下，我们通常都简单地称之为“客户端”。 Web 服务器服务器，Web Server。服务器是一个很大也很重要的概念，它是 HTTP 协议里响应请求的主体，通常也把控着绝大多数的网络资源，在网络世界里处于强势地位。硬件含义就是物理形式或“云”形式的机器，在大多数情况下它可能不是一台服务器，而是利用反向代理、负载均衡等技术组成的庞大集群。软件提供 Web 服务的应用程序，通常会运行在硬件含义的服务器上。它利用强大的硬件能力响应海量的客户端 HTTP 请求，处理磁盘上的网页、图片等静态文件，或者把请求转发给后面的 Tomcat、Node.js 等业务应用，返回动态的信息Apache 是老牌的服务器，到今天已经快 25 年了，功能相当完善，相关的资料很多，学习门槛低，是许多创业者建站的入门产品。Nginx 是 Web 服务器里的后起之秀，特点是高性能、高稳定，且易于扩展。在高流量的网站里更是不二之选。此外，还有 Windows 上的 IIS、Java 的 Jetty/Tomcat 等，因为性能不是很高，所以在互联网上应用得较少。 CDN [ 负载均衡，就近访问 ]CDN，全称是“Content Delivery Network”，翻译过来就是“内容分发网络”。它应用了 HTTP 协议里的缓存和代理技术，代替源站响应客户端的请求。它可以缓存源站的数据，让浏览器的请求不用“千里迢迢”地到达源站服务器，直接在“半路”就可以获取响应。如果 CDN 的调度算法很优秀，更可以找到离用户最近的节点，大幅度缩短响应时间。CDN 也是现在互联网中的一项重要基础设施，除了基本的网络加速外，还提供负载均衡、安全防护、边缘计算、跨运营商网络等功能，能够成倍地“放大”源站服务器的服务能力 爬虫是一种可以自动访问 Web 资源的应用程序。它们就像是一只只不知疲倦的、辛勤的蚂蚁，在无边无际的网络上爬来爬去，不停地在网站间奔走，搜集抓取各种信息，故而 成为爬虫。绝大多数是由各大搜索引擎“放”出来的，抓取网页存入庞大的数据库，再建立关键字索引，这样我们才能够在搜索引擎中快速地搜索到互联网角落里的页面。爬虫也有不好的一面，它会过度消耗网络资源，占用服务器和带宽，影响网站对真实数据的分析，甚至导致敏感信息泄漏。所以，又出现了“反爬虫”技术，通过各种手段来限制爬虫。其中一项就是“君子协定”robots.txt，约定哪些该爬，哪些不该爬。无论是“爬虫”还是“反爬虫”，用到的基本技术都是两个，一个是 HTTP，另一个就是 HTML图形验证码等，也是一种反爬虫手段。linux 上的 wget、curl 等命令行工具也是基于 http，也是一种 user agent","categories":[{"name":"基础","slug":"基础","permalink":"http://mcdowell8023.github.io/categories/基础/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://mcdowell8023.github.io/tags/笔记/"},{"name":"http","slug":"http","permalink":"http://mcdowell8023.github.io/tags/http/"}]},{"title":"透视http协议笔记1-HTTP 的前世今生","slug":"透视http协议笔记1-HTTP 的前世今生","date":"2020-05-22T00:25:58.000Z","updated":"2020-05-25T01:36:46.637Z","comments":true,"path":"2020/05/22/透视http协议笔记1-HTTP 的前世今生/","link":"","permalink":"http://mcdowell8023.github.io/2020/05/22/透视http协议笔记1-HTTP 的前世今生/","excerpt":"","text":"HTTP 的前世今生 史前20 世纪 60 年代，美国国防部高等研究计划署（ARPA）建立了 ARPA 网，它有四个分布在各地的节点，被认为是如今互联网的“始祖”。在 70 年代，基于对 ARPA 网的实践和思考，研究人员发明出了著名的 TCP/IP 协议。由于具有良好的分层结构和稳定的性能，TCP/IP 协议迅速战胜其他竞争对手流行起来，并在 80 年代中期进入了 UNIX 系统内核，促使更多的计算机接入了互联网。 创世纪 - 19891989 年，任职于欧洲核子研究中心（CERN）的蒂姆·伯纳斯 - 李发表了一篇论文，提出了在互联网上构建超链接文档系统，把这个系统称为“万维网”（World Wide Web），也就是我们现在所熟知的 Web。URI：即统一资源标识符，作为互联网上资源的唯一身份；HTML：即超文本标记语言，描述超文本文档；HTTP：即超文本传输协议，用来传输超文本。 HTTP/0.9 - 20 世纪 90 年代结构比较简单，采用了纯文本格式 【20 世纪 90 年代初期，计算机处理能力低，存储容量小，网速很慢，为了便于服务器和客户端处理】只允许用“GET”动作从服务器上获取 HTML 文档【最初设想的系统里的文档都是只读的】响应请求之后立即关闭连接 HTTP/1.0 - 19961996 年正式发布 HTTP/1.0,然而不是一个“标准”，只是记录已有实践和模式的一份参考文档，不具有实际的约束力，相当于一个“备忘录”增加了 HEAD、POST 等新方法；增加了响应状态码，标记可能的错误原因；引入了协议版本号概念；引入了 HTTP Header（头部）的概念，让 HTTP 处理请求和响应更加灵活；传输的数据不再仅限于文本1993 年，NCSA（美国国家超级计算应用中心）开发出了 Mosaic，是第一个可以图文混排的浏览器，随后又在 1995 年开发出了服务器软件 Apache，简化了 HTTP 服务器的搭建工作。同一时期，计算机多媒体技术也有了新的发展：1992 年发明了 JPEG 图像格式，1995 年发明了 MP3 音乐格式。 从用户需求的角度促进了 HTTP 的发展。 HTTP/1.1 - 1999得益于 1995 年，网景和微软开始的“浏览器大战” 推动了 Web 的发展，HTTP/1.0 经受了实践检验。“浏览器大战”结束之后的 1999 年，HTTP/1.1 发布了 RFC 文档，编号为 2616，正式确立了延续十余年的传奇。它是一个“正式的标准”，所有的浏览器、服务器、网关、代理等等，只要用到 HTTP 协议，就必须严格遵守这个标准，相当于是互联网世界的一个“立法”增加了 PUT、DELETE 等新的方法；增加了缓存管理和控制；明确了连接管理，允许持久连接；允许响应数据分块（chunked），利于传输大文件；强制要求 Host 头，让互联网主机托管成为可能 HTTP/2 - 2015HTTP/1.1 发布之后，整个互联网世界呈现出了爆发式的增长，度过了十多年，对于 HTTP 出现了不满的意见：主要就是连接慢，但 HTTP/1.1 标准一直“岿然不动”，无奈之下人们只好发明各式各样的“小花招”来缓解这些问题，比如以前常见的切图、JS 合并等网页优化手段。搜索巨头 Google 忍不住了，决定“揭竿而起”。首先开发了自己的浏览器 Chrome，然后推出了新的 SPDY 协议（2009 年，基于 TCP ），并在 Chrome 里应用于自家的服务器，这也开启了第二次的“浏览器大战”，Chrome 目前的全球的占有率超过了 60%。Google 借此顺势把 SPDY 推上了标准的宝座，互联网标准化组织以 SPDY 为基础开始制定新版本的 HTTP 协议，最终在 2015 年发布了 HTTP/2，RFC 编号 7540。HTTP/2 的制定充分考虑了现今互联网的现状：宽带、移动、不安全，在高度兼容 HTTP/1.1 的同时改善性能二进制协议，不再是纯文本；可发起多个请求，废弃了 1.1 里的管道；使用专用算法压缩头部，减少数据传输量；允许服务器主动向客户端推送数据；增强了安全性，“事实上”要求加密通信。HTTP/2 到今天已经四岁，也衍生出了 gRPC 等新协议，但由于 HTTP/1.1 实在是太过经典和强势，目前它的普及率还比较低，大多数网站使用的仍然还是 20 年前的 HTTP/1.1 HTTP/3 - 2018无论 SPDY 还是 HTTP/2，都是基于 TCP 的，TCP 与 UDP 相比效率上存在天然的劣势这次，还是 Google，而且它要“革自己的命”。在 HTTP/2 还处于草案之时，2013 年 Google 开发了基于 UDP 的名为 QUIC 的传输层协议，QUIC 全称 Quick UDP Internet Connections，希望它能替代 TCP，使得网页传输更加高效。2018 年，互联网标准化组织 IETF 提议将“HTTP over QUIC”更名为“HTTP/3”并获得批准，HTTP/3 正式进入了标准化制订阶段，也许两三年后就会正式发布，到时候我们很可能会跳过 HTTP/2 直接进入 HTTP/3。HTTP/3 原理与实践 总结HTTP 协议始于三十年前蒂姆·伯纳斯 - 李的一篇论文；HTTP/0.9 是个简单的文本协议，只能获取文本资源；HTTP/1.0 确立了大部分现在使用的技术，但它不是正式标准；HTTP/1.1 是目前互联网上使用最广泛的协议，功能也非常完善；HTTP/2 基于 Google 的 SPDY 协议，注重性能改善，但还未普及；HTTP/3 基于 Google 的 QUIC 协议，是将来的发展方向。","categories":[{"name":"基础","slug":"基础","permalink":"http://mcdowell8023.github.io/categories/基础/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://mcdowell8023.github.io/tags/笔记/"},{"name":"http","slug":"http","permalink":"http://mcdowell8023.github.io/tags/http/"}]},{"title":"web移动端调试笔记","slug":"web移动端调试笔记","date":"2020-04-22T08:26:08.000Z","updated":"2020-04-23T02:11:22.410Z","comments":true,"path":"2020/04/22/web移动端调试笔记/","link":"","permalink":"http://mcdowell8023.github.io/2020/04/22/web移动端调试笔记/","excerpt":"","text":"常见的几种调试方式Chrome Develop Tool 调试 ：无须额外的成本，方便快捷。但是，真机器和模拟还是不一样的(vConsole 调试)[https://github.com/Tencent/vConsole],使用简单，方便，就是 UI 界面，和 websock 问题，很头疼苹果调试套装 ：IOS Safari + Mac OS Safari 配合调试 （以下重点说明）安卓调试套装 ：Android Chrome + 桌面 Chrome 配合调试（以下重点说明） IOS Safari + Mac OS Safari 配合调试 设置手机设置: 设置 -&gt; Safari -&gt; 高级 -&gt; Web 检查器mac 电脑 设置： Safari 启用开发菜单：选择偏好设置 -&gt; 高级 -&gt; 在菜单栏中显示’开发’菜单命令 调试设备与计算机通过数据线连接,手机打开要调试的页面在 Safari 菜单：开发 -&gt; iphone-&gt; 要调试的页面可以愉快调试了 Android Chrome + 桌面 Chrome 配合调试手机端：开启开发者 -&gt; usb 调试, 用数据线连接至电脑【 你也可以通过 adb 无线调试方式进行连接 】手机端：安装装谷歌浏览器，并打开打开控制台，更多 -&gt; More tools -&gt; Remote devices 【 直接 地址栏 输入 Chrome://inspect 】最早在谷歌 75 时候，我是可以直接见到 调试控制 DevTools 页面，更显版本后发现有些不一样。谷歌版本&gt;= 81 你可能会碰到，Remote devices 栏中显示 如下： 12345This panel has been deprecated in favor of the chrome://inspect/#devices interface,which has equivalent functionality/* 直译： 此面板已被弃用，取而代之的是 chrome://inspect/#devices 接口，它具有同等的功能*/ 此时我们可以直接地址栏 输入 `chrome://inspect/#devices` 直接进入 DevTools 页面 找到 RemoteTarget 下 调试设备名称下面，输入 url 地址 open 后（会见到手机打开对应页面），下面会显示对应手机浏览器页签，点击 inspect正常情况下你会见到弹窗 显示手机页面和控制台，就可以进行调试了当地 5 步 出现弹窗，你有可能 会碰到 404 或者白页面。别急，打开你的 翻墙，或是 下载离线包具体看这里 Android 通过 Chrome Inspect 调试 WebView 的 H5 App 出现空白页面的解决方法（不需要 FQ） 关于无线连接方式ADB 无线模式调试 具体可以看我的文章 使用 scrcpy 连接安卓手机进行投屏演示 里的无线连接打开开发者模式，插线，保证同一网络插上 USB 线，开启 USB 连接，adb usb检查插上的设备，adb devices开启手机服务： adb tcpip 5555（PS：5555 是端口号，可以随意地指定）拔掉数据线，关于手机 找手机 ip 地址 adb connect 10.0.1.50:5555 [端口可以缺省，需要与 4 一致，默认 5555] # 返回 connected to 10.0.1.50 就表示成功","categories":[{"name":"工具","slug":"工具","permalink":"http://mcdowell8023.github.io/categories/工具/"}],"tags":[{"name":"调试","slug":"调试","permalink":"http://mcdowell8023.github.io/tags/调试/"},{"name":"web移动端","slug":"web移动端","permalink":"http://mcdowell8023.github.io/tags/web移动端/"}]},{"title":"zshell--从不小心切换开始","slug":"zshell-从不小心切换开始","date":"2020-04-22T03:48:55.000Z","updated":"2020-04-22T08:27:01.478Z","comments":true,"path":"2020/04/22/zshell-从不小心切换开始/","link":"","permalink":"http://mcdowell8023.github.io/2020/04/22/zshell-从不小心切换开始/","excerpt":"","text":"每次在 mac 中 打开 iTerm, 提示：123The default interactive shell is now zsh.To update your account to use zsh, please run `chsh -s /bin/zsh`.For more details, please visit https://support.apple.com/kb/HT208050.手贱，执行了chsh -s /bin/zsh【其实我都不知道 zeshell 是啥 🤦‍♂️】然后 adb connect 设备的 时候，adb 找不到了！！！🤦‍♂️🤦‍♂️🤦‍♂️查了一圈，终于有了了解，记录下。 关于 shellShell 是 Linux/Unix 的一个外壳，你理解成衣服也行。它负责外界与 Linux 内核的交互，接收用户或其他应用程序的命令，然后把这些命令转化成内核能理解的语言，传给内核，内核是真正干活的，干完之后再把结果返回用户或应用程序。那么关于切换 shell12345678# 查看 电脑几种 shellcat /etc/shells# 切换 shell# 切换成 Zshellchsh -s /bin/zsh# 切换成 bashchsh -s /bin/bash 回到最初问题仔细想来，其实就是环境变量问题，上面之所以提示找不到，无非 是 zshell 的环境变量没有配置 adb 需要去配置其实到这里，我仅仅为了使用 adb 切换回去 继续使用 bash 就好，但是： 好奇啊，那么继续 关于 ZshellShell 是在程序员与服务器间建立一个桥梁，它对外提供一系列命令，让我们得以控制服务器。常用的 Bash 就是 Shell 的一种，也是 Linux 下默认 Shell 程序。Zsh 属于 Shell 中的一种，但比 Bash 好用，而且完全兼容 Bash，拥有及其丰富的插件、强大的自动补全能力、以及自定义功能、代码高亮，可以大大提供我们使用 Linux 的效率。因为 Z 是最后一个字母，因此大家称之为——终极 Shell。 安装 Zshmac 跳过， 【系统已经默认安装好了】Redhat Linux，执行：sudo yum install zshUbuntu Linux，执行：sudo apt-get install zshwindows , 洗洗睡吧 👋 安装 on-my-zshZsh 虽然好用，但直接用起来比较麻烦，这就是为啥初期用的人少，后台有个大神，把 Zsh 的配置弄得相当简单 ：(ohmyzsh)[https://github.com/robbyrussell/oh-my-zsh]; 我们就借助 on-my-zsh 进行配置。 自动安装1wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O - | sh 手动安装克隆项目 git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh创建.zshrc 配置文件 cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc切换 zsh chsh -s /bin/zsh (如果你还没有切换的话)查看 zsh 版本 zsh --version有人说 还 需要 更新配置 source ~/.zshrc ,但是我实际是从新打开 iTerm 就看到 shell 的变化了，代码高亮… 配置 主题.zshrc 配置文件 中 默认主题 是 robbyrussell1ZSH_THEME=\"robbyrussell\" # 更换主题名称即可更多主题 插件.zshrc 配置文件 中 plugins=(git) 即时配置插件位置【默认支持 git】如果 mac 为例 增加 autojump安装 brew install autojump配置 增加12plugins=(git autojump)[[ -s ~/.autojump/etc/profile.d/autojump.sh ]] &amp;&amp; . ~/.autojump/etc/profile.d/autojump.sh关于 autojump，他是快捷跳转 你历史目录。比如， 先 cd /projcet/lanjiang/dist ,才可以 j lanjiang 更多作为一个 前端程序员 ，显然没有运维和服务端人员 shell 玩的溜。能了解的有限可以戳终极 Shell——ZSH zshell 配置 adb说会最开始碰到的问题，修正 zshell 环境变量其实 ，打开 bash 的配置 .bash_profile 对照添加到 .zshrc，然后重启就是了。我的配置。12345678910# 用户配置export ANDROID_HOME=$HOME/Library/Android/sdkexport PATH=$PATH:$ANDROID_HOME/toolsexport PATH=$PATH:$ANDROID_HOME/tools/binexport PATH=$PATH:$ANDROID_HOME/platform-toolsexport PATH=$PATH:$ANDROID_HOME/emulatorexport NVM_DIR=\"/Users/mcdowell/.nvm\"[ -s \"$NVM_DIR/nvm.sh\" ] &amp;&amp; \\. \"$NVM_DIR/nvm.sh\" # This loads nvm重启 iTerm adb version ,不会在报找不到 adb 了 为啥重启，不用 source .zshrc每次 zsh 启动都会读取这个 .zshrc 配置文件，所以我们可以把环境变量的配置信息放到这个配置文件中，这样每次启动 zsh 的时候，就会执行一次环境变量配置信息。而 bash 修改 配置环境变量后， 必须 倒入环境变量配置文件source .bash_profile 才可以生效。zsh 与 bash 设置环境变量的不同点","categories":[{"name":"工具","slug":"工具","permalink":"http://mcdowell8023.github.io/categories/工具/"}],"tags":[{"name":"zsh","slug":"zsh","permalink":"http://mcdowell8023.github.io/tags/zsh/"},{"name":"bash","slug":"bash","permalink":"http://mcdowell8023.github.io/tags/bash/"},{"name":"adb","slug":"adb","permalink":"http://mcdowell8023.github.io/tags/adb/"}]},{"title":"使用scrcpy连接安卓手机进行投屏演示","slug":"使用scrcpy连接安卓手机进行投屏演示","date":"2020-04-01T07:40:35.000Z","updated":"2020-05-07T03:00:14.640Z","comments":true,"path":"2020/04/01/使用scrcpy连接安卓手机进行投屏演示/","link":"","permalink":"http://mcdowell8023.github.io/2020/04/01/使用scrcpy连接安卓手机进行投屏演示/","excerpt":"","text":"需要演示？手机投屏到电脑上？快快使用 scrcpy 远程显示/控制 Android 手机scrcpy-github 安装要求 Android 5.0 以上，电脑安装 adb，手机启用 adb 调试，开发者模式 windowsscrcpy-win64-v1.12.1.zip macOS12brew install scrcpybrew cask install android-platform-tools # 如果 有了adb 不需要安装 使用github scrcpy mac 启动12345# 启动scrcpy# 帮助scrcpy --help windows 启动1234# 先进到对应目录cd /d d:scrcpy-win64adb connect 172.16.4.37:5555:11330scrcpy.exe -s 10.0.1.158:5555 -m 720 使用 USB 线连接在手机上启用 USB 调试adb devices 此时可以看到自己的设备。scrcpy 即可看到 手机屏幕投射到 电脑control + c 退出无法看到自己设备时，查看手机 USB 调试是否打开；PC 端是否安装手机驱动。 windos需要先进入 使用无线 WiFi 连接 ADB 无线模式调试打开开发者模式，插线，保证同一网络插上 USB 线，开启 USB 连接，adb usb检查插上的设备，adb devices开启手机服务： adb tcpip 5555（PS：5555 是端口号，可以随意地指定）拔掉数据线，关于手机 找手机 ip 地址adb connect 10.0.1.50:5555 [端口可以缺省，需要与 4 一致，默认 5555] # 返回 connected to 10.0.1.50 就表示成功scrcpy -s 10.0.1.50:5555 -m 720 # 启动 10.0.1.50:5555 的设备 以 720 分辨率 显示【分辨率越大，越卡】据说，你的手机设备每次重启后，你可能需要重复 1-6 【 🥱 好在我的手机一般不重启 】 安卓手机连接命令123456789# 进入对象ip 手机 shell 命令adb -s 10.0.1.50 shell# 进入 adb shell 命令# 查看手机日志logcat ｜ grep 'TAG'# 过滤 TAG 日志# 安装apk 需要 打开 允许usb 安装adb install -r &lt;apk路径&gt;","categories":[{"name":"工具","slug":"工具","permalink":"http://mcdowell8023.github.io/categories/工具/"}],"tags":[{"name":"调试","slug":"调试","permalink":"http://mcdowell8023.github.io/tags/调试/"},{"name":"安卓","slug":"安卓","permalink":"http://mcdowell8023.github.io/tags/安卓/"}]},{"title":"JavaScript从头来2.1-数据类型","slug":"JavaScript从头来2.1-数据类型","date":"2020-03-28T22:47:24.000Z","updated":"2021-04-01T03:06:56.618Z","comments":true,"path":"2020/03/29/JavaScript从头来2.1-数据类型/","link":"","permalink":"http://mcdowell8023.github.io/2020/03/29/JavaScript从头来2.1-数据类型/","excerpt":"","text":"本篇 是 JavaScript 从头来 的第二篇。数据类型，在面试中经常问到。 判断数据类型也是日常开发中的常见操作。由此可见，数据类型是多么重要。 数据类型 ECMAscript 的数据类型 简单的数据类型（基本数据类型）【 5 + 2 种 】1234字符串型、数值型、布尔型、null型、undefined型、 Symbol型、BigInt型// Symbol 是 ES6 引入了一种新的原始数据类型，表示独一无二的值// BigInt 也是 新增类型 用于表示比较大的 正数// 后两种为ES6新增类型 放在最后说 复杂数据类型（引用类型）【1 种】123Objecet类型 // 本质由一组无序的名值队组成// 几种基本数据类型以外的都被称为 Objecet 【 其实是个合集，并不单纯指 &#123;&#125; 】// Array、Function 属于 object 类型ECMAscript 数据类型具有动态性【弱类型】【 变量可以从一个类型变成另外的类型，不存在变量类型的概念 】基本数据类型 的 实例 被称作《值》，Object 类型的实例 被称为 《对象》。 字符串 字符串字面量（字符串值）字符串 类型由零个或者多个 16 位 Unicode 字符 组成的字符序列。''、&quot;&quot; 单引号、双引号均可。 转译序列【用于表示非打印字符、或者具有其他用途的字符】字面量含义\\0空字符\\ ’单引号\\ &quot;双引号\\ \\反斜杠\\n换行(LF) 【将光标“垂直”移动到下一行，而并不移动到下一行的开头】\\r回车(CR)【将光标移动到当前行的开头】\\v垂直制表符\\t水平制表符 【缩进】\\b退格\\f换页\\xXX用十六进制代码表示 一个字符 如： \\x42 表示 字符 B\\uXXXX用十六进制代码表示 一个 Unicode 字符 如： \\u03a3 表示 Σ 字符串的运算字符串一旦创建无法改变、修改变量的字符串需要采取覆盖方式 var str ='qwer'; str = str+'000';使用 + 、+= 进行拼接长字符串拼接普通拼接12345678910111213// 使用 + 进行拼接let longString = 'This is a very long string which needs ' + 'to wrap across multiple lines because ' + 'otherwise my code is unreadable.'longString += '还可使用+=方式'// 使用 \\ 连接let longString = 'This is a very long string which needs \\to wrap across multiple lines because \\otherwise my code is unreadable.'ES6 新增 模版字符串12var name = 'mcdowell'console.log(`hi!$&#123;name&#125;`) // hi!mcdowell字符串的比较123456789101112131415161718var str1 = '0'var str2 = '22'var num = str1 + str2 - 0 // 一种从从 字符串转 换为 数字 的方式var str3 = str1 + str2console.log(str1 == str2) // falseconsole.log(str1 === str2) // falseconsole.log(str3 == num) // trueconsole.log(str3 === num) // falsevar name1 = 'jack'var name2 = 'mcdowell'var name3 = '张三'var name4 = '李四'console.log(name2 &gt;= name1) // trueconsole.log(name2 &lt; name1) // falseconsole.log(name2 &gt; name3) // falseconsole.log(name3 &lt; name4) // true比较运算基于 Unicode 字符的编码值（编码位置）【实际中只有英语单词的比较是有意义的】英文字母是字典序（abc 顺序）英文字母的大写 排在小写字母前字符串 比较第一个字符数字和符号在英文字母之前（个别符号在字母之后）中文字符情况更为复杂，基于 《康熙字典》的部首顺序及壁画顺序进行排序的 字符串包装类型（String 类） 字符串对象String 类 其实就是 String() 方法，我们可以借助 new【 构造函数调用 】 进行实例化 得到 字符串对象123var stringObject = new String('123') // 生成字符串对象 也就是装箱操作typeOf stringObject // objectvar stringValue = stringObject.valueOf() // 得到字符串对象的值 也就是拆箱操作装箱: 把基本数据类型转换为对应的引用类型的操作称为装箱，把引用类型转换为基本的数据类型称为拆箱拆箱: 将引用类型对象转换为对应的值类型对象，它是通过引用类型的 valueOf()或者 toString()方法来实现的。如果是自定义的对象，你也可以自定义它的 valueOf()/tostring()方法，实现对这个对象的拆箱。js 中提供 三种 包装类型，分别为 String 包装类型、Boolean 包装类型、Number 包装类型摘自：javascript 中的装箱和拆箱操作 字符串型 与 String 类 进行的隐式转换字符串型 与 String 类 之间存在隐式转换，即 从 字符串型到 String 类 是 装箱操作，从 String 类 到 字符串型 是拆箱操作。123456789'123'.length // 3 要得到字符串的长度，其实是先进行了 隐式转换 装箱操作 才得到的结果// '123'其实只是字面量，他自己本身是没有 length 的方法。那么 实际是如何运行的呢// 字符串 ‘123’ 将会先被隐式转换 成 字符串对象var stringObject = new String('123') // 生成字符串对象 也就是装箱操作// 然后 读取 字符串对象 下的 lengthstringObject.length // 3typeof stringObject 通过 ‘+’ 进行隐式转换12345678var stringObject = new String('123') // 生成字符串对象 也就是装箱操作stringObject + '789' // '123789' 把 字符串对象 进行 隐式转换// 常见使用的隐式转换456 + '' // '456'// 过程 =&gt; new String(456).valueOf() + '' // 把 字符串对象 进行 隐式转换(valueOf()) 后进行拼接 字符串与字符串对象123456789101112var str1 = new String('abc')var str2 = new String('abc')str1 == 'abc' // truestr2 == 'abc' // true 在左右两边类型不想等时候，会进行隐式转换成（调用对象的的 valueOf）变成字符串 后进行比较str2 === 'abc' // false 类型不一样str1 == str2 // false == 虽然字符串相等，但是并非引用了同一个对象， 所以是falsestr1 === str2 // false == 虽然字符串相等，但是并非引用了同一个对象， 所以是false// 实际中不推荐 这样使用str1 + '' == str2 + '' // truestr1 + '' === str2 + '' // true为了避免 字符串 与 字符串对象 混用，造成混乱，使用字符串隐式转换即可满足日常 字符串类 的方法建议在控制台中输入 new String() 得到 String 进行属性查看 常用方法分类(String.prototype 上的方法)字符方法 charAt和 charCodeAt 、[]12345678// charAt 根据 下标 返回 对应位置的 的长度为 1 的字符串，从 0 开始，如果超过了，返回空字符串var stringValue = 'hello world'console.log(stringValue.charAt(1)) //\"e\"// charCodeAt 根据 下标 返回 对应位置的 的长度为 1 的字符串 的字符 编码，从 0 开始，如果超过了，返回NaNconsole.log(stringValue.charCodeAt(1)) //返回字符编码\"101\"// string 有length 自然也有 []方式console.log(stringValue[2]) // \"l\"字符串操作方法拼接 concat12345// 用于 拼接字符串 实际使用 '+' 进行拼接更多var stringValue = 'hello 'var result = stringValue.concat('world', '!')alert(result) // \"hello world!\"alert(stringValue) // \"hello\"取出新字符串 slice、substr、 substring取出新字符串 不影响 原来的字符串123456789101112var stringValue = 'hello world'// 按照 参数 start 开始至 end 结束 取出新的字符串。如果 start 和 end 是负数，则返回从末尾逆向起数的下标值alert(stringValue.slice(3)) //\"lo world\"alert(stringValue.substring(3)) //\"lo world\"alert(stringValue.substr(3)) //\"lo world\"// 截取到 第七位 但是不包含第七位alert(stringValue.slice(3, 7)) //\"lo w\"// 截取到 第七位 但是不包含第七位alert(stringValue.substring(3, 7)) //\"lo w\"// 从3位向后数，截取 7个字符alert(stringValue.substr(3, 7)) //\"lo worl\"第一个参数 为 负数：slice()和 substr() 在接收一个负数时，会经过计算 （length + 负数（如：-3））后，进行操作substring() 直接忽略 负数 为 0，返回全部字符。第二个参数 为 负数：slice() 从数组尾部开始算起的元素，会经过计算 （length+ 1 + 负数（如：-3））后，进行操作substring() 直接忽略 负数 为 0, 进行操作（类似余 start 与 end 位置互换）substr() 直接忽略 负数 为 0，返回全空字符。示例：1234567var stringValue = 'hello world'alert(stringValue.slice(-3)) //\"rld\"alert(stringValue.substring(-3)) //\"hello world\"alert(stringValue.substr(-3)) //\"rld\"alert(stringValue.slice(3, -4)) //\"lo w\"alert(stringValue.substring(3, -4)) //\"hel\"alert(stringValue.substr(3, -4)) //\"\"字符串位置 indexOf()和lastIndexOf()indexOf 从头部 查找字符串返回 index，没找到返回 -1； 第二参数 ，指定 从头部 开始的查找位置lastIndexOf 从尾部 查找字符串返回 index，没找到返回 -1； 第二参数 ，指定 从尾部 开始的查找位置12345var stringValue = 'hello world'alert(stringValue.indexOf('o')) //4alert(stringValue.lastIndexOf('o')) //7alert(stringValue.indexOf('o', 6)) //7alert(stringValue.lastIndexOf('o', 6)) //4trim() 返回 去掉首尾 空格字符串大小写转换12345678var stringValue = 'hello world'alert(stringValue.toUpperCase()) //\"HELLO WORLD\"alert(stringValue.toLowerCase()) //\"hello world\"// 本地 化的大小写 转换alert(stringValue.toLocaleUpperCase()) //\"HELLO WORLD\"alert(stringValue.toLocaleLowerCase()) //\"hello world\"字符串模式匹配方法match接收正则 或者 要匹配的字符串在字符串内检索指定的值，或找到一个或多个正则表达式的匹配类似 indexOf() 和 lastIndexOf()，但是它返回指定的值，而不是字符串的位置[与 RegExp 对象的 exec()相同]12345var str = 'cat, bat, sat, fat'// 仅匹配以第一位 的 ，返回含有 index ，值 等信息的特殊数组str.match(/.at/) // [\"cat\", index: 0, input: \"cat, bat, sat, fat\", groups: undefined]// 全局匹配 是返回全部数组str.match(/.at/g) // [\"cat\", \"bat\", \"sat\", \"fat\"]search接收正则 或者 要匹配的字符串在字符串内检索指定的值，或找到一个正则表达式的匹配 返回 第一次出现的位置，找不到返回 -1类似 indexOf()借助 正则 中的 i 实现忽略大小写匹配12345var str = 'cat, bat, sat, fat'str.search('bat') // 5str.search(/.at/) // 0str.search(/.at/g) // 0str.search(/.bt/) // -1replace接收两个参数 [0]要替换的 字符串或者正则 ；[1]替换内容 或者 函数返回 的替换内容用于在字符串中用一些字符替换另一些字符或替换一个与正则表达式匹配的子串1234var str = 'cat, bat, sat, fat'str.replace('at,'123') // \"c123, bat, sat, fat\"str.replace(/.at/,'123') // \"123, bat, sat, fat\"str.replace(/.at/g,'$&amp;_123') // \"cat_123, bat_123, sat_123, fat_123\"更多split接收两个参数 [0]要替换的 字符串或者正则 ；[1] 可选参数–指定返回的数组的最大长度方法用于把一个字符串分割成字符串数组12345678var str = 'How are you doing today?'console.log(str.split(' ')) // ['How','are','you','doing','today?']console.log(str.split('')) // [\"H\", \"o\", \"w\", \" \", \"a\", \"r\", \"e\", \" \", \"y\", \"o\", \"u\", \" \", \"d\", \"o\", \"i\", \"n\", \"g\", \" \", \"t\", \"o\", \"d\", \"a\", \"y\", \"?\"]console.log(str.split(' ', 3)) // [\"How\", \"are\", \"you\"]var htmlStr = '&lt;p&gt;213&lt;/p&gt;'htmlStr.split(/\\&lt;|\\&gt;/) // [\"\", \"p\", \"213\", \"/p\", \"\"]localeCompare用本地特定的顺序来比较两个字符串。要以本地特定的顺序与 stringObject 进行比较的字符串返回值 ：如果 stringObject 小于 target，则 localeCompare() 返回小于 0 的数。如果 stringObject 大于 target，则该方法返回大于 0 的数。如果两个字符串相等，或根据本地排序规则没有区别，该方法返回 01234var stringValue = 'yellow'alert(stringValue.localeCompare('brick')) //1alert(stringValue.localeCompare('yellow')) //0alert(stringValue.localeCompare('zoo')) //-1排序示例：123456// 将用本地特定排序规则对字符串数组进行排序var str = 'asdfsdwerqvzfvadfas'.split('')str.sort(function (a, b) &#123; return a.localeCompare(b)&#125;)// 结果： [\"a\", \"a\", \"a\", \"d\", \"d\", \"d\", \"e\", \"f\", \"f\", \"f\", \"q\", \"r\", \"s\", \"s\", \"s\", \"v\", \"v\", \"w\", \"z\"] Number 型在 javascript 中，数值的内部结构为 64 位浮点小数，即时是整数，也是由浮点小数形式存在的。因为所有数值都是浮点小数，所以运行效率多少会有些下降。 不同的方式 表示不同的 字面量十进制：常见 79 、12 等等。八进制: 第一位必须是 0，然后是八进制序列（0 ～ 7）,如果大于 7 则被认为是 十进制。1234567var octNum1 = 070 // 8进制 的 56var octNum2 = 0621 // 8进制 的 401var octNum3 = 079 // 无效的8进制 ---解析为 79// 8进制 转换 为 10进制0621 // =&gt;;(6 * 8) ^ (2 + 2 * 8) ^ (1 + 1 * 8) ^ 0八进制 字面量在 严格模式下，是无效的，会导致报错十六进制: 前两位必须是 0x,然后是 16 进制序列（0 ～ 9、A ～ F）[A ～ F 可大写，可小写]123456var hexNum1 = 0xa // 16进制 的 10var hexNum2 = 0x1f // 16进制 的 31var hrexNum2 = 0x200 // 16进制的 512// 16进制 转换 为 10进制0x200 // =&gt;;(2 * 16) ^ (2 + 0 * 16) ^ (1 + 0 * 16) ^ 0 计算在进行算数计算的时候，八进制和十六进制表示的数值都会被转换为 十进制数值。1234567891011121314151617181920// 两个八进制相加071 + 022 // = 75 （结果为 十进制 ）/* 【 计算过程： 57 + 18 = 75 或： 个位：1 + 2 =&gt; 3 十位： 7 + 2 =&gt; 9 ,8进1 余1， 结果是： 0113 （十进制的 75 ） 】 */// 两个十六进制相加0xa2 + 0xff // 417 (结果为 十进制)/* 【计算过程： 个位： 2 + F =&gt; 17，余1 进 1 十位： A + F + 1 =&gt; 26 , 进1 余10， 结果是：0x1A1 （十进制的 417 ）】 */js 其实不管是整数还是浮点数 都是使用 IEEE754【二进制浮点数算术标准】 进行存储 运算的 浮点数浮点数必须包含小数点，而且小数点后至少一位。123var num1 = 1.1var num2 = 1.0var num3 = 0.1 // 有效但是不推荐由于保存 浮点数值 需要的 内存空间 是保存整数的两倍 ECMAscript 会在某些时候将浮点数转换为 整数。12var floatNum1 = 1 // 直接转换为 1var floatNum2 = 21.0 // 整数解析为 21 使用科学技术法（用 e 表示），表示极大或极小的数字数值（整数或者浮点数）e(或 E) 指数（10 次幂的指数） 【表示数值 与 10 次方乘积】1234563.2145e8 // 等于 32145000045.12356e5 // 等于 45123561e-1 // 等于 0.13e-4 // 等于0.0003 浮点数计算精度问题由于采用 IEEE754 数据格式 的存储数字的原因, 浮点数计算的数值会产生舍入误差值的问题。【具体戳 JS 0.1+0.2 的理解】javascript 浮点数计算精度最高 17 位小数，进行算数计算时候，精度远远不如整数。0.1 + 0.2 = 0.30000000000000004 怎样理解简单来说：计算机在计算时，都是先转换为 二进制后进行计算的，得到结果后，在转换为 10 进制。 刚好 0.1 和 0.2 转为二进制的时候，是个无限的位数，超出了 双精度位数限制（52 为）,进行了取舍，后进行的计算数值。123450.1 + 0.2 === 0.3 // 输出false 0.1+0.2 的计算结果0.300000000000000004// 永远不要测试某个特定的浮点数值// 正确的比较方法是使用 JavaScript 提供的最小精度值：console.log(Math.abs(0.1 + 0.2 - 0.3) &lt;= Number.EPSILON)//检查等式左右两边差的绝对值是否小于最小精度，才是正确的比较浮点数的方法 IEEE754【二进制浮点数算术标准】IEEE754 标准包含一组实数的二进制表示法,它由符号位、指数位、尾数位三部分组成。1符号位(s) * 尾数位(m) * 2^指数位(p)js 采用双精度存储（double precision），占用 64 bit。具体情况如：123456789101112131415161718// IEEE 754 双精度 二进制 浮点表示法s p指数位（11位） m 尾数位 (共计52位，可表示53位)0 10000000001 010000000000000000000000000000000000000000000000000000// 根据以上数值进行计算(-1)^S*(1.M)*2^(E-1023)// M后面共计50个0 E= (10000000001)2 = (1025)10(-1)^0*(1.01000...)*2^(E-1023=2)// 注意此处 2进制乘法 相当于 进行小数点位移// 1 x 1.01 × 2∧2// 输出 101【输出的结果仍然是2进制，转为10进制是 5】// 指数 为啥 减1023？ 你没看图啊，那是偏移量。// 为啥指数位要减偏移量？ 因为指数也有正负,那么怎么表示？// 将真值映射到正数域数值（移码）。使用移码比较大小，只要高位对齐后，逐一比较就行意义：1 位用来表示符号位（s）11 位用来表示指数§52 位表示尾数(m)：IEEE754 规定，在计算机内部保存有效数字时，默认第一位总是 1，所以舍去，只保留后面的部分。比如保存 1.01，只存 01，等读取的时候再把第一位 1 加上去。所以 52 位有效数字实际可以存储 53 位。根据 ECMAscript 规范： s 符号为 是 +1 或 -1，m 尾数位 是一个小于 2^53 但不小于 2^52 的正整数，p 指数位 是一个闭区间 -1074 到 971 中的整数。浮点数将该数字乘以 2，取出整数部分作为二进制表示的第 1 位；然后再将小数部分乘以 2，将得到的整数部分作为二进制表示的第 2 位；以此类推，直到小数部分为 0。特殊情况： 小数部分出现循环，无法停止，则用有限的二进制位无法准确表示一个小数，这也是在编程语言中表示小数会出现误差的原因摘自小数用二进制如何表示12345670.1&gt;&gt; parseInt(0.1*2), parseInt(0.2*2),parseInt(0.4*2),parseInt(0.8*2)......&gt;&gt; 0.0001 1001 1001 1001…（1001无限循环）0.2&gt;&gt; parseInt(0.2*2), parseInt(0.4*2),parseInt(0.8*2),parseInt(0.6*2)......&gt;&gt; 0.0011 0011 0011 0011…（0011无限循环）然而，js 采用的 双精度 尾数(m) 位数 是有限的（52 位），此时只能模仿十进制进行四舍五入了，但是二进制只有 0 和 1 两个，于是变为 0 舍 1 入。这即是计算机中部分浮点数运算时出现误差，丢失精度的根本原因。整数你以为精度丢失，只存在浮点数？大于 9007199254740992 的可能会丢失精度。由于 尾数位最大是 52 位，因此 JS 中能精准表示的最大整数是 Math.pow(2, 53)【安全值为 Math.pow(2, 53)-1】，十进制即 9007199254740992，所以大整数丢失精度的本质原因与浮点数一样。12345// 实际情况9007199254740992 + 1 // 丢失9007199254740992 + 2 // 未丢失9007199254740992 + 3 // 丢失9007199254740992 + 4 // 未丢失推荐阅读 从科学记数法到浮点数标准 IEEE 754、IEEE-754 浮点转换器、JS Number 类型数字位数及 IEEE754 标准 数值范围在计算机中，我们有一定的精度限制。最大的数字是什么？在数学中，你应该是无法给出具体数字。但是在 ECMAscript 中你可以。因为毕竟内存是有限的。而JavaScript 中的 Number 类型 基本 符合 IEEE 754-2008 规定的双精度浮点数规则。根据 ECMAscript 规范 (s) * (m) * (2^e) ，m 范围 【2^52 - 2^53 】 的正整数，p 指数位 是一个闭区间 -1074 到 971 中的整数所以。。。1234567891011121314151617// 能精确表示的整数范围上限,S为1个0，E为11个0，S为53个1;((Math.pow(2, 53) - 1 === Number.MAX_SAFE_INTEGER - // true // 能精确表示的整数范围下限,S为1个1，E为11个0，S为53个1 (Math.pow(2, 53) - 1)) === Number.MIN_SAFE_INTEGER( // true // 能表示的最大数字，S为1个0，E为971，S为53个1 Math.pow(2, 53) - 1 ) * Math.pow(2, 971)) === Number.MAX_VALUE // true// 能表示的最接近于0的正数，S为1个0，E为-1074，S为0Math.pow(2, -1074) === Number.MIN_VALUE // true// [MIN_SAFE_INTEGER, MAX_SAFE_INTEGER] 的整数都可以精确表示，// 但是超出这个范围的整数就不一定能精确表示。这样就会产生所谓的大数精度丢失问题。Number.MAX_VALUE能表示的最大正数。最小的负数是 -MAX_VALUE。Number.MIN_VALUE能表示的最小正数即最接近 0 的正数 (实际上不会变成 0)。最大的负数是 -MIN_VALUE。Number.NaN特殊的“非数字”值。Number.NEGATIVE_INFINITY特殊的负无穷大值，在溢出时返回该值。Number.POSITIVE_INFINITY特殊的正无穷大值，在溢出时返回该值。ES6 新增Number.EPSILON两个可表示(representable)数之间的最小间隔。[最小精度]Number.MAX_SAFE_INTEGERJavaScript 中最大的安全整数 (2^53 - 1)。Number.MIN_SAFE_INTEGERJavaScript 中最小的安全整数 (-(2^53 - 1)).JavaScript 中的 Number 类型有 18437736874454810627(即 2^64 - 2^53+3) 个值。ECMAscript 的 Number 类型基本符合 IEEE 754-2008 规定的双精度浮点数规则，但是 JavaScript 为了表达几个额外的语言场景（比如不让除以 0 出错，而引入了无穷大的概念），规定了几个例外情况：NaN，占用了 9007199254740990，这原本是符合 IEEE 规则的数字；Infinity，无穷大；-Infinity，负无穷注意：javascript 的数值保存方式，可以保存正 0 和负 0，正 0 和负 0 被认为是相等的。0/0 返回 NaN正数/0、负数/-0 返回 Infinity负数/0、正数/-0 返回 -Infinity解决 精度问题的方法借助 Number.EPSILON 进行最小精度判断先将小数处理为整数，再除以乘积 【有可能超出最大安全值】通过字符串的方式，模拟计算，进行对应计算。【大部分成熟计算库都使用此方式】 数值转换number（）传入 Boolean true 是 1，false 是 0；传入 undefined 返回 NaN, null 返回 0,什么都不传 返回 0传入 字符串 纯数字 忽略前导 0，返回十进制数字。16 进制 Oxf1 等数字，转为 十进制数字。传入 字符串的包含 非数字 非空字符串 [字母符号等] 返回 NaN传入 对象： 先调用 valueOf()方法，如果返回 结果是 NaN ,继续调用 toString(),依据以上规则返回值parseInt（）传入 空字符串、Boolean、undefined、null、对象等均返回 NaN传入 包含数字的字符串 比较复杂123456789parseInt(' 12 3 ') // 12parseInt('1dasd12') // 1// 会忽略 字符串 起始位置的空字符串、数字后面的字母、符号、空字符【之后的内容直接被截取】parseInt(' w1d') // NaNparseInt(' 1.12 ') // 1 其实取整就是 按照上面规则 一刀切parseInt('.12 ') // NaN// 起始 位置是字母、符号[+、- 正负除外]的 直接返回 NaN不会忽略前导 0，可能会被按照 八进制或十六进制 进行解析，单推荐传入第二个参数进行使用。进行 进制 转换，请传入第二参数，基数1234parseInt('10', 2) // 2 按照二进制解析parseInt('10', 8) // 8 按照八进制解析parseInt('10', 10) // 10 按照十进制解析parseInt('10', 16) // 16 按照十六进制解析parseFloat（）同 parseInt 传入 空字符串、Boolean、undefined、null、对象等均返回 NaN会忽略 字符串 起始位置的空字符串、数字后面的字母、符号、空字符【之后的内容直接被截取】传入 字符串 起始 位置是字母、符号[+、- 正负除外]的 直接返回 NaN传入整数，仍然会返回整数，传入小数仍然返回小数。忽略前导 0，只进行十进制 解析借助 运算符进行隐式转换从 数字字符串 转换 成数字 使用 减法、乘法、除法[-、*、/]:12345678'12' - 0 // 12;'w12' - 0 // NaN;' 12' * 1 // 12;'1/2' * 1 // NaN;'12' / 1 // 12;'w12' / 1 // NaN;从数字转为字符串 使用 加法 [ + ]1212 + '' // '12'12 + '0' // '120'方法：Number.isNaN() / isNaN()确定传递的值是否是 NaN。默认对传入的 值进行转换后，进行判断isNaN('123')===false;isNaN('blue')===true;isNaN 同样适用于 对象。Number.parseFloat()/parseFloat()和全局对象 parseFloat() 一样。Number.parseInt()/parseInt()转换为整数Number.isFinite() / isFinite()确定传递的值类型及本身是否是有限数。ES6 新增Number.isInteger()确定传递的值类型是“number”，且是整数。Number.isSafeInteger()确定传递的值是否为安全整数 ( -(253 - 1) 至 253 - 1 之间)。 Number 类与 string 类 同样，也存在 Number 类。经过数据类型转换后，数值和数值对象可以被视为等价通过 new 显示的生成数值对象new Number() Number 类 的方法建议在控制台中输入 new Number() 得到 Number 进行属性查看，同步理解 函数或者构造函数Number(value) : 将参数转换为字符串类型new Number(value) : 得到一个 Sting 实例 Number.prototype 对象的 属性字面量含义 ｜numObj.toExponential(digits)以指数表示法（科学计数法）返回该数值字符串表示形式[digits：一个整数，用来指定小数点后有几位数字。]numObj.toFixed(digits)方法使用定点表示法来格式化一个数值[digits：小数点后数字的个数；介于 0 到 20 （包括）之间，默认是 0 ]numObj.toLocaleString()转换为和本地环境想对应的字符串numObj.toPrecision(precision)转换为小数点形式（科学计数法）的字符串[precision:有效数字–除去小数点以外的位数] UndefinedUndefined 类型只有一个值，就是特殊的 undefined。在声明变了时，不进行初始化的值就是 undefined。123456789var msg// var name;console.log(msg) // undefined 【只是声明了，未进行初始化负值】console.log(name) // 报错无法执行 【没有进行变量声明而报错】// 奇怪 的现象？？console.log(typeof msg) // undefinedconsole.log(typeof name) // undefined// 不管是为定义还是未声明 都是 无法真正操作的 所以，返回此种情况 是合理的undefined 可以进行赋值操作【undefined、NaN 和 Infinity 都是全局对象 window 的属性。既然是属性，当然可以赋值。然而这三个属性又是不可写的属性，即它们的的内部特性[[writable]]为 false，所以赋值无效 】undifined 不是常量不是保留字，你完全可以自定义一个叫做 undefined 的变量或者函数【 非全局作用域 】；比如 var undefined=‘foo’12345678910111213//此方法 表明是 undefined 是window 不可写的属性Object.getOwnPropertyDescriptor(window, 'undefined')// 2. undefined 全局模式可以赋值 不会报错，但是 赋值不会成功undefined = 11console.log(undefined, '全局')// 3. undefined 可以 非全局作用域 进行赋值 使用function foo() &#123; var undefined = 10 console.log(undefined)&#125;foo() // 打印10以上 摘自由 ES 规范学 JavaScript(一)：为什么 undefined 可以被赋值，而 null 不可以？建议使用 void 0 代替 undefined ?1234567void 0 === undefined // true/* JavaScript 的代码 undefined 是一个变量，而并非是一个关键字， 这是 JavaScript 语言公认的设计失误之一， 所以，我们为了避免无意中被篡改， 建议使用 void 0 来获取 undefined 值 -- 《重学前端-程劭非（winter）》 */void 运算符 对给定的表达式进行求值，然后返回 undefinedif 判断 通过msg===undefined 或 typeof(msg)===&quot;undefined&quot; 的形式确定变量是否是 undefined；【undefined 是 false !undefined 是 true】一个函数如果没有使用 return 指定返回值，将会返回一个 undefined 值 Null 类型Null 类型 只有一个值 null。null 是缺少标识符，表示变量 未指向任何对象【 这就是 typeof null 返回“object” 的原因 】如果定义变量将来要用来保存对象，初始变量最好是 null。undefined 实际派生自 nullnull 是一个字面量[与 true 和 false 类似]。属于 JavaScript 的保留字,不可以赋值null==undefined ; null!==undefined、 Boolean 类型Boolean 类型 有两个 字面量，true 和 false。字面量 true 和 false 区分大小写，与 True 和 False(以及其他形式的大小写)都不是 Boolean，知识标识符。 其他类型转换为 Boolean使用Boolean()方法使用!!msgif 条件语句中 自动转换123var msg = 'hello'console.log(Boolean(msg), 'Boolean(msg),!!msg', !!msg) // true \"Boolean(msg),!!msg\" true各类型不同值对应转换规则数据类型转换为 true 的值转换为 false 的值BooleantruefalseString任何非空字符串空字符串（’’）Number非 0 数字0 和 NaNObject任何对象nullUndefined–不存在–undefined","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://mcdowell8023.github.io/categories/基础知识/"}],"tags":[{"name":"js基础","slug":"js基础","permalink":"http://mcdowell8023.github.io/tags/js基础/"},{"name":"追本溯源","slug":"追本溯源","permalink":"http://mcdowell8023.github.io/tags/追本溯源/"},{"name":"笔记","slug":"笔记","permalink":"http://mcdowell8023.github.io/tags/笔记/"}]},{"title":"JavaScript从头来1.1-基本概念","slug":"JavaScript从头来1.1-基本概念","date":"2020-03-26T22:47:24.000Z","updated":"2020-11-03T06:50:39.418Z","comments":true,"path":"2020/03/27/JavaScript从头来1.1-基本概念/","link":"","permalink":"http://mcdowell8023.github.io/2020/03/27/JavaScript从头来1.1-基本概念/","excerpt":"","text":"javascript 简介 特点解释型语言类似于 c 和 java 的语法结构动态语言基于原型的面向对象字面量的表现能力函数式编程 JavaScript 组成浏览器客户端 :核心（ECMAScript）+ 文档对象模型（DOM）+ 浏览器对象模型（BOM）服务端：核心（ECMAScript）+ 内置宿主对象ECMAScript 与浏览器没有依赖关系（本身不包含输入、输出定义）。ECMA-262 定义的是语言基础，可以在此基础上构建完善的脚本语言。具体包含【语法、类型、语句、关键字、保留字、操作符、对象】 表达式和语句的构成JavaScript 的源代码本质上是一个语句的集合。语句是由语句和表达式所构成的。表达式则由表达式和 运算符所构成。即使在一条语句中包含其他语句，只要对这条被包含的语句继续进行分解， 最终都会到达仅包含保留字、表达式与符号的状态。 html 中的 javascript (script 标签)将 JavaScript 插入 HTML 的主要方法是使用&lt;script&gt;元素。 关于 script 标签 属性src: 没有表述 行内代码；有表示加载加载外部 jstype: 代替原来的 language 属性，表示语言类型。浏览器中始终是 text/javascript如果值是 module,代码会被理解为 ES6 模块，才可以使用 import 和 export 关键字nomodule: 在不支持 type=“module”【不支持 import 和 export】 的浏览器（IE11）执行的代码crossorigin（跨源）基本概念协议(pro tocal)、域名(domain)、端口(port) 有一个不同的，都视作 跨源（跨域）CORS 元素：【Cross Origin Resource Share】&lt;script&gt;、&lt;link&gt;、&lt;imag&gt;、&lt;audio&gt;、&lt;video&gt;配置相关请求的 CORS(跨源资源共享)设置。默认不使用 CORS。crossorigin= “” 或者不进行设置 ，为 anonymous 配置crossorigin= “anonymous” 配置文件请求不必设置凭据标志。crossorigin=&quot;use-credentials&quot;设置凭据 标志，意味着出站请求会包含凭据。integrity:可选。安全校验值用于 第三方 资源 提供的散列值 进行计算校验。校验 安全，于确保内容分发网络(CDN)不会提供恶意内容。关于 script 加载defer: 不阻塞文档正常加载，但是延迟执行（文档完全被解析和显示 之后再执行）。只对外部脚本文件有效。 【IE7 及一下也可使用】。async: 异步加载脚本，加载后 立即执行脚本(可能会 阻塞文档加载)。【立即开始下载脚本，但不能阻止页面其他动作，比如下载资源或等待其他脚本加载】src 引入方式有效。&lt;script type=&quot;module&quot;&gt;&lt;/script&gt;: 使用 defer 方式进行加载 [ 异步加载脚本,延迟到 文档都加载完后 才去执行 ]&lt;script type=&quot;module&quot; async&gt;&lt;/script&gt;: 使用 async 方式进行加载[ 异步加载脚本后，立即执行 ]没值: 会阻塞文档加载，开始加 脚本，直至 加载并执行完毕后，才会继续执行 文档加载。[通常应该把&lt;script&gt;元素放到页面末尾，介于主内容之后及&lt;/body&gt;标签 之前] 加载优化预加载 &lt;link rel=&quot;preload&quot; href=&quot;gibberish.js&quot;&gt;MDN 通过 link 标签 rel=&quot;preload&quot;进行内容预加载 关键字和保留字就有特殊用途的–关键字，如：void break return do case else new var ... 预留的不能用作特殊字符的保留字，如：boolean float native init short ... 标识符标识符指变量、函数、属性的名字、或者函数的参数。组合规则：第一个字符必须是字母、下划线（_）、或者美元( $ )其他字母可以是字母、下划线、美元或者数字驼峰写法： 第一个字母小写 剩下的每个单词首字母大写必须是除保留字以外的单词。必须是除 true、false、null 以外的单词。必须是以 Unicode 的(非空)字符开始，之后接有 Unicode 字符或是数字的单词。单词的长度并无限制。习惯上，以下划线(_)开始的标识符会被作为“内部标识符”来使用 字面量字面量(literal)指的是，在代码中写下这些值之后，将会在运行时直接使用这些值的字面含义。1234// 字符串字面量\"bar\"的例子var foo = 'bar'// 数值字面量0的例子var val0 = 0名称具体示例数值100字符串值“foobar”布尔值truenull值 nullObject{ x:1, y:2 }数列[3, 1, 2]函数function() { return 0; }正则表达式/foo/ 区分大小写变量、函数名、操作符都区分大小写 严格模式头部添加' use strict '，表示在严格模式下的执行。严格执行模式下，执行结果会有很大不同。支持浏览器：IE10+、Firefox4+、Safari5.1+、Opera12+、Chrome 语句每条语句，分号结尾（;）【 现代项目架构中，不加分号是编译后，统一由脚手架添加 】。复合语句，使用花括号 （{}）进行代码块分割，明确意图，降低出错情况。 变量的基础变量的作用是给某一个值或是对象标注名称。ECMAscript 变量是非常松散的（可以保存任何**类型**的数据）。每个变量仅仅只是一个用于存值的占位符。1234567891011121314151617181920212223// 操作符（关键字） + 变量名var clock // 变量值是： undefinedvar count = 1 // 变量值是： 1 【 等于： var count = undefined； count = 1; 】先声明 后负值dfunction test() &#123; num = 1 // 有意 忽略 var 关键字，的确可以在局部作用域创建一个全局变量。 // 但是不推荐这样使用会导致， 造成不必要的混乱 var isShow = true // 局部变量 console.log(count) // 1 count 是个全局变量&#125;test()console.log(isShow) // 错误 : isShow is not defined 因为 局部变量 无法访问console.log(clockName) // undefined： 变量提升【只会提升变了声明 ，不回提升负值】var clockName = 'littleClock'// 批量var message = 'hi', found = false, age = 29 关于 变量、常量、字面量 的区别变量、常量是引用，变量值可变，常量值固定。字面量是值 函数基础函数本身也是一种对象。正如变量存在的意义是为了调用没有名称的对象，函数名存在的意义是为了调用没有名称的函数。因此，变量名和函数名实质上是相同的。12345678910// 匿名函数的语法function (参数, 参数, ......) &#123; 函数体&#125;function 函数名 (参数, 参数, ......) &#123; 函数体&#125;var 函数名 = function()&#123; 函数体&#125; 对象的基础 对象特点属性值可以由函数指定具备一种称为原型链的构造 对象字面量表达式与对象的使用123&#123; key: value&#125;key 属性名可以是标识符、字符串值或是数值。value 属性值则可以是任意的值或对象。 属性访问. 方式用于确定属性的赋值或取值：obj.key=123[]方式用于不确定值的属性[字符串类型]的赋值或取值：123var name = 'key'obj[name] = 123obj['id'] = 123 new 表达式new 表达式的作用是生成一个对象。new 之后所写的是函数名,成的对象，其属性能够被 读取。12var obj = new Object()typeof obj // \"object\"JavaScript 中没 有类的概念，所以，根据 JavaScript 的语法规则，new 之后所写的是函数名。 就会把该函数作为构造函数来进行调用。 数组的基础数组是一种用于表达有顺序关系的值的集合的语言结构。在 JavaScript 中，数组并非是一种内建类 型。相对地，JavaScript 支持 Array 类，所以数组能够以 Array 类的实例的形式实现。12345var arr = [1, 100, 7]arr[1] = 100 // 读取索引值为1的元素var n = 1console.log(arr[n]) // 与a[1]含义相同 200console.log(arr[n + 1]) // 与a[2]含义相同 数组内部元素可以是多种类型12345var arr = [1, '23', true, null, undefined]arr.push(function () &#123; return 123&#125;)// [1, \"23\", true, null, undefined,function()&#123;return 123&#125;] 数组内部元素可以是多维123var arr = [1, 2, 3]arr.push([4, 5, 6])console.log(arr) // [1, 2, 3,[4, 5, 6]] 条件语句 if-else 语句12345678// 通过代码块来避免出现容5易使人误解的缩进if (i == 0) &#123; if (j == 0) &#123; console.log('i==0 and j==0') &#125; else &#123; console.log('i==0 and j!=0') &#125;&#125; switch-case 语句1234567891011121314151617181920212223242526// switch-case语句的语法var s = 'foo'// 可以在switch表达式中使用字符串值。// 可以在case表达式中使用和switch表达式类型不同的值。// s === 0 的值为假，所以将继续进行比较。switch (s) &#123; case 0: console.log('not here') break // 可以在case表达式中使用含有变量的表达式。 // s === s.length的值为假，所以将继续进行比较。 case s.length: console.log('not here') break // 可以在case表达式中使用方法调用表达式。 // s === (0).toString()的值为假，所以将继续进行比较。 case (0).toString(); console.log('not here') break // 还可以在case表达式中书写这样的表达式。 // s === 'f' + 'o' + 'o'为真，所以将执行以下的代码。 case 'f' + 'o' + 'o': console.log('here') break // 如果所有的case表达式在等值运算(===)后得到的结果都为假，则执行以下的代码。 default: console.log('not here') break&#125;进行相等运算符(===)进行比较case 标签并没有对代码按块 进行分割的功能。因此在一个 case 标签结束执行之后，并不会跳出 switch 语句，需要 break 循环语句 while12345678// 使用代码块的话就能很容易地理清语句结构// 循环10次的while语句var i = 0while (i &lt; 10) &#123; console.log(i) i++ return&#125;使用 break 等来中断循环,continue 跳出当次要避免出现无限循环，从 while 循环中跳出，可以执行以下操作。保证在循环过程中条件表达式的值将变为假在循环内部使用 break 语句在循环内部抛出异常 do-while 语句123456// do-while语句的例子do &#123; // 不管是否符合条件， 先执行一次 // 之后，符合条件，继续进入执行 console.log('in loop')&#125; while (flag)使用 break 等来中断循环,continue 跳出当次只要稍加调整，这两种情况也都能通过 while 语句来实现。如果循环内的语句不执行一次，条件表达式的求值就没有意义的情况希望确保循环内的语句至少被执行一次的情况 for 循环123for (var i = 0; i &lt; 10; i++) &#123; // 语句&#125;可以使用 return、break 等来中断循环,continue 跳过当次 for in 循环for in 语句是用于枚举对象属性名的循环语句1234var obj = &#123; x: 1, y: 3, z: 2 &#125;for (var k in obj) &#123; console.log(k)&#125;注意：枚举属性的顺序:不是一定的有一些无法被枚举的属性由原型继承而来的属性，会被意外枚举推荐做法：123456var obj = &#123; x: 1, y: 3, z: 2 &#125;var arr = Object.keys(obj)for (var i = 0; i &lt; arr.lengt; i++) &#123; var name = arr[i] console.log(obj[name])&#125; 跳出循环 break 语句 普通用法123456789101112131415// 不通过break语句跳出循环的代码示例var flag_loop = truewhile (flag_loop) &#123; 省略 if (跳出循环的条件) &#123; flag_loop = false &#125;&#125;// 通过break语句跳出循环的代码示例while (true) &#123; 省略 if (跳出循环的条件) &#123; break &#125;&#125; 通过标签跳转借助标签跳转 可以跳出多层循环1234567891011// 标签的语法规则标签字符串: 语句//eg: 使用标签来同时跳出嵌套的循环outer_loop: while (true) &#123; console.log('outer loop') while (true) &#123; console.log('inner loop') break outer_loop &#125;&#125; continue 语句跳过在此之后本次循环内尚未执行的语句,将会跳转至循环的开头。123456for (var i = 0; i &lt; 10; i++) &#123; if (i % 2 !== 0) &#123; continue &#125; // do something&#125; return 语句return 语句会中断函数的处理，并将指定的表达式的值作为函数的返回值返回。如果没有指定表达式，函数的返回值将会是 undefined 值return 语句","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://mcdowell8023.github.io/categories/基础知识/"}],"tags":[{"name":"js基础","slug":"js基础","permalink":"http://mcdowell8023.github.io/tags/js基础/"},{"name":"追本溯源","slug":"追本溯源","permalink":"http://mcdowell8023.github.io/tags/追本溯源/"},{"name":"笔记","slug":"笔记","permalink":"http://mcdowell8023.github.io/tags/笔记/"}]},{"title":"JavaScript从头来1.2-基本概念","slug":"JavaScript从头来1.2-基本概念","date":"2020-03-26T22:47:24.000Z","updated":"2020-08-13T21:46:39.442Z","comments":true,"path":"2020/03/27/JavaScript从头来1.2-基本概念/","link":"","permalink":"http://mcdowell8023.github.io/2020/03/27/JavaScript从头来1.2-基本概念/","excerpt":"","text":"异常throw 语句来抛出异常对象(异常值)12// throw语句的语法规则throw 表达式借助 try-catch 抛出 捕捉抛出异常123456789// try-catch-finally结构的语法try &#123; // 正常 流程&#125; catch (erro) &#123; // 捕捉的异常 throw erro&#125; finally &#123; // 成功、异常 都会 执行&#125; 表达式表达式由 运算符 和 操作数 组成 运算符运算符 的优先级两个操作数的运算符被称为双目运算符，需要在运算符的前后分别书写一个操作数。大部分运算符都是双目运算符，三目运算符有 1 个，其余的都是单目运算符。三目运算符有 3 个操作数，而单目运算符则只有 1 个操作数。单目运算符又可以根据运算符与操作数的前 后位置关系，分为前置运算符与后置运算符。前置运算符是以“运算符 操作数”的顺序书写的，而后置 运算符则是按照“操作数 运算符”的顺序。 表达式求值除了含有 &amp;&amp; 运算符、|| 运算符、?: 运算符这三个运算符的情况外，其他的表达式都是首先对操作数进行求值。操作数按从左至右的顺序求值。对于函数方法或是构造函数调用表达式的情况，会在调用前对参数从左至右求值。优先对括号内的表达式求值。如果在对操作数求值的过程中产生了异常，则不会对剩余的操作数进行求值。对于函数方法或是构造函数调用表达式的情况，如果在对参数进行求值的过程中发生异常，则不会对剩余的参数进行求值。 算数运算符+[加法]、-[减法]*[乘法]/[除法]%[取模]、++(前置)++(后置)[自增]、--(前置)、--(后置)[自减]、-(单目)[符号反转]、+(单目)[符号保持不变]++ 运算符的含义是对操作数加 1。-- 运算符的含义是对操作数减 1。这两个运算符都会重写操作数的值。这类会改写操作数本身的值的运算符，称为破坏性运算符赋值运算符是另一种有代表性的破坏性运算符12345678// 前置运算符的行为var n = 10var m = ++nconsole.log(m, n) // n变为了11。++n的值是进行了加法之后的值，所以m为11。 11 11// 后置运算符的行为var n = 10var m = n++console.log(m, n) // n变为了11。++n的值是进行了加法之前的值，所以m为10。 10 11 相等运算符相等运算 ==,只比进行隐式数据类型转换后的值 是否相等，忽略 两个操作数 本身类型。全等运算 ===,上来先比较类型是否相等，类型相同后才进行比较，必须是内容一样的，则结果为真。 比较运算符如果两个操作数都 是数值，则对这两个数值的大小进行比较。如果两个操作数都是字符串型则对字符串值内容的 Unicode 编码进行大小比较。一方为数值，另一方为可以被转换为数值的数据类型的情况，将其转换为数值类型后再进行大小比较。如果操作数中含有 NaN 则结果为假。一方为字符串值，另一方为可以被转换为字符串值的数据类型的情况，将其转换为字符串值后再对字符串值进行大小比较。操作数中有无法被转换为数值及字符串值的值，或是转换结果为 NaN的情况，运算的结果为假。 in 运算符指定的属性在指定的对象或其原型链中，则 in 运算符返回 true.12345678910111213141516171819// 数组var trees = new Array('redwood', 'bay', 'cedar', 'oak', 'maple', null)0 in trees // 返回true3 in trees // 返回true5 in trees // 返回true 只要这个属性确实存在， 仍然返回 true6 in trees // 返回false'bay' in trees // 返回false (必须使用索引号,而不是数组元素的值)'length' in trees // 返回true (length是一个数组属性)Symbol.iterator in trees // 返回true (数组可迭代，只在ES2015+上有效)// 内置对象'PI' in Math // 返回true// 自定义对象var mycar = &#123; make: 'Honda', model: 'Accord', year: 1998 &#125;'make' in mycar // 返回true'model' in mycar // 返回true 逻辑运算符运算符说明短路规则!逻辑非(NOT)无(单目运算符)&amp;&amp;逻辑与(AND)若左操作数的值为假，则不再对右操作数进行求值。||逻辑或(OR)若左操作数的值为真，则不再对右操作数进行求值。&amp;&amp; 运算和 || 运算有一个重要的性质——短路求值。运算前仅会先对左边的操作数进行求值。1234567891011var n = 1 &amp;&amp; 2console.log(n) // 2var n = 0 &amp;&amp; 2console.log(n) // 0var n = 0 || '--'console.log(n) // --var n = 'type' || 'default'console.log(n) // type 条件运算符（三目运算符）条件运算符是唯一的三目运算符。由于三目运算符只有这一个，所以有时也会直接把条件运算符称 为三目运算符。与 &amp;&amp; 运算符和 || 运算符一样，条件运算符也有短路求值的特性。基本可以理解为if else的缩写，把?看作 if,:看作else条件表达式 ? 表达式1 : 表达式2常用示例12345678// 这是 一个处理数字 小于两位数时候，的补0 操作函数function formatZero(num) &#123; if (isNaN(num)) &#123; return '--' &#125; // 在获得计算结果后，进行返值 return num &gt; 10 ? '' + num : '0' + num&#125; 位运算符运算符说明&amp;按位与(AND)|按位或(OR)^按位异或(XOR)&lt;&lt;左移&gt;&gt;右移(最左位保持原符号不变)&gt;&gt;&gt;无符号右移(最左位被置为 0)~单目运算符。按位取反，取 1 的补码123456// 右侧移动 1位 除以2\b^1(2的1次方); 移动 2位 除以 2^2(2的2次方);....72 &gt;&gt; 1 // 36(72/2)72 &gt;&gt; 2 // 18(72/2^2)// 左侧移动 1位 乘以2\b^1(2的1次方); 移动 2位 乘以 2^2(2的2次方);....72 &lt;&lt; 2 // 288 (72*2^2)72 &lt;&lt; 3 // 576 (72*2^3) 赋值运算符用于对变量赋值的 = 运算符是赋值运算符123456789var a = 1console.log(a) // 1// 多次赋值 从右到左x = y = z = 0console.log(x, y, z) // 0 0 0z += 1y -= 1console.log(z, y) // 1,-1 new 运算符new 运算符创建一个用户定义的对象类型 的 实例或具有构造函数的内置对象 的 实例。new 关键字会进行如下的操作：创建一个空的简单 JavaScript 对象（即{}）；链接该对象（即设置该对象的构造函数）到另一个对象 ；将步骤 1 新创建的对象作为 this 的上下文 ；如果该函数没有返回对象，则返回 this。123456789function Car(make, model, year) &#123; this.make = make this.model = model this.year = year&#125;const car1 = new Car('Eagle', 'Talon TSi', 1993)console.log(car1.make) delete 运算符delete 操作符会从某个对象上移除指定属性。成功删除的时候回返回 true，否则返回 false。注意： delete 对象上没有的属性，依然会返回 true【成功与否 主要看 Object.defineProperty 设置该属性 的 configurable 是否 true】123456789101112131415const object1 = &#123;&#125;Object.defineProperty(object1, 'property1', &#123; configurable: false, // 如果设为true 就可以 delete object1.property1 返回 true value: 42, writable: false,&#125;)object1.name = 'jack'object1.tag = nulldelete object1.name // truedelete object1.tag // truedelete object1.id // truedelete object1.property1 // false void 运算符void 是 undefined 类型的单目运算符。无论向其传递什么操作数，其运算结果都会是 undefined 值。由于 js 的特性 undefined 不是保留字，容易被篡改，所以建议使用 void 0 代替 undefined 进行类型判断 一个 void 的常见用法1234567&lt;a href=\"javascript:void(document.form.submit())\" &gt;发送HTML表单数据但不跳转页面&lt;/a&gt;&lt;!-- 为了阻止标 签 a 跳转页面，需要将 href 属性中表达式的值强制设为 undefined 值。对此最为简单的惯用方法就是通 过 void 运算来实现。 --&gt; 逗号(,)运算符逗号运算符(,)是一个双目运算符，其作用为依次对其左操作数与右操作数求值。逗号运算符的运算结果是其右操作数的值，也就是说其结果的类型取决于所使用的操作数 数据类型的判断本节建议看完 全部 Object 对象章节，再回过头重看一遍 typeof 运算符typeof 一元运算符，用来返回操作数类型的字符串‘undefined’ – 未定义‘boolean’ – 布尔值‘string’ – 字符串‘number’ – 数值‘function’ – 函数‘object’ – 对象或者 null [ null 被认为是 空对象的引用 ]技术角度说，函数不是一种数据类型，是对象，但是函数有一些特殊属性。因此需要 将函数 与对象区分开123456789typeof true // \"boolean\"typeof &#123;&#125; // \"object\"typeof typeof 11 // \"string\"typeof function () &#123;&#125; // \"function\" -- 由于特殊考虑，确实需要将function 与 object区分开来typeof [1, 2, 3] // \"object\" -- 可是数组 不如你所预想的那样typeof /abc/g // \"object\"typeof new RegExp('meow') // \"object\" -- 遇到检测数组的同样问题正如你看到的，typeof 返回的，不一定都是你想看到的。【因为 array、正则表达式、函数等，除了原始值，都是对象】实际情况一览表：ValueClassType“foo”Stringstringnew String(“foo”)Stringobject1.2Numbernumbernew Number(1.2)NumberobjecttrueBooleanbooleannew Boolean(true)Booleanobjectnew Date()Dateobjectnew Error()Errorobject[1,2,3]Arrayobjectnew Array(1, 2, 3)Arrayobjectnew Function(&quot;&quot;)Functionfunction/abc/gRegExpobject (function in Nitro/V8)new RegExp(“meow”)RegExpobject (function in Nitro/V8){}Objectobjectnew Object()Objectobject你可以看到：除了被正常的个数据类型对象外，显示为 object 的还有 js 内置对象 RegExp(正则对象),Array 对象,Error对象,Date 日期对象那么我们用什么判断类型，数组是数组，正则是正则，字符串是字符串呢？ instanceof 运算符用法object instanceof constructor运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。【看起来可以完美进行类型判断】但是，只有在比较自定义的对象时才有意义。 如果用来比较内置类型用处不大 比较 自定义对象1234567891011//function Foo() &#123;&#125;function Bar() &#123;&#125;Bar.prototype = new Foo()new Bar() instanceof Bar // truenew Bar() instanceof Foo // true// 如果仅仅设置 Bar.prototype 为函数 Foo 本身，而不是 Foo 构造函数的一个实例Bar.prototype = Foonew Bar() instanceof Foo // false 比较 比较内置类型123456789101112131415/abc/g instanceof RegExp // truenew Date() instanceof Date // true'123' instanceof Array // false123 instanceof Array // false[] instanceof Array // true(&#123;&#125;) instanceof Array // false // 不加（） 会报错// 然而 你以为完美了？ 不然。。。[] instanceof Object // true/abc/g instanceof Object // true// 比较内置类型new String('foo') instanceof String; // truenew String('foo') instanceof Object; // true'foo' instanceof String; // false'foo' instanceof Object; // false注意：用来比较内置类型用处不大基本类型值（undefined,null,‘23df’,123,true） instanceof Object(String、Number) 也都是 false因为检查原型链会找到 undefined其实按照用法，要求进行两个对象 进行比较 ，而这种比较方式本身就是错误的js 所有 对象 都派生 Object ，所以 任何对象 instanceof Object 都是 true!(mycar instanceof Car) 与 !mycar instanceof Car 不同，后者 会先 转换 为 布尔值，然后进行instanceof判断，会一直显示 false使用 arr instanceof Array判断是不是数组,仅限于在当前 JavaScript 上下文的 Array 对象 相同。 instanceof 操作符应该仅仅用来比较来自同一个 JavaScript 上下文的自定义对象instanceof 问题在于，它假定了单一的全局执行环境。如果网页中包含多个框架，那实际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的 Array 构造函数。如果你从一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有各自不同的构造函数。为了解决这个问题，尽量使用 Array.isArray()方法，这个方法的目的是确认某个值是否是数组，而不管它是在哪个全局执行环境中创建的。支持 Array.isArray()的浏览器：IE9+、Firefox 4+、Safari 5+、Opera 10.5+和 chrome。那么如何一劳永逸的判断数据类型？ 对象的类定义其实我们要的，是检测对象的 的内部属性 [[Class]] 的值 （对象的 类定义）；JavaScript 标准文档中定义: [[Class]] 的值只可能是下面字符串中的一个： Arguments, Array, Boolean, Date, Error, Function, JSON, Math, Number, Object, RegExp, String.为了获取对象的 [[Class]]，我们需要使用定义在 Object.prototype 上的方法 toString。123456789101112131415161718Object.prototype.toString.call([]) // \"[object Array]\"Object.prototype.toString.call(&#123;&#125;) // \"[object Object]\"Object.prototype.toString.call(4) // \"[object Number]\"Object.prototype.toString.call('acdf') // \"[object String]\"// 高级浏览器表现Object.prototype.toString.call(null) // \"[object Null]\"Object.prototype.toString.call(undefined) // \"[object Undefined]\"// IE8Object.prototype.toString.call(null) // \"[object Object]\"Object.prototype.toString.call(undefined) // \"[object Object]\"// 通用方法 通常不对null undefined 进行判断function is(type, obj) &#123; var clas = Object.prototype.toString.call(obj).slice(8, -1) return obj !== undefined &amp;&amp; obj !== null &amp;&amp; clas === type&#125;is('String', 'test') // trueis('String', new String('test')) // true敲黑板辨别到底是不是数组的方法 ：使用 Array.isArray 或者 Object.prototype.toString.call 方法那么为什么是 Object.prototype.toString 而不是直接使用 toString 方法。因为，array 、date 等 对象都是派生自 Object,对其进行实例化的时候，已经改写了 toString 方法。记住 一劳永逸的的判断 变量类型：Object.prototype.toString.call参考 1：typeof 和 instanceOf 的区别参考 2：为什么用 Object.prototype.toString.call(obj)检测对象类型?","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://mcdowell8023.github.io/categories/基础知识/"}],"tags":[{"name":"js基础","slug":"js基础","permalink":"http://mcdowell8023.github.io/tags/js基础/"},{"name":"追本溯源","slug":"追本溯源","permalink":"http://mcdowell8023.github.io/tags/追本溯源/"},{"name":"笔记","slug":"笔记","permalink":"http://mcdowell8023.github.io/tags/笔记/"}]},{"title":"vue项目调整兼容IE8+","slug":"vue项目调整兼容IE8+","date":"2019-11-28T06:29:00.000Z","updated":"2020-03-29T10:03:45.659Z","comments":true,"path":"2019/11/28/vue项目调整兼容IE8+/","link":"","permalink":"http://mcdowell8023.github.io/2019/11/28/vue项目调整兼容IE8+/","excerpt":"","text":"记一次，vue 项目调整兼容 IE8+ 要点flex 样式兼容element UI 部分组件兼容 详细 交代说明公司项目开发接近收尾,突然硬性要求兼容 ie9。项目搭建时，采用 vue2.6 + elementUI + axios,使用大量 es6 语法（Promise），和 flex 布局。 需要面临的问题elementUI 针对 IE 部分存在兼容问题axios 针对 IE 下返回表现不同flex 只支持到 IE10Promise IE 系（不含除去 Edge） 不支持 基本兼容垫片babel-polyfill1npm install --save-dev babel-polyfill在 webpack config.js 中加入:123module.exports = &#123; entry: &#123;app: ['babel-polyfill', './src/main.js']&#125; IE 11 中接口返回值接收失败查找发现 Axios 返回值 response 的 data 是个字符串的 json。需要转换为 JavaScript 对象，才可正常读取。代码如下：1234567891011121314151617181920212223242526272829303132import axios from 'axios'import config from './config'const Axios = axios.create(config)// 用于转换为 JavaScript对象const looseJsonParse = function(obj) &#123; return Function('\"use strict\";return (' + obj + ')')()&#125;// Response 拦截器Axios.interceptors.response.use( response =&gt; &#123; var pathsearch = window.location.pathname + window.location.search if (response) &#123; var res = typeof response.data === 'string' ? looseJsonParse(response.data) : response.data switch (res.status) &#123; case '200': return res case '40001': console.log(response) return 0 default: return res &#125; &#125; &#125;, error =&gt; &#123; return error &#125;)export default Axios关于 looseJsonParse 转换为 JavaScript 对象其实也可使用 JSON.parse() 【 ie8+ 】虽然可以 eval(’(’ + obj + ‘)’)，但不建议使用由于性能和容易被劫持攻击等原因，推荐使用 looseJsonParse 方式 戳这里 插曲：eval 与 JSON.parse()详细了解？戳这里JSON.parse 只是格式化 json;要求严格的 json 格式（只能解析属性名是双引号包裹的字符串对象【key、value 都要双引号】，并会忽略换行和空格（值外面））。eval 函数可将一个 JavaScript 代码字符串求值成特定的对象，解析 json 只是其中一点功能。eval 解析 json 需要加入’()’ eg: eval(’(’ + obj + ‘)’)eval 对 josn 的格式没有特殊要求，但是会直接执行里面内容进行运算。（eval 相当于一个执行环境）eg: eval(’(’ + ‘{data:new Date()}’ + ‘)’)eval 解析 json 需要加入’( )’ 是因为eval()相当于一个执行环境，当你不加括号的时候，jsonstr1 会被认为是一条复合语句。运行的时候就会逐个字符的解析。但是加上括号的时候，jsonstr1 就当做一个表达式去运算。从括号开始就被当做了对象进行识别。 IE 9 中接口返回值的 data 为 undefined 查找发现在 Axios config 中，默认设置了 responseType: ‘json’ 。 ie9 下不支持,返回数据没有 data 字段 解决注释 // responseType: ‘json’ 就好 IE 中 elementUI 组件 bug NavMenu 导航 组件 移入下拉报错（TypeError 对象不支持此操作） 查找发现NavMenu 组件默认使用的 hover 方式不被 IE 支持 解决在对应的 el-menu 加入属性 menu-trigger=“click” mode=“horizontal”注意：文档说的很明确，menu-trigger (只在 mode 为 horizontal 时有效) IE 下 table 组件 下表格与表头错位的兼容问题 问题因为表格宽度未设置 100%，导致计算每列出现几 px 的精度差，最后导致整体样式错乱 解决全局接入 css 补丁:1234567891011body .el-table th.gutter &#123; display: table-cell !important;&#125;body .el-table colgroup.gutter &#123; display: table-cell !important;&#125;table &#123; width: 100% !important;&#125; IE 下报错 ：Unhandled promise rejection SyntaxError: 缺少 ‘;’ 或 Unhandled promise rejection SyntaxError: 缺少 ‘）’ 查找发现vue-chart 出现了兼容问题。 解决查阅文档步骤 1： npm i echarts vue-echarts -S步骤 2：npm i resize-detector -S步骤 3：当使用 Vue CLI 3+ 时，需要在 vue.config.js 中的 transpileDependencies 增加 vue-echarts 及 resize-detector，如下：1234567// vue.config.jsmodule.exports = &#123; transpileDependencies: [ 'vue-echarts', 'resize-detector' ]&#125;当使用 Vue CLI 2 的 webpack 模板时，需要按下述的方式修改 build/webpack.base.conf.js：1234567891011&#123; test: /\\.js$/, loader: 'babel-loader', - include: [resolve('src'), resolve('test')] + include: [ + resolve('src'), + resolve('test'), + resolve('node_modules/vue-echarts'), + resolve('node_modules/resize-detector') + ]&#125;还有一种方案，直接使用 echarts 兼容样式问题 问题最早使用了大量的 flex 布局，导致 IE9 无法正常显示。 解决在 index.html 中借助 “&lt;!–[if IE 9]&gt;” 来引入针对 IE9 的样式补丁，如下：1234567891011121314151617&lt;!--[if IE 9]&gt; &lt;style&gt; .flex-row-between &gt; :nth-child(1) &#123; float: left; &#125; .flex-row-between &gt; :nth-child(2) &#123; float: right; &#125; img &#123; vertical-align: middle; &#125; &lt;/style&gt;&lt;![endif]--&gt;&lt;!-- 或者，也比较建议借助link 引入补丁样式 --&gt;&lt;!--[if IE 9]&gt; &lt;link rel=\"stylesheet\" href=\"static/compatible/forIE9.css\" /&gt;&lt;![endif]--&gt; IE9、10、11、edge 下 头像裁剪上传 报错（提示对象或方法未定义）由于此处代码是同事写的，屡了下流程：通过 点击 label 标签 触发 隐藏 input file 控件，选取图片;通过 FileReader 读取文件 使用 FileReader.readAsArrayBuffer() 得到 blob 对象;使用 window.URL.createObjectURL 得到 dataUrl 喂给 vue-cropper 组件进行图片裁剪;从 vue-cropper 裁剪后，返回得到 base64，通过 new File() 转换为 file 文件; // 或者 blob 对象使用 formData 发送给后台;后台返回成功后，修改页面头像，流程完毕。了解到都使用哪些东西，还需要了解下基本知识。MDN 下了 File、 blob、URL.createObjectURL技术实现采用了一些比较高级的 api ，对于 IE 来讲不是太友好，总结如下：浏览器FileblobcreateObjectURLnew File(转换为 File 文件)IE9NONONONOIE10YESYESYESNOIE11YESYESYESNOEdgeYESYESYESNO看起来情况不太乐观。那么，一个一个解决。 IE9 下头像上传从上面看来，IE9 不支持高级 api ，原来的整套应该全部不适用。果然，从 第一步 获取文件就在报错。 input file 控件 的 target.files 是 udefined。难道无法拿到文件？补习了下：IE9 获取 File 文件对象前端图片预览，上传前预览，兼容 IE7、8、9、10、11，Firefox，Chrome得到如下信息：低版本 IE 由于 JS 安全问题，不允许 JS 访问本地文件,所以无法获取 files对于低版本的 IE 可以使用 ActiveXObject 获取文件对象, 但是默认情况下ActiveXObject 为不可用的, 所以要想使用此对象要先启用设置, 即:Tools(工具) / Internet options(选项) / Security(安全) / Custom level(自定义级别)找到&quot;Initialize and script ActiveX controls not marked as safe for scripting&quot;设置为&quot;Enable(not secure)&quot;即可.获取文件路径出于安全性的考虑，低版本 IE 上传文件时屏蔽了真实的本地文件路径,以 C:\\fakepath**取而代之, 所以默认情况下通过 fileEle.value 不能获取到文件的真实路径.如果想获取真实路径, 有两种方式:通过设置 IE 的安全设置, 即:Tools(工具) / Internet options(选项) / Security(安全) / Custom level(自定义级别)找到&quot;Include local directory path when uploading files to a server&quot;设置为的&quot;Enable&quot;使用 JS 获取, 即:fileEle.select().blur();var filePath = document.selection.createRange().text;然后试了下 在 IE 下使用 ActiveXObject 读取文件。然后读取文件还要设置【⊙﹏⊙b 汗】，放弃。与产品沟通了下。本着华丽升级，优雅降级的原则【好吧，就是我也没有办法】。IE9 下可以取消裁剪。先科普下兼容 ie9 文件上传，解决 ie9 下提示下载或保存HTML5 file 对象和 blob 对象的互相转换js blob 转 FileConvert blob to fileHTML 利用 meta 标签设置 IE 文档模式及相关知识拓展","categories":[{"name":"项目改造","slug":"项目改造","permalink":"http://mcdowell8023.github.io/categories/项目改造/"}],"tags":[{"name":"兼容","slug":"兼容","permalink":"http://mcdowell8023.github.io/tags/兼容/"},{"name":"vue","slug":"vue","permalink":"http://mcdowell8023.github.io/tags/vue/"}]},{"title":"docker笔记-基础篇","slug":"docker笔记-基础篇","date":"2019-10-28T02:24:19.000Z","updated":"2020-04-22T08:24:05.227Z","comments":true,"path":"2019/10/28/docker笔记-基础篇/","link":"","permalink":"http://mcdowell8023.github.io/2019/10/28/docker笔记-基础篇/","excerpt":"","text":"本文仅以前端视角，接触使用 docekr。认识较为肤浅，大神请绕行。关于 DockerDocker 是啥Docker 主要用途Docker 中的概念安装慢？！修改镜像源地址基本操作镜像操作检索拉取镜像新增 镜像删除 镜像修改 镜像 名称查看 镜像导入、导出、上传 镜像容器操作新增容器删除 容器修改 容器 状态进入 容器查看 容器器与主机之间的数据拷贝导入、导出 容器 关于 Docker Docker 是啥Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。它是目前最流行的 Linux 容器解决方案。 Docker 主要用途提供一次性的环境。比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。提供弹性的云服务。因为 Docker 容器可以随开随关，很适合动态扩容和缩容。组建微服务架构。通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。以上摘自阮老师博客 Docker 中的概念镜像（image）: 镜像中包含有需要运行的文件。镜像用来创建 container，一个镜像可以运行多个 container；镜像可以通过 Dockerfile 创建，也可以从 Docker hub/registry 上下载。容器（container）: 容器是 Docker 的运行组件，启动一个镜像就是一个容器，容器是一个隔离环境，多个容器之间不会相互影响，保证容器中的程序运行在一个相对安全的环境中。仓库（repository）: 共享和管理 Docker 镜像，用户可以上传或者下载上面的镜像，官方地址为 https://registry.hub.docker.com/（类似于 github 对源代码的管理），也可以搭建自己私有的 Docker registry。以上摘自Ant Design Pro 的 Docker 部署方式从我的角度，使用 docker 常常是要解决宿主依赖环境的问题。比如：我是个前端开发从业者，可能有些时候需要在本地 查看 打包编译后的项目真实表现。以前需要本地安装一个 Nginx 配好文件，然后启动。现在，只需要编写好 dockerfile 文件，直接输入命令，就可以在本地查看项目。再者，搭建较为复杂的环境（依赖因为网络等问题过于缓慢），不同开发者需要安装很多东西，不便捷。如，搭建一个 gitbook 文档项目（支持多个文档），从 nodejs ,gitbook, gitbookcli 等比较多的依赖全局安装后，还需要安装 gitbook 的插件（比较慢，而且还没有较快的国内镜像），才可本地启动。毕竟项目本身只是辅助编写文档，因为环境问题给团队带来困扰，就得不偿失了。 如果，将项目的依赖环境做成镜像，放到自己的内部服务器上，每个需要启动项目的人直接使用 docker 镜像，那么基本无痛启动项目。 安装安装系统推荐使用 Mac 或者 Linux。Windows 不建议使用。《菜鸟教程》的 Docker Windows 安装中说的 Docker toolbox（老黄历） 已经无法使用了。官方推荐 安装 Docker desktop，需要系统是专业版的。（而且折腾一番，及时能用，跑别人写的 Dockerfile 还会碰到问题。过于折腾，本末倒置。）Mac 或 Windows 安装软件地址安装教程：Mac 安装ubuntu 安装Windows 安装1234567# 查看版本 验证成功docker version# 把用户加入 Docker 用户组 避免每次命令都输入sudosudo usermod -aG docker $USER# 启动一个Nginx 验证效果 正常浏览器输入http://localhost/即可访问docker run --detach --publish=80:80 --name=webserver nginx 慢？！修改镜像源地址Docker 修改镜像源地址如果是 dockerDesktop 进入设置，找到 Daemon 选项，修改 registry-mirrors 选项为：'http://hub-mirror.c.163.com’ [这个是网易的加速镜像]，然后 apply &amp;&amp; startinsecure registry 一般 是公司搭建的私服使用 基本操作 镜像操作 检索拉取镜像1234# 1. 检索镜像 或去 &lt;https://hub.docker.com&gt; 进行搜索docker search &lt;Images Name&gt;# 2. 从仓库中拉取 镜像 到本地docker pull &lt;Images Name:tag-缺省为latest&gt;非官方下载 需要加上 仓库地址。如从网易蜂巢的镜像源来下载 ubuntu:18.04 镜像，可以使用如下命令，此时下载的镜像名称为 hub.c.163.com/public/ubuntu:18.04 新增 镜像根据现有容器生成镜像12345678# OPTIONS# -a: 作者信息；# -c: 提交时执行dockerfile指令，包含CMD等# -m: 提交消息# -p: 提交暂停容器运行docker commit [OPTIONS] CONTAINER [镜像名称[:TAG]]# 常用方式 填写信息 作者 镜像名称（不包含大写）docker commit -m'提交消息' -a '作者' &lt;容器ID&gt; &lt;Images Name:tag&gt;本地模版导入123456# OPTIONS# -c: 提交时执行dockerfile指令，包含CMD等# -m: 提交消息docker import [OPTIONS] file|URL|- &lt;Images Name:tag&gt;# eg:cat exampleimage.tgz | docker import - exampleimagelocal:new基于 dockerfile 创建12345678910# 编写好 dockerfile 后 进行build# OPTIONS# --file , -f Dockerfile的名称（默认为“ PATH / Dockerfile”）# --tag , -t 名称以及“ name：tag”格式的标签（可选）docker build [OPTIONS] &lt;Dockerfile的 PATH | URL | - &gt;# eg:# 使用URL github.com/creack/docker-firefox 的 Dockerfile 创建镜像。docker build github.com/creack/docker-firefox# 使用根目录下的 Dockerfile 创建名称为 lanjiang/gitbook 的镜像docker build -t lanjiang/gitbook . 删除 镜像docker rmi 删除123456# 删除 镜像 (没有使用该镜像的容器 才可删除，不推荐强制删除)docker rmi [-f: 强制删除] &lt;Images Name/ids&gt;# 筛选包含 none 的镜像删除docker rmi $(docker images | grep \"none\" | awk '&#123;print $3&#125;')# 删除全部镜像docker rmi $(docker images -a -q)docker image prune 清除没有被使用的镜像123456# 清除没有被使用的镜像# OPTIONS:# -a 删除所有无用镜像（不光临时镜像）；# -filter filter:只清理给定过滤的镜像；# -f,-force:强制删除docker image prune [OPTIONS] 修改 镜像 名称12# 给镜像添加标签docekr tag &lt;Images Name/id&gt; &lt;new Images Name&gt; 查看 镜像12345# 查看 本地镜像docker images / docker image ls# 查看 本地全部镜像（包含临时镜像）docker images -a 导入、导出、上传 镜像123456# 镜像 导出 和 载入docker save -o &lt;导出名称&gt; &lt;Images Name:tag&gt;# 将镜像 node 生成 /Users/mcdowell/Downloads/ 下的dockderApp.tardocker save -o /Users/mcdowell/Downloads/dockderApp.tar node# ordocker save node &gt; /Users/mcdowell/Downloads/dockderApp11.tar1234# 将/Users/mcdowell/Downloads/ 下的tf-keras.tar 镜像 导入镜像docker load -i /Users/mcdowell/Downloads/tf-keras.tar# ordocker load &lt; /Users/mcdowell/Downloads/tf-keras.tar12# 上传镜像docker push [OPTIONS] NAME[:TAG]123456789# eg:# 本地生成镜像docker commit c16378f943fe rhel-httpd# 给刚生成的镜像打上 源标签docker tag rhel-httpd registry-host:5000/myadmin/rhel-httpd# 上传镜像docker push registry-host:5000/myadmin/rhel-httpd# 如果是官网仓库 （官方仓库省略源地址）docker push myadmin/rhel-httpd 容器操作 新增容器新建123456789101112131415161718192021222324252627# 新建 容器（默认是停止的）docker create &lt;Images Name:version /ID&gt;# 用 XX镜像 新建容器 并启动 （ docker create + docker start ）# OPTIONS 常用说明# -d: 后台运行容器，并返回容器ID；# -i: 以交互模式运行容器，通常与 -t 同时使用；# -P: 随机端口映射，容器内部端口随机映射到主机的高端口# -p: 指定端口映射，格式为：主机(宿主)端口:容器端口# -t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；docker run [OPTIONS] &lt;Images Name:version&gt; [COMMAND] [ARG...]# 用 node 镜像 以交互模式终端 新建容器 并启动docker run -it node bash# 用 ubuntu:18.04 镜像 以交互模式终端 新建容器 并启动docker run -it ubuntu:18.04 /bin/bash# 进入交互模式 使用ctrl+d 或者 exit 退出# 用 lanjiang/gitbook镜像 新建容器 并启动 映射到 80 端口docker run -p 80:80 lanjiang/gitbook# 用 nginx镜像 以守护进行（后台运行）的方式 新建容器 并启动 映射到 80 端口 --默认返回ID号docker run -d -p 80:80 nginx# 使用docker镜像nginx:latest 以后 随机端口 台模式 启动一个容器,并将容器命名为mynginx【需要使用docker port 才可访问】docker run -P -d --name mynginx nginx:latest 删除 容器docker rm 删除1234567# 删除容器 id可以是多个 （容器必须终止才能删除）docker rm &lt;IDs&gt;# 筛选包含 gitbook 的容器删除docker rm $(docker ps -a|grep gitbook|awk '&#123;print $1&#125;')# 删除 全部容器docker rm $(docker ps -a -q)docker container prune 删除12345# 删除暂停的容器# OPTIONS# --filter 提供过滤器值（例如'until ='）# --force , -f 强制删除，不提示docker container prune [OPTIONS] 修改 容器 状态启动、重启12345# 启动 容器docker start &lt;Images Name:version /ID&gt;# 重启 容器docker restart &lt;ID&gt;暂停\\恢复 容器 (保存容器状态）1234# 暂停 容器docker pause &lt;ID&gt;# 恢复 容器docker unpause &lt;ID&gt;终止容器1234# 终止容器 id可以是多个 kill 也可以docker stop &lt;IDs&gt;# 筛选包含 gitbook 的容器终止docker stop $(docker ps -a|grep gitbook|awk '&#123;print $1&#125;') 进入 容器docker attach 进入 容器12345# 默认 CTRL-c不退出当前终端而是 给容器内 程序执行docker attach [OPTIONS] &lt;container Name/ID&gt;# 使用 --sig-proxy=false 避免上述问题docker attach --sig-proxy=false mynginx# 缺点：多个窗口执行时，一个窗口阻塞，其他窗口无法执行docker exec 进入 容器1234567891011# 使用 exec 进入容器#OPTIONS说明：# -d :分离模式: 在后台运行# -i :即使没有附加也保持STDIN 打开# -t :分配一个伪终端docker exec [OPTIONS] &lt;container Name/ID&gt; [\b命令] [ARG...]# 在容器 mynginx 中以交互模式执行容器内 /root/blue.sh 脚本:docker exec -it mynginx /bin/sh /root/blue.sh# 在运行的容器中 以 以交互模式终端 执行 bash 命令docker exec -it &lt;container Name/ID&gt; /bin/bash 查看 容器查看本地容器1234567# 输出 ID容器的 日志docker logs &lt;ID&gt;# 查看 运行的 容器docker ps# 查看全部容器（包含运行和暂停的）docker ps -a # -q:只显示ID查看容器内部信息123456789101112# 查看容器详情docker inspect &lt;container Name/ID&gt;# 查看容器内 进程（容器需要启动）docker top &lt;container Name/ID&gt;# 查看统计信息 （cpu 内存 存储 网络使用情况）docker stats &lt;container Name/ID&gt;# 查看系统变更docker diff &lt;container Name/ID&gt;# 查看 容器 端口映射docker port &lt;container Name/ID&gt; 器与主机之间的数据拷贝12345678# 容器与主机之间的数据拷贝docker cp &lt;path&gt; &lt;path&gt;# 将主机/www/blue目录拷贝到容器63d47d7c0d4c的/www目录下。docker cp /www/blue 63d47d7c0d4c:/www/# 将主机/www/blue目录拷贝到容器 63d47d7c0d4c中，目录重命名为www(此处无斜杠))docker cp /www/blue 63d47d7c0d4c:/www# 将容器 63d47d7c0d4c 的 /www 目录拷贝到主机的 /tmp 目录中。docker cp 63d47d7c0d4c:/www /tmp/ 导入、导出 容器123456# 容器导出docker export -o tf-keras-33f6c8359187.tar &lt;container Name/ID&gt;# ordocker export 33f6c8359187 &gt; tf-keras-33f6c8359187.tar# 导入docker import tf-keras-33f6c8359187.tar与镜像导出（docker save）比较：容器快照文件 将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积更大","categories":[{"name":"工具","slug":"工具","permalink":"http://mcdowell8023.github.io/categories/工具/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://mcdowell8023.github.io/tags/笔记/"},{"name":"Docker","slug":"Docker","permalink":"http://mcdowell8023.github.io/tags/Docker/"}]},{"title":"浏览器全屏api--fullScreen","slug":"浏览器全屏api-fullScreen","date":"2019-09-24T07:40:35.000Z","updated":"2020-03-29T10:00:02.803Z","comments":true,"path":"2019/09/24/浏览器全屏api-fullScreen/","link":"","permalink":"http://mcdowell8023.github.io/2019/09/24/浏览器全屏api-fullScreen/","excerpt":"","text":"fullScreen 浏览器 全屏 api本文转载 Fullscreen API工作开发中遇到需要浏览器 全屏。查询 api 后，决定使用 requestFullscreen，但是 api 存在兼容问题。借助大佬的总结： 启动全屏模式12345678910111213141516// 处理兼容性 调用 全屏apifunction launchIntoFullscreen(element) &#123; if (element.requestFullscreen) &#123; element.requestFullscreen() &#125; else if (element.mozRequestFullScreen) &#123; element.mozRequestFullScreen() &#125; else if (element.webkitRequestFullscreen) &#123; element.webkitRequestFullscreen() &#125; else if (element.msRequestFullscreen) &#123; element.msRequestFullscreen() &#125;&#125;// 开启全屏 模式 谷歌浏览器 、安卓手机 亲测可用launchIntoFullscreen(document.documentElement) // 整个页面launchIntoFullscreen(document.getElementById('videoElement')) // 或者任意对象 退出全屏模式12345678910// 退出全屏function exitFullscreen() &#123; if(document.exitFullscreen) &#123; document.exitFullscreen(); &#125; else if(document.mozCancelFullScreen) &#123; document.mozCancelFullScreen(); &#125; else if(document.webkitExitFullscreen) &#123; document.webkitExitFullscreen(); &#125;&#125; 全屏属性和事件document.fullScreenElement：已推送到全屏状态的元素。document.fullScreenEnabled：说明当前是否启用了全屏。123456789/* 兼容写法 */var fullscreenElement = document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElementvar fullscreenEnabled = document.fullscreenEnabled || document.mozFullScreenEnabled || document.webkitFullscreenEnabled实际使用12345678910111213// 添加事件监听document.addEventListener('fullscreenchange', function(e) &#123; console.log('fullscreenchange event! ', e)&#125;)document.addEventListener('mozfullscreenchange', function(e) &#123; console.log('mozfullscreenchange event! ', e)&#125;)document.addEventListener('webkitfullscreenchange', function(e) &#123; console.log('webkitfullscreenchange event! ', e)&#125;)document.addEventListener('msfullscreenchange', function(e) &#123; console.log('msfullscreenchange event! ', e)&#125;) 全屏 CSS1234567891011121314151617181920212223242526272829303132333435:-webkit-full-screen &#123; /* properties */&#125;:-moz-full-screen &#123; /* properties */&#125;:-ms-fullscreen &#123; /* properties */&#125;:full-screen &#123; /*pre-spec */ /* properties */&#125;:fullscreen &#123; /* spec */ /* properties */&#125;/* deeper elements */:-webkit-full-screen video &#123; width: 100%; height: 100%;&#125;/* styling the backdrop*/::backdrop &#123; /* properties */&#125;::-ms-backdrop &#123; /* properties */&#125; 实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" /&gt; &lt;title&gt;全屏api测试页面&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div style=\"padding:20px;\"&gt; &lt;button onclick=\"launchFullscreen(document.documentElement);\" class=\"sexyButton\" &gt; 启动全屏 &lt;/button&gt; &lt;button onclick=\"exitFullscreen();\" class=\"sexyButton\"&gt;关闭全屏&lt;/button&gt; &lt;button onclick=\"dumpFullscreen();\" class=\"sexyButton\"&gt; 转储全屏属性数据 &lt;/button&gt; &lt;/div&gt; &lt;!-- 谷歌浏览器 、安卓手机 亲测可用 --&gt; &lt;style&gt; /* 全屏后 样式 */ :-webkit-full-screen &#123; background: pink; &#125; :-moz-full-screen &#123; background: pink; &#125; :-ms-fullscreen &#123; background: pink; &#125; :full-screen &#123; /*pre-spec */ background: pink; &#125; :fullscreen &#123; /* spec */ background: pink; &#125; &lt;/style&gt; &lt;script&gt; // 处理兼容性 调用 全屏api function launchFullscreen(element) &#123; if (element.requestFullscreen) &#123; element.requestFullscreen() &#125; else if (element.mozRequestFullScreen) &#123; element.mozRequestFullScreen() &#125; else if (element.webkitRequestFullscreen) &#123; element.webkitRequestFullscreen() &#125; else if (element.msRequestFullscreen) &#123; element.msRequestFullscreen() &#125; &#125; // 退出全屏 function exitFullscreen() &#123; if (document.exitFullscreen) &#123; document.exitFullscreen() &#125; else if (document.mozCancelFullScreen) &#123; document.mozCancelFullScreen() &#125; else if (document.webkitExitFullscreen) &#123; document.webkitExitFullscreen() &#125; &#125; function dumpFullscreen() &#123; console.log( 'document.fullscreenElement is: ', document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement ) console.log( 'document.fullscreenEnabled is: ', document.fullscreenEnabled || document.mozFullScreenEnabled || document.webkitFullscreenEnabled || document.msFullscreenEnabled ) &#125; // 添加事件监听 document.addEventListener('fullscreenchange', function(e) &#123; console.log('fullscreenchange event! ', e) &#125;) document.addEventListener('mozfullscreenchange', function(e) &#123; console.log('mozfullscreenchange event! ', e) &#125;) document.addEventListener('webkitfullscreenchange', function(e) &#123; console.log('webkitfullscreenchange event! ', e) &#125;) document.addEventListener('msfullscreenchange', function(e) &#123; console.log('msfullscreenchange event! ', e) &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"拓展","slug":"拓展","permalink":"http://mcdowell8023.github.io/categories/拓展/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://mcdowell8023.github.io/tags/浏览器/"},{"name":"api","slug":"api","permalink":"http://mcdowell8023.github.io/tags/api/"}]},{"title":"ant-design踩坑：Cascader级联选择","slug":"ant-design踩坑-Cascader级联选择","date":"2019-09-03T11:33:33.000Z","updated":"2020-03-29T09:59:54.841Z","comments":true,"path":"2019/09/03/ant-design踩坑-Cascader级联选择/","link":"","permalink":"http://mcdowell8023.github.io/2019/09/03/ant-design踩坑-Cascader级联选择/","excerpt":"","text":"Cascader 级联选择 遇到的问题 要点级联选择 数据中 isLeaf: false 可以控制是否选中【false 表示不选中】，触发 loadData 函数级联选择 数据中 如果当前层不是最终级【就是你要 id 的那层】，children 一定不能为[],否则会导致组件选中错误层级，不会触发 loadData 函数 详细 交代说明 公司开发后台管理系统，涉及一个地级区域选择的功能，实现效果如下 后台给的接口是根据参数查询省，然后市…,如下 查看官网文档通过官网示例，了解到 采用 动态加载选项 示例的方式，使用 loadData 实现动态加载选项。按照官网的介绍，结合实际接口，我们需要 每次动态修改 根据返回 数据进行 数据拼接。 编码当然后台数据返回的字段与组件预制不同，我们可以借助 fieldNames 属性进行自定义字段。编码 测试组件 时候，你会发现点击第一层的数据就会直接选中【我们要的是最后一层，通信商的 id】。查阅属性说明未果。但是通过示例后发现，数据中 isLeaf: false 可以控制是否选中，从而触发 loadData。貌似准备就绪。然后，愉快的编码点击非 type 是 3 的一层，进行接口调用1234567891011121314151617// Cascader loadData 事件 函数 查询数据const cascaderLoadData = selectedOptions =&gt; &#123; // 点击得到的 一级 或 二级 数据 const targetOption = selectedOptions[selectedOptions.length - 1] const &#123; id, type &#125; = targetOption targetOption.loading = true const newType = type + 1 if (type !== 3) &#123; // 一级 或 二级 数据 // 这里是调用 查询地区接口的函数 getDict(&#123; [newType === 2 ? 'regionId' : 'cityId']: id, webId: id, type: newType &#125;) &#125;&#125;数据拼接,上代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// 这里是 得到后台返回数据 在 reducers 的 数据动态拼接处理// 提供 Cascader optionssaveVPNAddressDict(state, action) &#123; const &#123; params: &#123; type, webId &#125;, res, &#125; = action.payload; const &#123; VPNAddressDict &#125; = state; const pushList = (arr, typeNum) =&gt; &#123; return arr ? arr .map(item =&gt; &#123; if (!item) &#123; return null; &#125; return &#123; ...item, loading: false, isLeaf: typeNum === 3, // 用于控制非 第三层 不能选 children: null, &#125;; &#125;) .filter(item =&gt; item) : []; &#125;; let dicts = []; const dict = pushList(res, type); // 基本思路就是： 根据type 确定层级 当前数据该是第几层 根据 webId 找到应该对应的 数据对象 switch (type) &#123; case 1: // 查询省数据 dicts = [...dict]; break; case 2: // 查询市数据 dicts = VPNAddressDict.map(item =&gt; &#123; if (item.id === webId) &#123; return &#123; ...item, loading: false, children: [...dict], &#125;; &#125; return item; &#125;); break; case 3: // 运营商数据 dicts = VPNAddressDict.map(items =&gt; &#123; const list = items &amp;&amp; items.children ? items.children : []; const children = list.map(item =&gt; &#123; if (item.id === webId) &#123; return &#123; ...item, loading: false, children: [...dict], &#125;; &#125; return item; &#125;); return &#123; ...items, loading: false, isLeaf: false, children, &#125;; &#125;); break; default: dicts = []; break; &#125; return &#123; ...state, VPNAddressDict: dicts, &#125;;然后按照示例使用组件基本完成后。测试发现，如果你依次点击 【 广东 &gt; 广州 &gt; 移动 】（ 选中最后一层），再次选择 【北京】 组件直接选中了 【北京】（直接选中第一层）。多次测试发现只要不点击最后一层，那么不会出现这个问题。分析：根据 bug 出现的情况，可以判断，是执行了 saveVPNAddressDict 动态拼接函数 type= 3 的运营商数据拼接出现的问题。检查代码未发现明显错误。通过打印数据发现，【北京】数据的 children 是个空数组。 凭借多年开发的直觉[🤦‍ 好吧，我也不知道我是怎么知道的]，推测 children 数据问题。验证：自造一条假数据，直接给组件测试使用。数据如下1234567891011121314const options = [ &#123; value: '北京', label: '北京', isLeaf: false, children: [] &#125;, &#123; value: '广东', label: '广东', isLeaf: false, children: [] &#125;]验证结果发现，children 字段如果是数组，会导致直接选中，不会触发 loadData。8.修正。那么在函数执行时候，如果没被选中的 children 显示为 null。 修正如下1234567891011121314151617181920212223// saveVPNAddressDict case 3的代码片段case 3: // 运营商数据 dicts = VPNAddressDict.map(items =&gt; &#123; const list = items &amp;&amp; items.children ? items.children : []; const children = list.map(item =&gt; &#123; if (item.id === webId) &#123; return &#123; ...item, loading: false, children: [...dict], &#125;; &#125; return item; &#125;); return &#123; ...items, loading: false, isLeaf: false, children:children.length?children:null, &#125;; &#125;); break; 总结级联选择 数据中 isLeaf，children 两个字段直接影响 是否被选中，loadData 是否会触发。","categories":[{"name":"踩坑","slug":"踩坑","permalink":"http://mcdowell8023.github.io/categories/踩坑/"}],"tags":[{"name":"ant-design","slug":"ant-design","permalink":"http://mcdowell8023.github.io/tags/ant-design/"},{"name":"踩坑","slug":"踩坑","permalink":"http://mcdowell8023.github.io/tags/踩坑/"},{"name":"react","slug":"react","permalink":"http://mcdowell8023.github.io/tags/react/"}]},{"title":"git 学习笔记","slug":"git-学习笔记","date":"2019-08-28T08:37:24.000Z","updated":"2020-03-29T09:59:30.671Z","comments":true,"path":"2019/08/28/git-学习笔记/","link":"","permalink":"http://mcdowell8023.github.io/2019/08/28/git-学习笔记/","excerpt":"","text":"目录目录安装 git初始化基本配置配置帐号信息配置别名查看配置参数说明生成 shh 密钥获取 Git 仓库在现有目录中初始化仓库克隆现有的仓库本地已有构建的项目不进行版本控制添加不进行版本控制的文件目录提交 commit 后，想再忽略一些已经提交的文件常见操作查看信息查看帮助 git help查看状态 git status查看变化 git diff查看日志 git log查看某个文件的版本历史 git show图形化查看提交内容 gitk更新文件重命名文件删除提交撤销&amp;回滚简单总结撤销修改文件 尚未提交修改文件 已经提交（git commit）到 本地仓库回滚还原 远端服务器 提交的代码删除最后一次远程提交回滚某次提交删除某次提交操作标签创建标签查看标签删除标签操作分支查看分支新建分支提交到远程分支删除分支合并分支暂存分离头【detached HEAD】操作子仓库常用命令详解git pull 详解git fetch 详解git add 详解git commit 详解git remote 详解git push 详解语法示例完整示例本地分支名 缺省本地分支、远程分支都 缺省远程主机名、本地分支、远程分支都 缺省simple 方式 和 matching 方式git branch 详解语法示例git checkout 详解例子git reset 详解git cherry-pick 详解git submodule 详解git 原理git 工作解析图git 文件目录commit 与 tree 和 blob 的关系git 注意事项常见缩写 安装 git已有？请跳过git 文档地址git 下载地址查看 git 版本1git --version 初始化 基本配置 配置帐号信息1234# 设置 [本仓库 | 全局 | 系统 ] 的 用户名称$ git config [--local | --global | --system] user.name 'Your name'# 设置 [本仓库 | 全局 | 系统 ] 的 用户邮箱$ git config [--local | --global | --system] user.email 'Your email'当然你也可以通过修改 .git 文件目录下面的 config 文件进行修改 配置别名12345# 配置别名$ git config --global alias.st status # git st$ git config --global alias.co checkout # git co$ git config --global alias.br branch # git br$ git config --global alias.ci commit # git ci 查看配置1234# 查看配置git config --list [--local | --global | --system]# 根据git哈希值 查看内容 / 查看类型git cat-flie [-p / -t] 参数说明local：区域为本仓库global: 当前用户的所有仓库system: 本系统的所有用户缺省等同于 local优先级：local &gt; global &gt; system 生成 shh 密钥如果你想通过 https 的方式 每次提交输入密码，当然可以跳过此节检查是否已经存在公私钥1234# 查看.ssh目录下是否有密钥 如列表中包含 id_rsa和id_rsa.pub 说明电脑中已经存在公私钥ls -al ~/.ssh# cat ~/.ssh/id_rsa.pub生成密钥123456# 生成秘钥（根据电脑主机）$ ssh-keygen -t rsa# 根据邮箱生成 密钥$ ssh-keygen -t rsa -C \"youremail\"# 执行后 ：建议不要输入，一路回车，生成的 id_rsa 是私钥 生成的 id_rsa.pub 是公钥添加 密钥在对应服务器增加密钥。【github -&gt; setting -&gt; SSH and GPG keys】如果公司是自己搭建的 git 服务（未使用 gitlab），则交给管理员添加。如果使用 gitlab 在设置增加密钥 获取 Git 仓库 在现有目录中初始化仓库12345678910111213# 初始化本地仓库 缺省 为当前目录$ git init ['your_project'/缺省]# git init --bare 建立裸仓库【中心仓库】# 获取状态$ git status# .或*代表全部添加$ git add [file1] [file2] ...# 提交$ git commit -m \"提交message\"# 添加远程源$ git remote add origin [远程地址]# push 同时 设置默认跟踪分支$ git push -u origin master 克隆现有的仓库1234# 克隆远程仓库到本地 fileName 的文件夹内 【缺省-默认远端名称】$ git clone [url] &lt;fileName/缺省&gt;# 克隆 为 裸仓库【中心仓库】$ git clone --bare [ 连接地址 ] &lt; file bf名称 &gt;从裸仓库 clone 下来的本地仓库可以进行正常的 push 操作， 但是从一般仓库 clone 下来的本地仓库却不行。 这也正是裸仓库存在的意义。 裸仓库一般情况下是作为远端的中心仓库而存在的。 本地已有构建的项目12345678$ git remote -v #查看远程版本库信息$ git remote add github &lt;url&gt; #添加github远程版本库$ git fetch github #拉取远程版本库$ git merge -h #查看合并帮助信息$ git merge --allow-unrelated-histories github/master# or git pull origin master --allow-unrelated-histories# 对github上的master分支与本地master分支进行合并（两分支不是父子关系，所以合并需要添加 --allow-unrelated-histories）$ git push github #推送同步到github仓库 不进行版本控制 添加不进行版本控制的文件目录项目目录下 新建 .gitignore 文件 ，写入不需要进行版本控制的文件名或文件夹1234567891011121314# 文件示例node_modules # 对 node_modules文件夹及其文件 及 node_modules文件 不进行版本控制doc # 对 [doc文件夹及其子文件 和 名称为doc的文件] 不进行版本控制*doc # 不允许 任何 包含doc字符的 文件夹及其子文件 和 文件（包括.扩展名）不进行版本控制doc/ # 对 [doc文件夹及其下文件] 不进行版本控制*doc/ # 对 [任何 包含doc字符的文件夹及其下文件] 不进行版本控制*.md // 对 .md结尾的文件 不进行版本控制# /* 复合示例 */doc!doc/* # git管doc文件夹，不管doc文件 提交 commit 后，想再忽略一些已经提交的文件把忽略的文件添加到 .gitignore;通过 git rm --cached &lt; file &gt;的方式删除掉 git 仓库里面无需跟踪的文件。你需要确认 的 云端源 也要删除git commit -m 'delete git remote somefile'git push 常见操作 查看信息 查看帮助 git help12345678# 所有可用的命令都将打印在标准输出上$ git help [--all/-a]# 在标准输出中也会列出有用的Git指南$ git help [--guide/-g]# 显示 git 手册页$ git help git 查看状态 git statusgit status 命令用于显示工作目录和暂存区的状态。git status 不显示已经 commit 到项目历史中去的信息。看项目历史的信息要使用 git log常用于 git commit 之前, 这样能防止你不小心提交了您不想提交的东西。1234567# 显示工作目录和暂存区的状态$ git status# 只列出所有已经被git管理的且被修改但没提交的文件$ git status -uno# 紧凑的格式输出$ git status -s # or $ git status --short 查看变化 git diff对比 修改之后还没有暂存起来的内容变化123456789101112131415161718192021222324252627282930313233343536# 工作树中的更改尚未分段进行下一次提交$ git diff# 比较当前文件和暂存区文件差异 git diff$ git diff &lt;file&gt;$ git diff &lt;id1&gt;&lt;id1&gt;&lt;id2&gt; # 比较两次提交之间的差异$ git diff &lt;branch1&gt; &lt;branch2&gt; # 在两个分支之间比较$ git diff --staged # 比较暂存区和版本库差异$ git diff --cached # 比较暂存区和版本库差异$ git diff --stat # 仅仅比较统计信息$ git diff HEAD # 显示工作版本(Working tree)和HEAD的差别$ git diff test # 查看当前目录和另外一个分支(test)的差别# 假定：HEAD、缓存区、工作区中的readme.md文件内容均不相同。# 比较 工作区 &lt;===&gt; HEAD$ git diff HEAD -- readme.md# 比较 工作区 &lt;===&gt; 缓存区$ git diff -- readme.md# 比较 缓存区 &lt;===&gt; HEAD$ git diff --cached -- readme.md# 比较两个提交或分支的差异$ gti diff [分支名称/commit-id] [分支名称/commit-id] --&lt; file &gt;# 对比两个版本的不同$ git diff [commit号] [commit号]# 对比 当前提交版本与上次提交$ git diff HEAD HEAD^[同 HEAD～1]# 对比当前提交版本与上上次（前两次）提交$ git diff HEAD HEAD^^[同HEAD～2]补充说明：一个节点，可以包含多个子节点（checkout 出多个分支）一个节点可以有多个父节点（多个分支合并）是~都是父节点，区别是跟随数字时候，2 是第二个父节点，而~2 是父节点的父节点^和~可以组合使用,例如 HEAD~2^2 查看日志 git log1234567891011121314# 查看所有分支的历史 git log 等同于它$ git log --all# 查看图形化的 log 地址$ git log --all --graph# 查看单行的简洁历史。$ git log --oneline# 查看最近的四条简洁历史。$ git log --oneline -n4#查看所有分支最近 4 条单行的图形化历史。$ git log --oneline --all -n4 --graph# 跳转到git log 的帮助文档网页$ git help --web log$ git log -1 // 最近一次提交信息 查看某个文件的版本历史 git show1234// 先查看文件提交历史git log --pretty=oneline [文件名或文件路径] // 例如src/AfterView/common/commonStream.vuegit show [版本号] // 显示具体的某次的改动的修改 图形化查看提交内容 gitk1234# 在当前目录下输入，弹出图形化界面$ gitk$ gitk --all定制化图形界面 ： view --&gt; new view [勾选 all refs] # 显示全部分支 更新使用 git pull 进行更新1234# 按照git branch 设置的默认跟踪的服务器和分支来拉取$ git pull# 实例：拉取远程服务器origin的master分支$ git pull origin master使用 git fetch 进行更新12345678# 将远程仓库的master分支下载到本地当前branch中$ git fetch orgin master# 比较本地的master分支和origin/master分支的差别 $ git log -p master ..origin/master # 进行合并$ git merge origin/master 文件重命名先删除文件再添加文件123456# 重命名3步骤 eg: 重命名 readme 为 readme.md$ mv [文件名1] [文件名2] # 重命名文件名1为文件名2$ git add ['文件名'] # 添加新文件 eg: git add readme.md$ git rm ['文件名'] # 删除旧文件 eg: git rm readme# 就可以正常commit直接使用 git 命令123$ git mv ['旧文件名'] ['新文件名'] # git重命名（相当于上面三个步骤）# 就可以正常commit12345# 回滚到对版本号的应提交状态【缺省回滚到最近的一次提交】$ git reset --hard [提交版本号|缺省]# 记录所有HEAD的历史，也就是说当你做reset，checkout等操作的时候，这些操作会被记录在reflog中$ git reflog 文件删除先删除文件再添加文件1234$ rm &lt;file&gt; # 删除文件$ git add ['文件名'] # 添加新文件 eg: git add readme.md# 就可以正常commit直接使用 git 命令12# 删除工作区，暂存区 的文件$ git rm &lt;file&gt;如果删除出错 借助 git reset --hard 进行撤销 提交1234567891011121314151617181920# 添加新文件$ git add ['文件名' | '.'代表全部]# 查看提交状态【是否有未提交】（不必的） but 能防止你不小心提交了您不想提交的东西# $ git status # 没有未提交的显示 nothing to commit# 提交填写日志$ git commit -m'这里填写提交日志'# 如果发现点问题，那么继续进行了修改# 继续执行 git add . 重新提交，会覆盖上次提交，只以当前为准# $ git commit --amend# 查看日志(不必的)# $ git log# 更新 先更新避免发生冲突$ git pull# 推送到 orgin 远端服务器$ git push 撤销&amp;回滚 简单总结修改了工作区，恢复：git checkoutadd 后，想撤销： git reset HEADcommit 后，想撤销： git reset --hard [需要回退的 commit id] 撤销 修改文件 尚未提交未执行 git add 操作123# 从暂存区（index） 恢复 文件$ git checkout &lt;fileName&gt;$ git checkout .文件执行了 git add 操作，恢复 文件（index 内回滚）123456789# 取消暂存$ git reset HEAD fileName# 撤销修改$ git checkout &lt; fileName &gt;# 暂存区的 commitid 覆盖工作区修改$ git checkout [commitid] -- &lt;file&gt;# git checkout 5384b04 -- src/pages/AdScreen/components/commonStream.vue // 回退 5384b04 的文件同时对多个文件执行了 git add 操作，本次只想提交其中一部分文件1234$ git add *$ git status# 取消暂存$ git reset HEAD &lt;filename&gt; 修改文件 已经提交（git commit）到 本地仓库修改 git commit 不再产生新的 Commit[ 只能修改最近一次 ]1234# 修改最后一次提交$ git add sample.txt# 代替（或这说修改）上一次提交，不只是修改message。$ git commit --amend -m\"说明\"多次 git commit 撤销到其中某次 Commit1234567891011121314# 修改最后一次提交$ git reset --[soft/hard/mixed] [commit|HEAD]# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit] 回滚已进行 git push，即已推送到“远程仓库”中。我们将已被提交到“远程仓库”的代码还原操作叫做“回滚”！注意：对远程仓库做回滚操作是有风险的，需提前做好备份和通知其他团队成员！ 还原 远端服务器 提交的代码12345# 根据 tag 还原工作区代码$ git checkout &lt;tag&gt;# 回滚到指定commitID$ git checkout &lt;commitID&gt; &lt;filename&gt; 删除最后一次远程提交使用 revert123$ git revert HEAD$ git push origin master使用 reset123$ git reset --hard HEAD^$ git push origin master -f二者区别：revert 是放弃指定提交的修改，但是会生成一次新的提交，需要填写提交注释，以前的历史记录都在；reset 是指将 HEAD 指针指到指定提交，历史记录中不会出现放弃的提交记录。 回滚某次提交1234# 找到要回滚的 commitID$ git log# 根据 commitID 进行回滚$ git revert commitID 删除某次提交1234567891011# 找到要回滚的 commitID$ git log --oneline -n5# 注意：最后的^号，意思是commit id的前一次提交$ git rebase -i \"commit id\"^ # git rebase -i \"5b3ba7a\"^# 根据交互输入命令修改信息# 合并多个历史版本commit合并$ git rebase -i [父级commit id ]# 合并多个历史版本commit合并$ git rebase -i [开始commit 的父级id] [结束commit id]如果没有指定 结束 commit,那么结束 commit 默认为当前分支最新的 commit，那么 rebase 结束后会自动更新当前分支指向的 commit,如果指定了结束 commit，而且结束 commit 不是当前分支最新的 commit，那么 rebase 后会有生成一个 游离的 head,，而且当前分支指向的 commit 不会更新具体还可参考：Deleting a Git commit在 Git 中，如何『删除』commit？ 操作标签标签操作允许为存储库中的特定版本提供有意义的名称。 创建标签12345678910# 创建标签$ git tag -a 'tag1' -m 'tag1的说明' [HEAD / commit id / 缺省]# -a选项的 标签名称，-m选项的 标签消息。# 缺省：HEAD 要标记特定提交，则使用相应的COMMIT ID而不是HEAD指针# 将 tag1 推送到 origin 远端$ git push origin &lt;tagname&gt;# 一次性推送全部尚未推送到远程的本地标签$ git push origin --tags 查看标签123456$ git tag# 查看 所有可用的标签$ git tag -l# 查看 tagName标签的 详细信息$ git show tagName 删除标签1234567891011# 查看 所有可用的标签$ git tag -l# 删除 tagName标签$ git tag -d &lt;tagName&gt;# 删除 远端 tag 标签$ git push origin --delete tag &lt;tagname&gt;# 删除 远端 tag 标签 类似 删除远端分支的做法$ git push origin :refs/tags/标签名 操作分支 查看分支1234# 查看分支git branch -v# 查看本地分支对应的远程分支$ git branch -av 新建分支1234567891011121314151617# 新建一个名字为 dev2 的分支 (不切换到新分支)$ git branch dev2# 新建一个名字为 dev2 的分支 并切换到该分支$ git checkout -b &lt;branchname&gt;# 从某个版本创建分支 并切换到该分支$ git checkout -b &lt;branchname&gt; [commit号/分支名称]# 创建并切换分支$ git checkout -b &lt;branchname&gt; [commit版本号]# 基于 远端分支 建立 本地分支（远程分支名x） 采用此种方法建立的本地分支会和远程分支建立映射关系$ git checkout -b &lt;本地分支名x&gt; &lt;origin/远程分支名x&gt;/* 相当于分别执行了下面两条命令 */# git branch &lt;branchname&gt;# git checkout &lt;branchname&gt; 提交到远程分支12345678910$ git push [origin] &lt;分支名称&gt;:&lt;分支名称&gt;# 本地分支push到远程服务器，远程分支与本地分支同名（当然可以随意起名）$ git pull [origin] &lt;分支名称&gt; 更新远程分支到本地# /* 远程分支关联 */$ git branch --set-upstream-to=[origin]/&lt;分支名称&gt;# 接下来就 可以直接pull 或者push 了# 查看关联的分支名称$ git branch -vv[origin] 代指 添加远程裸仓库地址时候，创建的名称 删除分支123456789# 删除分支 -d是删除 -D 是强制删除$ git branch [-D/-d] &lt;branchname&gt;# 删除远程分支$ git branch -d -r &lt;branchname&gt;$ git push origin :&lt;branchname&gt;# OR$ git branch # 查看分支名称$ git push origin --delete &lt;branchname&gt; 合并分支fast-forwardfast-forward 方式 合并这种方法相当于直接把 master 分支移动到 test 分支所在的地方，并移动 HEAD 指针1234# 先切换到主分支，为合并分支准备$ git checkout master# 进行合并$ git merge devno-fast-forward 方式 合并这种合并方法会在 master 分支上新建一个提交节点，从而完成合并1234# 先切换到主分支，为合并分支准备$ git checkout master# 进行合并$ git merge –no-ff devsquash 方式 合并squash 和 no-ff 非常类似，区别只有一点不会保留对合入分支的引用12$ git checkout master$ git merge –squash devrebase 方式 合并rebase 与 merge 不同，rebase 会将合入分支上超前的节点在待合入分支上重新提交一遍，变成线性历史1234# 先切换到主分支，为合并分支准备$ git checkout master# 进行合并$ git rebase devcherry-pick 挑拣 合并对已经存在的 commit 进行 再次提交 [选择某些节点进行合并]12$ git cherry-pick &lt;commit id&gt;当执行完 cherry-pick 以后，将会 生成一个新的提交；这个新的提交的哈希值和原来的不同，但标识名 一样；图解 4 种 git 合并分支方法 &gt; git cherry-pick 的使用 暂存当收到紧急任务，手里又存在未完成的模块可以先放到暂存区12345678git stash # 暂存git stash list # 查看暂存列表git stash apply [序号/缺省为stash@&#123;0&#125;] # 恢复暂存进度到工作区git stash pop [序号/缺省为stash@&#123;0&#125;] # 恢复暂存进度到工作区并删除# git stash pop = git stash pop stash@&#123;0&#125; 分离头【detached HEAD】执行 git checkout [commit 版本号] ，git 会提示显示处于分离头（无分支状态），在此状态下，进行的提交操作不挂到在分支下，直接切换分支，会导致分离头的提交丢失。错误示范：123456789git checkout 15a6686b624 # 检出15a6686b624的提交，到分离头情况git commit -am\"错误示例\" # 创建一次提交git branch -av # 查看分支git checkout marst # 切换到marst 分支 此时git 会提示你，对分离头提交# 最后一次补救git branch [分支名称] [commit版本号]正常使用1234# 使用某个提交创建分支git checkout -b [分支名称] [commit版本号] // 创建并切换分支git checkout -b 本地分支名x origin/远程分支名x // 基于 远端分支 建立 本地分支（远程分支名x） 采用此种方法建立的本地分支会和远程分支建立映射关系 操作子仓库12345678910111213141516171819# 添加子仓库$ git submodule add &lt;仓库地址&gt; &lt;本地路径&gt;# 检出子仓库# 初始化本地配置文件$ git submodule init# 检出父仓库列出的commit$ git submodule update# 或者使用组合指令。$ git submodule update --init --recursive# 删除子仓库# 1删除.gitsubmodule里相关部分# 2删除.git/config 文件里相关字段# 3删除子仓库目录。$ git rm -r --cached &lt;本地路径&gt;git submodule 使用小结 常用命令详解 git pull 详解git pull 相当于从远程获取最新版本并 merge 到本地1234# 按照git branch 设置的默认跟踪的服务器和分支来拉取$ git pull# 实例：拉取远程服务器origin的master分支$ git pull origin mastergit pull 详解12345$ git pull [&lt;options/缺省&gt;] [&lt;远端仓库名称&gt; [&lt;分支名称&gt;…​]]# options : –allow-unrelated-histories 允许无关的历史，这个选项，更多是在更改远程仓库的时候用到# options : –ff 开启fast-forward# options : –no-ff 强行关闭fast-forward方式# options : –ff-only git fetch 详解git fetch 相当于是从远程获取最新到本地，不会自动 merge在实际使用中，git fetch 更安全一些使用 git fetch 进行更新12345678# 将远程仓库的master分支下载到本地当前branch中$ git fetch orgin master# 比较本地的master分支和origin/master分支的差别 $ git log -p master ..origin/master # 进行合并$ git merge origin/masterOR123456# 从远程仓库master分支获取最新，在本地建立tmp分支$ git fetch origin master:tmp#將當前分支和tmp進行對比$ git diff tmp#合并tmp分支到当前分支$ git merge tmpgit pull = git fetch + git merge git add 详解将修改添加到暂存区12345678910111213141516# 将所有修改添加到暂存区$ git add .# Ant风格添加修改$ git add *# 将文件的修改、文件的删除，添加到暂存区。$ git add -u# 将文件的修改，文件的删除，文件的新建，添加到暂存区$ git add -A# 将以Controller结尾的文件的所有修改添加到暂存区$ git add *Controller# 将所有以Hello开头的文件的修改添加到暂存区 例如:HelloWorld.txt,Hello.java,HelloGit.txt ...$ git add Hello*# 将以Hello开头后面只有一位的文件的修改提交到暂存区 例如:Hello1.txt,HelloA.java 如果是HelloGit.txt或者Hello.java是不会被添加的$ git add Hello? git commit 详解用于将更改记录(提交)到存储库1234567891011# 普通提交填写提交信息$ git commit -m \"the commit message\"# 将所有已跟踪文件中的执行修改或删除操作的文件都提交到本地仓库，即使它们没有经过git add添加到暂存区，# 然后提交(有点像svn的一次提交,不用先暂存)。# 对于没有track的文件,还是需要执行`git add &lt;file&gt;` 命令。$ git commit -a$ git commit -a -m \"the commit message\"# 增补提交（修改上次提交），会使用与当前提交节点相同的父节点进行一次新的提交，旧的提交将会被取消。$ git commit --amend git remote 详解git remote 命令管理一组跟踪的存储库1234567891011121314151617181920212223242526272829# 查看当前的远程库# 列出已经存在的远程分支$ git remote# 列出详细信息，在每一个名字后面列出其远程url$ git remote [-v | --verbose]# 添加一个名字为 &lt;name&gt; 的 远程服务器# $ git remote add &lt;name&gt; &lt;url&gt;$ git remote add [-t &lt;branch&gt;] [-m &lt;master&gt;] [-f] [--[no-]tags] [--mirror=&lt;fetch|push&gt;] &lt;name&gt; &lt;url&gt;# 重命名 远程链接$ git remote rename &lt;old&gt; &lt;new&gt;# 删除 远程链接$ git remote remove &lt;name&gt;$ git remote set-head &lt;name&gt; (-a | --auto | -d | --delete | &lt;branch&gt;)$ git remote set-branches [--add] &lt;name&gt; &lt;branch&gt;…​# 获取 &lt;name&gt; 远程服务 地址$ git remote get-url [--push] [--all] &lt;name&gt;# 设置 &lt;name&gt; 远程服务 地址$ git remote set-url [--push] &lt;name&gt; &lt;newurl&gt; [&lt;oldurl&gt;]# eg: git remote set-url [ 裸仓库名称/常用origin]$ git remote set-url --add [--push] &lt;name&gt; &lt;newurl&gt;$ git remote set-url --delete [--push] &lt;name&gt; &lt;url&gt;$ git remote [-v | --verbose] show [-n] &lt;name&gt;…​$ git remote prune [-n | --dry-run] &lt;name&gt;…​$ git remote [-v | --verbose] update [-p | --prune] [(&lt;group&gt; | &lt;remote&gt;)…​] git push 详解将修改添加到暂存区 语法12# 命令用于将本地分支的更新，推送到远程主机。与git pull命令相似。$ git push &lt;远程主机名/缺省&gt; &lt;本地分支名/缺省&gt;:&lt;远程分支名/缺省&gt; 示例origin 可通过 .git config 查看地址 完整示例12# 将本地的master分支推送到origin主机的master分支。如果master不存在，则会被新建。$ git push origin master 本地分支名 缺省表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。1234# 表示删除origin主机的master分支$ git push origin :master# 等同于$ git push origin --delete master 本地分支、远程分支都 缺省表示推送特定主机的对应分支简写方式：如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。12# 将当前分支推送到origin主机的对应分支$ git push origin 远程主机名、本地分支、远程分支都 缺省表示推送origin 主机的对应分支简写方式：如果当前分支只有一个追踪分支，那么主机名都可以省略。12# 将当前分支推送到 预设 主机【默认origin】的对应分支$ git push当前分支与多个主机存在追踪关系，则可以使用-u 选项指定一个默认主机，这样后面就可以不加任何参数使用 git push12# 将本地的master分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用git push了$ git push -u origin master simple 方式 和 matching 方式不带任何参数的 git push，默认只推送当前分支，这叫做 simple 方式matching 方式，会推送所有有对应的远程分支的本地分支Git 2.0 版本之前，默认采用 matching 方法，现在改为默认采用 simple 方式如果要修改这个设置，可以采用 git config 命令123$ git config --global push.default matching# 或者$ git config --global push.default simple12345678910111213141516171819202122232425# 不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机# 所有本地分支都推送到origin主机$ git push --all origin# 使用-–force选项，结果导致在远程主机产生一个”非直进式”的合并(non-fast-forward merge)$ git push --force origin# git push不会推送标签(tag)，除非使用–tags选项$ git push origin --tags# 推送tag$ git push origin tag_name# 删除远程标签$ git push origin :tag_name# 将当前分支推送到远程的同名分支$ git push origin HEAD# 将当前所在指针分支 推送到 远程的master分支$ git push origin HEAD:master# 用本地分支 dev 覆盖远程分支 dev_op$ git push -f origin dev:refs/dev_op# or$ git push origin :refs/dev //删除远程的dev分支$ git push origin dev:refs/dev_op git branch 详解用于列出，创建或删除分支 语法123456789101112# 查看分支$ git branch [-r | -a]# 新建分支$ git branch [-f] &lt;branchname&gt;# 重命名分支 使用-M则表示强制重命名$ git branch (-m | -M) &lt;oldbranch&gt; &lt;newbranch&gt;# 删除分支 使用-D则表示强制删除，相当于 --delete --force$ git branch (-d | -D) &lt;branchname&gt;使用-d 在删除前 Git 会判断在该分支上开发的功能是否被 merge 的其它分支。如果没有，不能删除。如果 merge 到其它分支，但之后又在其上做了开发，使用-d 还是不能删除。-D 会强制删除 示例12345678910111213141516171819202122232425# 查看分支$ git branch# 列出所有远程分支$ git branch -r# 查看本地和远程分支$ git branch -a# 查看本地分支对应的远程分支$ git branch -vv# 新建一个名字为 dev2 的分支$ git branch dev2# 修改分支的名字#你需要重命名远程分支，推荐的做法是：1.删除远程待修改分支 2.push本地新分支名到远程$ git branch -m dev2# 删除本地分支$ git branch -d &lt;branchname&gt;# 删除远程分支$ git branch -d -r &lt;branchname&gt;$ git push origin :&lt;branchname&gt;# OR$ git branch$ git push origin --delete dev2 git checkout 详解用于切换分支或恢复工作树文件。这条命令会重写工作区123456789101112131415161718192021222324252627282930313233343536# 切换 &lt;branch&gt; 分支$ git checkout &lt;branch&gt;# 从 &lt;branch&gt; 分支 提交中取出文件$ git checkout &lt;branch&gt; &lt;fileName&gt;# 从暂存区（index） 恢复文件$ git checkout &lt;fileName&gt;# 新建 &lt; branch &gt; 分支 并进行切换$ git checkout -b &lt;branch&gt;$ git checkout -b|-B &lt;new_branch&gt; [&lt;start point&gt;] # 完整版# 相当于 执行# git branch newBranch# git checkout newBranch# 换到newBranch的远程分$ git checkout -b newBranch origin/newBranch# 检出索引中的 fileName文件$ git checkout -- &lt;fileName&gt;# 检出索引中的 fileName文件$ git checkout -- &lt;fileName&gt;# 用于检出某一个指定文件# 不填写commit id，则默认会从暂存区检出该文件，如果暂存区为空，则该文件会回滚到最近一次的提交状态$ git checkout [-q] [&lt;commit id&gt;] [--] &lt;paths&gt;# 当暂存区为空，如果我们想要放弃对某一个文件的修改，可以用这个命令进行撤销$ git checkout [-q] [--] &lt;paths&gt;# 新建的分支，严格意义上说，还不是一个分支，因为HEAD指向的引用中没有commit值，只有在进行一次提交后，它才算得上真正的分支$ git checkout --orphan &lt;new_branch&gt;# 将当前分支修改的内容一起打包带走，同步到切换的分支下 [切换到新分支后，当前分支修改过的内容就丢失了]$ git checkout --merge &lt;branch&gt;$ git checkout -m &lt;branch&gt; 例子12345678910111213141516171819202122#//取出master版本的head。$ git checkout master#//在当前分支上 取出 tag_name 的版本$ git checkout tag_name#//放弃当前对文件file_name的修改$ git checkout master file_name#//取文件file_name的 在commit_id是的版本。commit_id为 git commit 时的sha值。$ git checkout commit_id file_name# 从远程dev/1.5.4分支取得到本地分支/dev/1.5.4$ git checkout -b dev/1.5.4 origin/dev/1.5.4#这条命令把hello.rb从HEAD中签出.$ git checkout -- hello.rb# 检出索引中的所有C源文件$ git checkout -- '*.c'#这条命令把 当前目录所有修改的文件 从HEAD中签出并且把它恢复成未修改时的样子.#注意：在使用 git checkout 时，如果其对应的文件被修改过，那么该修改会被覆盖掉。$ git checkout . git reset 详解123456789$ git reset [ –-soft | -–mixed | -–hard] &lt;commit&gt;# git reset &lt;commit&gt; 的意思就是 把HEAD移到&lt;commit&gt;# --soft 这个只是把 HEAD 指向的 commit 恢复到你指定的 commit，暂存区 工作区不变# --hard 这个是 把 HEAD， 暂存区， 工作区 都修改为 你指定的 commit 的时候的文件状态# --mixed 这个是不加时候的默认参数，把 HEAD，暂存区 修改为 你指定的 commit 的时候的文件状态，工作区保持不变# 取消暂存区 部分文件（files 代表多个）的修改$ git reset HEAD --&lt; files &gt; git cherry-pick 详解语法123456789$ git cherry-pick [&lt;options&gt;] &lt;commit-ish&gt;...# 常用options:# --quit 退出当前的chery-pick序列# --continue 继续当前的chery-pick序列# --abort 取消当前的chery-pick序列，恢复当前分支# -n, --no-commit 不自动提交# -e, --edit 编辑提交信息 git submodule 详解命令用于初始化，更新或检查子模块12345678910111213$ git submodule status [--cached] [--recursive] [--] [&lt;path&gt;…​]# 添加 子模块 路径为 相关信息保存在 .gitmodules 文件$ git submodule add &lt;url&gt; [&lt;path&gt;]# 初始化本地配置文件$ git submodule init [--] [&lt;path&gt;…​]# 检出父仓库列出的commit$ git submodule update# 使用组合指令$ git submodule update --init --recursive git 原理 git 工作解析图下面这个图展示了工作区、版本库中的暂存区和版本库之间的关系： git 文件目录COMMIT_EDITMSGconfig 当前 git 的配置文件description （仓库的描述信息文件）HEAD （指向当前所在的分支），例如当前在 develop 分支，实际指向地址是 refs/heads/develophooks [文件夹]indexinfo [文件夹]logs [文件夹]objects [文件夹] （存放所有的 git 对象，对象哈希值前 2 位作为文件夹名称，后 38 位作为对象文件名, 可通过 git cat-file -p 命令，拼接文件夹名称+文件名查看）ORIG_HEADrefs [文件夹]• heads （存放当前项目的所有分支）• tags (存放的当前项目的所有标签，又叫做里程碑) commit 与 tree 和 blob 的关系12345commit 对应一个treetree 包含文件[blob]，如果下级还是文件夹，则又是一个treeblob 是tree下面具体文件 【与文件名无关具体到文件内容】 git 注意事项checkout reset 慎用禁止向集成分支[多人使用分支] 执行 push -f [强制更新到远端 可能会导致远端所在分支回退很多版本]如果单人自行分支，确认是要返回某个节点， 使用 push -f公共分支修改 commit ： git reflog 命令查找历史，然后利用 git reset --hard [提交版本号|缺省] 的方式恢复公共分支 禁止进行 rebase 变基操作对于自己在本地的多次 commit，我想把他合并成一次 commit，还没有 push 的情况下,使用 rebase 常见缩写1234567891011121314-d --delete：删除-D --delete --force的快捷键-f --force：强制-m --move：移动或重命名-M --move --force的快捷键-r --remote：远程-a --all：所有","categories":[{"name":"工具","slug":"工具","permalink":"http://mcdowell8023.github.io/categories/工具/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://mcdowell8023.github.io/tags/笔记/"},{"name":"git","slug":"git","permalink":"http://mcdowell8023.github.io/tags/git/"}]},{"title":"git常用命令","slug":"git常用命令","date":"2019-08-21T03:23:21.000Z","updated":"2020-03-29T09:59:23.193Z","comments":true,"path":"2019/08/21/git常用命令/","link":"","permalink":"http://mcdowell8023.github.io/2019/08/21/git常用命令/","excerpt":"","text":"git 常用命令清单转载 阮老师博客 部分修改 说明Workspace：工作区Index / Stage：暂存区Repository：仓库区（或本地仓库）Remote：远程仓库 一、新建代码库12345678# 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url] 二、配置Git 的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。123456789# 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name \"[name]\"$ git config [--global] user.email \"[email address]\" 三、增加/删除文件1234567891011121314151617181920212223# 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p# 移除文件$ git rm -f *# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed] 四、代码提交123456789101112131415161718# 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ... 五、分支123456789101112131415161718192021222324252627282930313233343536373839404142# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -d -r [remote/branch] 六、标签1234567891011121314151617181920212223242526# 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag] 七、查看信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263# 通过图像方式查看提交历史gitk# 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其\"提交说明\"必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat \"@&#123;0 day ago&#125;\"# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog 八、远程同步1234567891011121314151617181920212223# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all 九、撤销123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475# 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 从仓库取出file覆盖当前分支$ git checkout branch|tag|commit -- file_name# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 取消已经暂存的文件$ git reset HEAD *# 同上$ git reset --mixed HEAD *# 重置到指定状态，不会修改索引区和工作树$ git reset --soft HEAD *# 重置到指定状态，会修改索引区和工作树$ git reset --hard HEAD *# 重置index区文件$ git reset -- files#撤销前一次操作$ git revert HEAD#撤销前前一次操作$ git revert HEAD~# 撤销指定操作commit 所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]# 暂时将未提交的变化移除，稍后再移入# 将工作区现场（已跟踪文件）储藏起来，等以后恢复后继续工作。$ git stash# 查看保存的工作现场$ git stash list# 恢复工作现场$ git stash apply# 删除stash内容$ git stash drop# 恢复的同时直接删除stash内容$ git stash pop# 恢复指定的工作现场，当你保存了不只一份工作现场时$ git stash apply stash@&#123;0&#125; 十、子仓库 git submodule12345678910111213141516171819# 添加子仓库$ git submodule add &lt;仓库地址&gt; &lt;本地路径&gt;# 检出子仓库# 初始化本地配置文件$ git submodule init# 检出父仓库列出的commit$ git submodule update# 或者使用组合指令。$ git submodule update --init --recursive# 删除子仓库# 1删除.gitsubmodule里相关部分# 2删除.git/config 文件里相关字段# 3删除子仓库目录。$ git rm -r --cached &lt;本地路径&gt; 十一、其他12# 生成一个可供发布的压缩包$ git archive","categories":[{"name":"工具","slug":"工具","permalink":"http://mcdowell8023.github.io/categories/工具/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://mcdowell8023.github.io/tags/笔记/"},{"name":"git","slug":"git","permalink":"http://mcdowell8023.github.io/tags/git/"},{"name":"命令","slug":"命令","permalink":"http://mcdowell8023.github.io/tags/命令/"},{"name":"速查","slug":"速查","permalink":"http://mcdowell8023.github.io/tags/速查/"}]},{"title":"hexo博客-常见问题","slug":"hexo博客-常见问题","date":"2019-07-17T16:15:05.000Z","updated":"2020-04-23T04:40:39.946Z","comments":true,"path":"2019/07/18/hexo博客-常见问题/","link":"","permalink":"http://mcdowell8023.github.io/2019/07/18/hexo博客-常见问题/","excerpt":"","text":"博客在 github 访问访问慢？在 coding page 上部署实现国内外分流申请 coding 账户，新建项目 同 GitHub添加 ssh key 同 GitHub修改_config.yml12345deploy: type: git repo: github: &lt;github项目地址 url&gt;,master coding: &lt;coding项目地址 url&gt;,master部署12hexo ghexo dcoding 控制台 开启 pages菜单目录中 -&gt; 代码 pages 服务注意：本地电脑之前 没有与 远端托管服务器[ github、coding 等 ] 建立过 ssh 连接，部署会报错[ 即使已经在远端配置好了 ssh 公钥 ]。可以先用本地电脑与远端进行 ssh -T git@github.com 进行测试 或者 项目克隆。 补充coding 不太给力，不知道为啥私自改了地址，而且访问巨慢。ps: 决定使用 码云，虽然每次都要点击 更新 ，但是总访问不了的强啊要注意 根目录菜单的倒是样式无法加载 的问题【 仓库名 与 用户名一样】。 戳这里看详情 同时使用 Gitub 和码云部署博客 第三方主题 没有办法上传到自己的项目中？在使用第三方主题的时候，难免要对主题进行微调。但是调整后的主题文件 是无法上传上去的。这时候，你换台电脑来写博客，就还得再来一遍。【别问我，我是怎么知道的 😂】其实第三方主题是别人的项目，你修改后自认是无法提交到别人的项目上。那么针对上面问题，有两个解决办法：删掉 第三方主题 的.git &lt; 好用但不推荐 &gt;git 不能嵌套上传，最好是显示隐藏文件，检查一下有没有，否则上传的时候会出错，导致你的主题文件无法上传使用 Git 的 Submodulefor 主题的仓库到自己的目录下 【喂，for 就不用说了吧】然后先删掉你原来主题文件 【❗️ 备份 ❗ 备份 ️❗️ 备份】1git rm -r --cached themes/&lt; 主题目录 &gt;添加 submodlue1git submodule add &lt; for后的主题仓库地址 &gt; themes/&lt; 主题目录 &gt;当前工程根路径下生成一个名为“.gitmodules”的文件123[submodule \"themes/主题\"]path = themes/主题url = https://github.com/wuchong/jacman.git # 主题地址单独提交修改后的主题【这是你还原主题更改的好时候】12345cd themes/&lt; 主题目录 &gt;git add .git commit -m \"我只是对主题进行了一些调整\"git push origin master //这是提交到fork后主题的仓库然后返回博客项目根目录 进行正常提交就好在新电脑上 clone 后 npm install 之前要去下载 主题123cd themes/&lt; 主题目录 &gt;git submodule initgit submodule update # 获取我的主题的配置注意：一定要切换到对应分支【 同时注意更新下来的版本 】 关于博客版本管理关于 hexo 博客的机制是这样的：由于 hexo d 上传部署到 github 的 pages 服务其实是 hexo 编译后的文件，是用来生成网页的，不包含源文件。那么我们写博客的源文件总要放到网上去托管啊。那么新建仓库，直接上传到 github？这样算上刚刚 for 的主题，再加上 主页的 pages 服务的主页，一个博客用了三个仓库。貌似有点浪费资源。那么。。。可以在主页仓库[pages 服务的仓库]的其他分支上传源码在下面，其实就是 git 的知识了，然而还是贴上吧1234567# 在github仓库上，创建hexo 分支，用于存放源码git remote -v #查看远程版本库信息git remote add github &lt;url&gt; #添加github远程版本库git fetch github hexo #拉取远程版本库git merge -h #查看合并帮助信息git merge --allow-unrelated-histories github/heox # 对github上的heox分支与本地master分支进行合并（两分支不是父子关系，所以合并需要添加 --allow-unrelated-histories）git push github hexo #推送同步到github仓库 的 hexo记得 fetch,pull,push 的时候 一定要 带着分支 相关连接基于 Hexo 的博客同步中的一些问题 相关文章hexo博客-建站","categories":[{"name":"技术帖","slug":"技术帖","permalink":"http://mcdowell8023.github.io/categories/技术帖/"}],"tags":[{"name":"hexoBlog","slug":"hexoBlog","permalink":"http://mcdowell8023.github.io/tags/hexoBlog/"}]},{"title":"hexo博客-建站","slug":"hexo博客-建站","date":"2019-07-17T16:14:13.000Z","updated":"2019-08-30T09:38:03.621Z","comments":true,"path":"2019/07/18/hexo博客-建站/","link":"","permalink":"http://mcdowell8023.github.io/2019/07/18/hexo博客-建站/","excerpt":"","text":"安装启动依赖：Node.js (Should be at least nodejs 6.9) / Git 安装 Hexo1npm install -g hexo-cli 建站123hexo init &lt;blogName&gt;cd &lt;blogName&gt;npm install 目录介绍12345678 .├── _config.yml # 博客项目配置文件├── package.json # 依赖包，不多少├── scaffolds # 文章模版 可以根据现有模版自定义├── source # 存放用户资源的地方| ├── _drafts| └── _posts # 文章存放目录└── themes # 主题source :资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。 修改配置12345678910vim _config.yml# 修改信息# Sitetitle: # 例如 mcdowell博客subtitle: # 例如 博客+笔记description: # 例如 javascript/vue/react/node OR 其他 笔记帖以及日常磨叨keywords: # 例如 web js vue react nodejsauthor: # 例如 mcdowelllanguage: # 例如 zh-CNtimezone:更多详细配置 见 hexo 本地启动12hexo g # g -&gt; generate 生成静态文件hexo s # s -&gt; server 启动项目然后你就见到 你的 项目了 更换主题去 hexo 官网挑选心仪主题找到主题 github 地址12git clone &lt;github 地址&gt; themes/&lt;主题名称&gt;#eg git clone https://github.com/blleng/hexo-theme-lx themes/lx修改配置 _config.yml123vim _config.yml# 修改配置theme: &lt;主题名称&gt; # eg: lx 新建文章 新建默认模版文章1hexo new &lt;title&gt;可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局 新建指定模版文章12hexo new &lt;模版名称&gt; \"文章标题\"# eg: hexo new photo \"My Gallery\" 准备 github GitHub 创建个人仓库准备 github 账号New repository，新建仓库创建一个和你用户名相同的仓库，后面加.github.io只有这样，将来要部署到 GitHub page 的时候，才会被识别，也就是 xxxx.github.io，其中 xxx 就是你注册 GitHub 的用户名。 生成 SSH 添加到 GitHub 本地电脑生成 ssh 密钥初始化 git 信息12git config --global user.name &quot;yourname&quot;git config --global user.email &quot;youremail&quot;生成密钥1ssh-keygen -t rsa -C &quot;youremail&quot;找到.ssh 下的 id_rsa.pub 文件，里面存放的就是密钥信息，可以对应添加到 github生成的 id_rsa 是私钥 生成的 id_rsa.pub 是公钥 将 hexo 部署到 GitHub修改配置 _config.yml123456vim _config.yml# 修改配置deploy:type: gitrepo: https://github.com/YourgithubName/YourgithubName.github.io.git # gitub 地址branch: master安装 deploy-git 用于部署1npm install hexo-deployer-git --save然后 三部曲123456hexo clean # 清理hexo generate # 生成静态文件hexo deploy # 部署推到远端# 缩写hexo g -d # -&gt; hexo generate --deploy然后浏览器打开 https://YourgithubName.github.io 【YourgithubName 是你的 githu 账户名称】 就可以访问了 关于留言功能valine :[https://valine.js.org/]为博客添加 Gitalk 评论插件 :[https://www.jianshu.com/p/78c64d07124d] 推荐相关连接Hexo 博客常用插件及用法GitHub+Hexo 搭建个人网站详细教程hexo 史上最全搭建教程 相关文章hexo博客-常见问题","categories":[{"name":"技术帖","slug":"技术帖","permalink":"http://mcdowell8023.github.io/categories/技术帖/"}],"tags":[{"name":"hexoBlog","slug":"hexoBlog","permalink":"http://mcdowell8023.github.io/tags/hexoBlog/"}]}]}