{"meta":{"title":"mcdowell博客","subtitle":"博客+笔记","description":"javascript/vue/react/node OR 其他 笔记帖以及日常磨叨","author":"mcdowell","url":"http://mcdowell8023.github.io"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2019-08-30T09:38:03.620Z","updated":"2019-08-30T09:38:03.620Z","comments":false,"path":"/404.html","permalink":"http://mcdowell8023.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2020-03-31T01:34:44.107Z","updated":"2020-03-31T01:34:44.107Z","comments":false,"path":"about/index.html","permalink":"http://mcdowell8023.github.io/about/index.html","excerpt":"","text":"123456789101112131415161718192021222324252627// initlet me = nullconst timeAxis = [&#x27;1991&#x27;, &#x27;2013&#x27;, &#x27;2016&#x27;, &#x27;2017&#x27;, &#x27;today&#x27;]const person = function(name, sex) &#123; return &#123; name: name, sex: sex &#125;&#125;// thentimeAxis.map(year =&gt; &#123; if (year === &#x27;1991&#x27;) &#123; me = new person(&#x27;mcdowell&#x27;, &#x27;male&#x27;) &#125; if (year === &#x27;2013&#x27;) &#123; me.college = &#x27;邯郸学院&#x27; &#125; if (year === &#x27;2016&#x27;) &#123; me.job = &#x27;coder&#x27; me.skills = [&#x27;html&#x27;, &#x27;css&#x27;, &#x27;js&#x27;, &#x27;JQ&#x27;] &#125; if (year === &#x27;2017&#x27;) &#123; me.skills = [...me.skills, &#x27;react&#x27;, &#x27;vue&#x27;] &#125;&#125;)// checkconsole.log(me, &#x27;个人简介&#x27;)"},{"title":"书单","date":"2019-08-30T09:38:03.622Z","updated":"2019-08-30T09:38:03.622Z","comments":false,"path":"books/index.html","permalink":"http://mcdowell8023.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-08-30T09:38:03.622Z","updated":"2019-08-30T09:38:03.622Z","comments":false,"path":"categories/index.html","permalink":"http://mcdowell8023.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-08-30T09:38:03.622Z","updated":"2019-08-30T09:38:03.622Z","comments":true,"path":"links/index.html","permalink":"http://mcdowell8023.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2019-08-30T09:38:03.622Z","updated":"2019-08-30T09:38:03.622Z","comments":false,"path":"repository/index.html","permalink":"http://mcdowell8023.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-08-30T09:38:03.623Z","updated":"2019-08-30T09:38:03.623Z","comments":false,"path":"tags/index.html","permalink":"http://mcdowell8023.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"HarmonyOS学习笔记-开发杂记","slug":"HarmonyOS学习笔记/HarmonyOS学习笔记-开发杂记","date":"2025-03-03T12:33:27.000Z","updated":"2025-03-02T17:23:20.269Z","comments":true,"path":"2025/03/03/HarmonyOS学习笔记/HarmonyOS学习笔记-开发杂记/","permalink":"http://mcdowell8023.github.io/2025/03/03/HarmonyOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/HarmonyOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%BC%80%E5%8F%91%E6%9D%82%E8%AE%B0/","excerpt":"","text":"网络请求 配置权限 鸿蒙中发起网络请求 需要 配置权限应用需要在module.json5配置文件的requestPermissions标签中声明权限。​ 1234567891011121314151617181920&quot;requestPermissions&quot;: [&#123; &quot;name&quot;: &quot;ohos.permission.INTERNET&quot;, &quot;usedScene&quot;: &#123; &quot;abilities&quot;: [ &quot;entryability&quot; ], &quot;when&quot;:&quot;inuse&quot; &#125; &#125;, &#123; &quot;name&quot;: &quot;ohos.permission.GET_NETWORK_INFO&quot;, &quot;usedScene&quot;: &#123; &quot;abilities&quot;: [ &quot;entryability&quot; ], &quot;when&quot;:&quot;inuse&quot; &#125; &#125;, ] 还有，每次发起请求 每一个httpRequest对应一个HTTP请求任务，不可复用​还需要及时清理 12345678910111213141516import &#123; http &#125; from &quot;@kit.NetworkKit&quot;;// 每一个httpRequest对应一个HTTP请求任务，不可复用let httpRequest = http.createHttp(); httpRequest .request(url, requestOption) .then(async (res: http.HttpResponse) =&gt; &#123; // do something &#125;).catch((res) =&gt; &#123; // do something &#125;)// 取消订阅HTTP响应头事件httpRequest.off(&quot;headersReceive&quot;);// 当该请求使用完毕时，调用destroy方法主动销毁httpRequest.destroy(); 简单封装了一个请求 源码 ‍ 文件相关 ‍ 文件下载 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import &#123; BusinessError, request &#125; from &quot;@kit.BasicServicesKit&quot;;/** * @description: 下载文件 * @param &#123;string&#125; downloadUrl: 要下载的文件的url * @param &#123;string&#125; savePath: 保存路径 * @return &#123;*&#125; */export async function downloadFile( downloadUrl: string, savePath: string, context): Promise&lt;BusinessError&gt; &#123; return new Promise(async (resolve, reject) =&gt; &#123; // 下载文件 try &#123; request .downloadFile(context, &#123; url: downloadUrl, filePath: savePath, &#125;) .then((downloadTask: request.DownloadTask) =&gt; &#123; downloadTask.on(&quot;complete&quot;, () =&gt; &#123; console.log( &quot;fileTools/file &gt;&gt; downloadFile ::log:: complete 文件下载成功，保存路径：&quot;, savePath ); resolve(&#123; code: 200, message: &quot;文件下载成功&quot;, name: &quot;downloadFile&quot;, &#125;); &#125;); &#125;) .catch((err: BusinessError) =&gt; &#123; console.error( `fileTools/file &gt;&gt; downloadFile ::log:: catch:Invoke downloadTask failed, code is $&#123;err.code&#125;, message is $&#123;err.message&#125;` ); reject(err); &#125;); &#125; catch (error) &#123; let err: BusinessError = error as BusinessError; console.error( `fileTools/file &gt;&gt; downloadFile ::log:: try-catch:Invoke downloadFile failed, code is $&#123;err.code&#125;, message is $&#123;err.message&#125;` ); reject(err); &#125; &#125;);&#125; gizp 解压 你往往发现 下载下来的文件 乱码 大小与 浏览器下载的大小不一致还不一致？？ 往往，服务器默认会对文件 进行 gzip 处理， 浏览器下载自动进行解压处理了 ，这里 我们需要 自己借助 pako 进行 gizp 解压 ‍ 使用 pako 进行 gizp 解压 123456789101112131415161718192021222324252627282930313233343536373839404142import pako from &quot;pako&quot;;import &#123; fileIo as fs &#125; from &quot;@kit.CoreFileKit&quot;;/** * 解压gz文件方法 * * @since 7 * @permission N * @param &#123;string&#125; src - 解压缩的.gz文件的路径和名称. * @param &#123;string&#125; target - 解压缩的目标文件路径. * @returns &#123;void | Promise&lt;boolean&gt;&#125; return返回Promise否则返回true或false */export async function unGzipFile( src: string, target: string): Promise&lt;boolean&gt; &#123; try &#123; const reader = fs.openSync(src, fs.OpenMode.READ_ONLY); const stat = fs.statSync(src); const buf = new ArrayBuffer(stat.size); await fs.read(reader.fd, buf); const data: string | Uint8Array | undefined = pako.ungzip( new Uint8Array(buf) ); if (typeof data == &quot;string&quot;) &#123; console.error(`fileTools/gzip &gt;&gt; unGzipFile ::log:: unGzipFile [src: $\\&#123;src&#125;,target: $\\&#123;target&#125;] data: $&#123;data&#125;`); return false; &#125; const writer = fs.openSync( target, fs.OpenMode.READ_WRITE | fs.OpenMode.CREATE ); fs.writeSync(writer.fd, data?.buffer); fs.closeSync(writer); fs.closeSync(reader); return true; &#125; catch (error) &#123; console.error( `fileTools/gzip &gt;&gt; unGzipFile ::log:: unGzipFile [src: $&#123;src&#125;,target: $&#123;target&#125;] error: $&#123;error&#125;` ); return false; &#125;&#125; ‍ zip 解压 如果文件是 压缩包，需要用到 zlib 123456789101112131415161718192021222324252627282930313233343536373839404142import &#123; zlib, BusinessError &#125; from &quot;@kit.BasicServicesKit&quot;;export async function unZipFile( inFile: string, outFile: string, opt?: zlib.Options): Promise&lt;boolean&gt; &#123; // 代码中使用的路径需为应用的沙箱路径，如/data/storage/el2/base/haps,也可以通过context获取。 // let inFile = &#x27;/xxx/filename.zip&#x27;; // let outFile = &#x27;/xxx/xxx&#x27;; let options: zlib.Options = opt || &#123; level: zlib.CompressLevel.COMPRESS_LEVEL_DEFAULT_COMPRESSION, memLevel: zlib.MemLevel.MEM_LEVEL_DEFAULT, strategy: zlib.CompressStrategy.COMPRESS_STRATEGY_DEFAULT_STRATEGY, &#125;; return new Promise((resolve, reject) =&gt; &#123; try &#123; // zlib.unzipFile zlib .decompressFile(inFile, outFile, options) .then((data: void) =&gt; &#123; console.info( &quot;fileTools/zipFile &gt;&gt; unZipFile ::log:: zipFile result is &quot; + JSON.stringify(data) ); resolve(true); &#125;) .catch((err: BusinessError) =&gt; &#123; console.error( &quot;fileTools/zipFile &gt;&gt; unZipFile ::log:: error is &quot; + JSON.stringify(err) ); reject(false); &#125;); &#125; catch (err) &#123; console.error( &quot;fileTools/zipFile &gt;&gt; unZipFile ::log:: error is &quot; + JSON.stringify(err) ); reject(false); &#125; &#125;);&#125; rawfile目录读取 rawfile下的资源会打成一个hap包，没有对外暴露的文件路径，且没有获取文件绝对路径的api ‍ Native侧读取rawfile目录文件 Native Rawfile接口操作Rawfile目录和文件 如果需要通过沙箱路径或绝对路径获取rawfile资源，就只能先将rawfile下资源拷贝进应用沙箱目录再进行操作。 ArkTS元应用侧读取rawfile目录文件 getRawFileContentSync getRawFileContent 下面是几个 arkTS rawfile 的操作实例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148 /** * @description: 拷贝 zip 文件到沙箱路径, 并自动解压 * @param &#123;string&#125; fileName: 要拷贝的文件 &#x27;2001.zip&#x27; * @param &#123;string&#125; san的boxPath: 拷贝后的文件保存路径 &#x27;filesDir/2001&#x27; * @return &#123;*&#125; * @example copyRawFileZip(&#x27;2001.zip&#x27;, this.getDirPathTheme(), applicationContext); copyRawFileZip(&#x27;2001.zip&#x27;, &#x27;/data/storage/el2/base/files/Fmap/theme&#x27;, applicationContext); */ public copyRawFileZip(fileName: string, sandBoxPath: string): Promise&lt;boolean&gt; &#123; return new Promise(async (resolve, reject) =&gt; &#123; try &#123; this.context.resourceManager.getRawFd(fileName, async (err, data) =&gt; &#123; if (err != null) &#123; console.error(`FMResourceManager.ts@copyRawFileZip &gt;&gt; getRawFd error : $&#123;JSON.stringify(&#123; fileName:fileName, sandboxPath:sandBoxPath,err:err &#125;)&#125; ` ); resolve(false); return; &#125; console.log(`FMResourceManager.ts@copyRawFileZip &gt;&gt; getRawFd : `, &#123; fileName:fileName, sandboxPath:sandBoxPath &#125;); await checkDir(sandBoxPath); await this.copyFile(fileName,sandBoxPath,data); // 此处依赖了一zip 解压函数 const isCompled = await unZipFile(sandBoxPath+&#x27;/&#x27;+fileName, sandBoxPath); this.context.resourceManager.closeRawFd(fileName, (err, data) =&gt; &#123; if (err != null) &#123; console.error(`FMResourceManager.ts@copyRawFileZip &gt;&gt; closeRawFd -&gt;:$&#123;JSON.stringify(err)&#125;`); &#125; &#125;); return resolve(isCompled ? true : false); &#125;); &#125; catch (error) &#123; let code = (error as BusinessError).code; let message = (error as BusinessError).message; console.error(`FMResourceManager.ts@copyRawFileZip &gt;&gt; catch -&gt;:$&#123;JSON.stringify(&#123;code:code,message:message&#125;)&#125;`, ); return(false); &#125; &#125;); &#125; /** * 拷贝rawfile到沙箱，md5验证文件，文件已经存在，返回已存在的文件名称 * @param fileName rawfile静态资源名称 * @param sandboxPath 沙箱目录 * @returns 复制后的文件名称,可能和传入的文件名不同 | null 拷贝失败 */ public async copyRawFile(fileName: string,sandboxPath: string) : Promise&lt;string&gt; &#123; console.log(`FMResourceManager.ts@copyRawFile &gt;&gt; 沙箱路径: $&#123;JSON.stringify(&#123;fileName,sandboxPath&#125;)&#125;`); try &#123; let data = await this.context.resourceManager.getRawFdSync(fileName); //先将文件复制到临时目录,然后校验md5,如果已有文件，则删除临时文件，返回已有文件的 文件名，如果没有相同文件，则从临时目录移动到最终目录 let tempPath = sandboxPath+&quot;/temp&quot;; let tempFileName = tempPath +&quot;/&quot; + fileName; console.log(`FMResourceManager.ts@copyRawFile &gt;&gt; 复制临时文件 $&#123;JSON.stringify(&#123;tempPath&#125;)&#125;`); await this.copyFile(fileName,tempPath,data); console.log(`FMResourceManager.ts@copyRawFile &gt;&gt; 计算文件 Md5 $&#123;JSON.stringify(&#123;tempFileName&#125;)&#125;`); let rawFdFileMd5 = await calFileMd5(tempFileName); if(rawFdFileMd5 == null)&#123; return; &#125; //校验文件 md5判断是否有重复文件 let filenames = await fileIo.listFileSync(sandboxPath); for (let i = 0; i &lt; filenames.length; i++) &#123; let path = sandboxPath +&quot;/&quot;+filenames[i]; if(filenames[i] === &#x27;temp&#x27;)continue; let fileMd5 = await calFileMd5(path); if(fileMd5 == null) continue; console.log(`FMResourceManager.ts@copyRawFile &gt;&gt; 计算目标目录下文件md5-&gt;$&#123;JSON.stringify(&#123;path,fileMd5&#125;)&#125;`); if(fileMd5 === rawFdFileMd5)&#123; //将临时文件删除 console.log(`FMResourceManager.ts@copyRawFile &gt;&gt; 找到md5相同的文件，返回该文件名-&gt;$&#123;JSON.stringify(&#123;path,fileMd5,rawFdFileMd5&#125;)&#125;`); fileIo.unlink(tempFileName); return filenames[i]; &#125; &#125; //未找到md5同一的文件，则移动临时文件到最终目录 console.log(`FMResourceManager.ts@copyRawFile &gt;&gt; 没有重复文件，拷贝文件到指定目录 -&gt;$&#123;JSON.stringify(&#123;tempFileName,dest:sandboxPath+&quot;/&quot;+fileName&#125;)&#125;`); await fileIo.copyFile(tempFileName, sandboxPath+&quot;/&quot;+fileName); console.log(`FMResourceManager.ts@copyRawFile &gt;&gt; 删除临时文件-&gt;$&#123;JSON.stringify(&#123;tempFileName&#125;)&#125;`); await fileIo.unlink(tempFileName); return fileName; &#125; catch (error) &#123; let code = (error as BusinessError).code; let message = (error as BusinessError).message; console.error(`FMResourceManager.ts@copyRawFile catch error :-&gt;$&#123;JSON.stringify(&#123;code:code,message:message&#125;)&#125;`); return; &#125; &#125;/** * 计算文件 md5 * @param fileUrl 文件路径 * @returns 文件md5 */export async function calFileMd5(fileUrl: string): Promise&lt;string | null&gt; &#123; try&#123; return await hash.hash(fileUrl, &quot;md5&quot;); &#125;catch (e)&#123; FMLog.i(&quot;file.ts@calFileMd5 &gt;&gt; calFileMd5 : &quot;,e); &#125; return null;&#125; /** * 将传入文件拷贝到指定目录 * @param fileName 文件资源名称 * @param sandboxPath 沙箱目录 * @returns */ public async copyFile(fileName: string, sandboxPath: string,data:any)&#123; try&#123; await checkDir(sandboxPath); let destFilePath = sandboxPath+&#x27;/&#x27;+fileName; console.log(`FMResourceManager.ts@copyFile &gt;&gt; copyFile `,&#123;destFilePath&#125;); let dest = fileIo.openSync(destFilePath,fileIo.OpenMode.CREATE | fileIo.OpenMode.READ_WRITE); let bufsize = 4096; let buf = new ArrayBuffer(bufsize); let off = 0,len = 0,readedLen = 0; /** * 通过buffer将rawfile文件内容copy到沙箱路径 */ while (len = fileIo.readSync(data.fd, buf, &#123; offset: data.offset + off, length: bufsize &#125;)) &#123; readedLen += len fileIo.writeSync(dest.fd, buf, &#123; offset: off, length: len &#125;) off = off + len if ((data.length - readedLen) &lt; bufsize) &#123; bufsize = data.length - readedLen &#125; &#125; fileIo.close(dest.fd); &#125;catch (e) &#123; console.error(`FMResourceManager.ts@copyFile &gt;&gt; copyFile catch error-&gt;: $&#123;JSON.stringify(e)&#125; `); &#125; &#125; ‍ 根据传入的字符串生成图片 实现思路： 使用 @Builder​ 函数组件 作为 截图对象。（函数组件如果为全局，可能会报错） 使用 componentSnapshot.createFromBuilder​ 进行离屏渲染截图 截图后得到包装图片包装对象，使用 pixelMap.readPixelsToBufferSync​ 或者 image.createImagePacker​ 的packToData​ 进行解码 代码 ‍","categories":[{"name":"客户端","slug":"客户端","permalink":"http://mcdowell8023.github.io/categories/%E5%AE%A2%E6%88%B7%E7%AB%AF/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://mcdowell8023.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"HarmonyOS","slug":"HarmonyOS","permalink":"http://mcdowell8023.github.io/tags/HarmonyOS/"},{"name":"拓展","slug":"拓展","permalink":"http://mcdowell8023.github.io/tags/%E6%8B%93%E5%B1%95/"}]},{"title":"HarmonyOS学习笔记 - har 包构建&&发布","slug":"HarmonyOS学习笔记/HarmonyOS学习笔记 - har 包构建&&发布","date":"2025-03-02T10:26:47.000Z","updated":"2025-03-02T10:26:56.506Z","comments":true,"path":"2025/03/02/HarmonyOS学习笔记/HarmonyOS学习笔记 - har 包构建&&发布/","permalink":"http://mcdowell8023.github.io/2025/03/02/HarmonyOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/HarmonyOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20-%20har%20%E5%8C%85%E6%9E%84%E5%BB%BA&&%E5%8F%91%E5%B8%83/","excerpt":"","text":"‍ HAR 的介绍 HAR（Harmony Archive）是静态共享包，可以包含代码、C++ 库、资源和配置文件。通过 HAR 可以实现多个模块或多个工程共享 ArkUI 组件、资源等相关代码。 ‍ 使用用场景 作为二方库，发布到 OHPM 私仓，供公司内部其他应用使用。 作为三方库，发布到 OHPM 中心仓，供其他应用使用。 HAR 约束限制 ‍ 不支持在设备上单独安装/运行，只能作为应用模块的依赖项被引用。 不支持在配置文件中声明​**UIAbility​组件与​ExtensionAbility​组件**。 不支持在配置文件中声明​**pages​页面**，但是可以包含 pages 页面，并通过命名路由的方式进行跳转。 不支持引用 AppScope 目录中的资源。在编译构建时，AppScope 中的内容不会打包到 HAR 中，因此会导致 HAR 资源引用失败。 可以依赖其他 HAR，但不支持循环依赖，也不支持依赖传递。 ‍ 构建 HAR ‍ 工具准备 ide : devEoc-studio [ 安装到华为官网自行下载 ] ohpm 命令行工具： 使用手册 下载 Command Line Tools 解压后 拷贝到 ～/ 目录下 ,重新命名为 .ohpm_tools​ 「 ps 如果 .ohpm 不冲突也可以 不修改 」 cd 进入 .ohpm_tools/bin​ 目录下 执行 ./init​ 将 ohpm 配置到环境变量中: 1234567export OHPM_HOME=/home/xx/Downloads/ohpm #本处路径请替换为ohpm的安装路径export PATH=$&#123;OHPM_HOME&#125;/bin:$&#123;PATH&#125;## 例如export OHPM_HOME=&quot;$HOME/.ohpm_tools&quot; #本处路径请替换为ohpm的安装路径export PATH=$&#123;OHPM_HOME&#125;/bin:$&#123;PATH&#125;% ‍ ‍ 1、创建库模块 1）新建一个鸿蒙项目（或者使用原有项目也可以），以新建的鸿蒙项目 fengmap_harmony_sdk​ 为例，鼠标移到工程目录顶部，单击右键，选择 New &gt; Module，在工程中添加模块： ‍ ​​ ‍ 2）在 Choose Your Ability Template 界面中，选择 Static Library，并单击 Next： ‍ ‍ 3）在 Configure New Module 界面中，设置新添加的模块信息（以新增模块 fengmap_harmony_sdk​ 为例），设置完成后，单击 Finish 完成创建。 Module name：新增模块的名称。比如：fengmap_harmony_sdk​。 Device type：支持的设备类型。 Enable native：是否创建一个用于调用 C++ 代码的模块。 ‍ ​​​ ‍ ？？已经存在模块 如果已经有了要打包的模块，那么 选中模块 shift+F6 弹出菜单 选择《重命名模块》修改名称即可，devEoc-studio 会自动帮你修改所有相关名称 ‍ ‍ 2、HAR 包的构建 将要发布使用的代码放在 src/main/ets/components 目录下，比如新增一个 ets 文件 index.ets。 随便写些功能，如增加 FMMapViewComponent 页面。 在模块包根目录下 Index.ets 如 fengmap_harmony_sdk/Index.ets​ 导出页面 1export &#123; FMMapViewComponent &#125; from &#x27;./src/main/ets/components/FMMapViewComponent&#x27; ‍ 在模块的 fengmap_harmony_sdk/oh-package.json5​ 文件修改希望使用的 引用名称。 如：@fengmap/sdk​ 根据官方名规范 为 @+组织名称/名称​ 当然在该文件可以修改某些 包的关键信息，如： 版本 version​ 、描述 description​ 、入口 main​、开源仓库检索关键字 keywords​、作者 author​、开源协议 license​ 如现在命名为：@fengmap/sdk 那么用户在 引入调用的 名称 与此一致 实际使用 import &#123; FMMapViewComponent &#125; from '@fengmap/sdk';​ 12345678910&#123; &quot;name&quot;: &quot;@fengmap/sdk&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;XXXX&quot;, &quot;main&quot;: &quot;Index.ets&quot;, &quot;author&quot;: &quot;wxq24&quot;, &quot;license&quot;: &quot;Apache-2.0&quot;, &quot;dependencies&quot;: &#123;&#125;, &quot;compatibleSdkType&quot;: &quot;HarmonyOS&quot;&#125; ‍ ‍ 开发完库模块后，选中模块名，然后通过 DevEco Studio 菜单栏的 Build &gt; **Make Module '**​fengmap_harmony_sdk​ ’ 进行编译构建，生成 HAR。HAR 可用于工程其它模块的引用，或将 HAR 上传至 ohpm 仓库，供其他开发者下载使用。若部分源码文件不需要打包至 HAR 中，可通过创建.ohpmignore 文件，配置打包时要忽略的文件/文件夹。 使用 release 模式构建 HAR 具体看。 其他构建方式 具体看 官方构建文档 点击 DevEco Studio 右上角图标 Build Mode 中选择 release。 默认为 &lt;Default&gt; 模式：在编译 App 时使用 release 模式，编译 HAP/HSP/HAR 时使用 debug 模式。 ​​ 在使用 release 模式 为保护代码资产，建议开启混淆。 在模块级 build-profile.json5 文件 配置如下： 1234567891011121314151617181920212223242526272829303132&#123; &quot;apiType&quot;: &quot;stageMode&quot;, &quot;buildOption&quot;: &#123; &#125;, &quot;buildOptionSet&quot;: [ &#123; &quot;name&quot;: &quot;release&quot;, &quot;arkOptions&quot;: &#123; // 混淆相关参数 &quot;obfuscation&quot;: &#123; &quot;ruleOptions&quot;: &#123; // true表示进行混淆，false表示不进行混淆。5.0.3.600及以上版本默认为false &quot;enable&quot;: true, // 混淆规则文件 &quot;files&quot;: [ &quot;./obfuscation-rules.txt&quot; ] &#125;, // consumerFiles中指定的混淆配置文件会在构建依赖这个library的工程或library时被应用 &quot;consumerFiles&quot;: [ &quot;./consumer-rules.txt&quot; ] &#125; &#125;, &#125;, ], &quot;targets&quot;: [ &#123; &quot;name&quot;: &quot;default&quot; &#125; ]&#125; 最外层工程级 build-profile.json5 ​中的 useNormalizedOHMUrl 字段设置为 false。 12345678910111213&#123; &quot;app&quot;: &#123; &quot;products&quot;: [ &#123; &quot;buildOption&quot;: &#123; &quot;strictMode&quot;: &#123; &quot;useNormalizedOHMUrl&quot;: false &#125; &#125; &#125; ] &#125;&#125; 构建成功后，会生成一个包 fengmap_harmony_sdk​.har，在 build/default/outputs/default/fengmap_harmony_sdk​.har 路径下。 ​​​ ‍ ‍ 3、HAR 包的导入和使用 1）验证下本地构建好的 HAR 包是否可以在项目中导入和使用，首先新建一个测试项目 maptest​ ，工程目录下新建文件夹 libs，并将 fengmap_harmony_sdk​.har 包拷贝到该目录下，打开项目的 oh-package.json5​ 添加 har 包的依赖，最后执行同步操作 Sync Now ​​ ‍ ​maptest​ 项目 下的 oh-package.json5​ 示例如下： 123456789101112&#123; &quot;name&quot;: &quot;entry&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;Please describe the basic information.&quot;, &quot;main&quot;: &quot;&quot;, &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;&quot;, &quot;dependencies&quot;: &#123; &quot;@fengmap/sdk&quot;: &quot;file:../libs/fengmap_harmony_sdk.har&quot; &#125;&#125; ‍ ‍ 2）导入成功后，会生成一个文件 oh-package-lock.json5​，里面详细记录导入的包的信息 ​​ ‍ 3）在 ets/pages Index.ets ​中导入包的头文件，调用 har 包中的相关代码。 123456789101112import &#123; FMMapViewComponent &#125; from &#x27;@fengmap/sdk&#x27;;@Entry@Componentstruct Index &#123; build() &#123; Column() &#123; FMMapViewComponent() &#125; .height(&#x27;100%&#x27;) .width(&#x27;100%&#x27;) &#125;&#125; 4）接下来运行项目，查看效果。没有问题 至此 结束。 「 如果不准备 上传到 开源仓库 让用户通过命令使用，此处构建已经结束。 直接本地分发使用即可」 ‍ 发布 HAR 包 1. 在库模块 fengmap_harmony_sdk ​中（与 src 文件夹同一级目录下），修改 oh-package.json5 文件内容，如下： 12345678910111213141516171819202122232425262728&#123; &quot;name&quot;: &quot;@fengmap/sdk&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;XXXXXXXXXXXX&quot;, &quot;main&quot;: &quot;Index.ets&quot;, &quot;keywords&quot;: [&#x27;map&#x27;,&#x27;fengmap&#x27;,&#x27;mapSDK&#x27;,&#x27;室内地图&#x27;,&#x27;地图SDK&#x27;], &quot;author&quot;: &quot;fengmap&quot;, &quot;license&quot;: &quot;Apache-2.0&quot;, &quot;dependencies&quot;: &#123; &quot;liblibrary.so&quot;: &quot;file:./src/main/cpp/types/liblibrary&quot;, &quot;pako&quot;: &quot;^2.1.0&quot; &#125;, &quot;devDependencies&quot;: &#123; &quot;@types/pako&quot;: &quot;^2.0.0&quot; &#125;, &quot;dynamicDependencies&quot;: &#123;&#125;, &quot;compatibleSdkVersion&quot;: &quot;12&quot;, &quot;compatibleSdkType&quot;: &quot;HarmonyOS&quot;, &quot;obfuscated&quot;: false, &quot;nativeComponents&quot;: [ &#123; &quot;name&quot;: &quot;liblibrary.so&quot;, &quot;compatibleSdkVersion&quot;: &quot;12&quot;, &quot;compatibleSdkType&quot;: &quot;HarmonyOS&quot; &#125; ]&#125; name：HAR 包名。在 ohpm 中包的命名格式为 @&lt;group&gt;/&lt;package_name&gt; 或者 &lt;package_name&gt; 。 其中 group 是组织，package_name 是包名。 当想要上传一个含有组织（例如 @fengmap/map）的包时，在 ohpm-repo 中需要先创建出该组织（例如 fengmap）才能进行上传。 该组织名称需要审核，只有审核通过后，才能在该组织下发布包，所以要提前申请。具体的申请，请参考官方文档：组织管理。 version：包的版本号，一般从 1.0.0 开始。 description：包的描述。 main: 定义包的主入口文件。 author：开发者名称。 license: 包的许可证类型。 dependencies: 列出项目运行时必需的依赖包及其版本。 其他配置具体看官方文档配置 以上信息中的 name、author、description，会在 OpenHarmony 三方库中心仓中展示。 ⚠️ 注意：在后面的 README.md 文件或者 CHANGELOG.md 中如果介绍包信息，其中包名一定要和 name 中设置的包名（@wxqos/wxqcolor）一致，否则有审核失败的风险！！！ ‍ 2. 添加其他必要文件 新建 README.md 文件： 在 README.md 文件中必须包含包的介绍和引用方式，还可以根据包的内容添加更详细介绍。 ​​ 新建 CHANGELOG.md 文件：填写 HAR 的版本更新记录。 ​​ ‍ 添加 LICENSE 文件：LICENSE 许可文件。 可以去 Apache License, Version 2.0 直接粘贴 具体格式 进行修改 ‍ 12345678910111213Copyright 发布年份 应用组织Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);you may not use this file except in compliance with the License.You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0Unless required by applicable law or agreed to in writing, softwaredistributed under the License is distributed on an &quot;AS IS&quot; BASIS,WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.See the License for the specific language governing permissions andlimitations under the License. ⚠️ 注意：以上内容要保证文件不缺失、内容正确且真实，不然之后的审核有可能会通不过！ ‍ 3、修改完以上信息后，需要重新执行下 Make Module ‘fengmap_harmony_sdk​’ 编译构建一个新的 fengmap_harmony_sdk​.har 包。 ‍ 4、开始发布 利用工具 ssh-keygen 生成公、私钥，可通过执行以下命令来生成公钥和私钥： 12345ssh-keygen -m PEM -t RSA -b 4096 -f ~/.ssh_ohpm/mykey## 例如ssh-keygen -m PEM -t RSA -b 4096 -f ~/.ssh_ohpm/fengmapKey ‍ ❗️ 前提： 如果没有~/.ssh_ohpm 目录需要先创建 mkdir .ssh_ohpm ⚠️ 注意：OHPM 包管理器只支持加密密钥认证，请在生成公私钥时输入密码, ❗️ 并要记住密码，发布时候会使用 OHPM 包管理器只支持加密密钥认证，请在生成公私钥时输入密码。【解释：就是上面说的密码，后面上传包的时候会用】 ‍ 登录 OpenHarmony 三方库中心仓官网，单击主页右上角的个人中心，新增 OHPM 公钥，将公钥文件（XXX.pub）的内容粘贴到公钥输入框中。 ​​​ 使用 命令行 配置私钥路径：（ 此处需要 使用 ohpm 工具包 ） 123ohpm config set key_path your-keypath## 例如ohpm config set key_path ~/.ssh_ohpm/fengmapKey ～/.ohpm/.ohpmrc 隐藏文件 中会填充一条内容，表示命令执行成功 : 1key_path=/Users/xxx/.ssh_ohpm/fengmapKey 配置登录用户发布码： 登录 OpenHarmony 三方库中心仓官网，单击主页右上角的个人中心，复制发布码 ​​ 获取发布码并配置到 .ohpmrc 文件中，可执行如下命令： 1234ohpm config set publish_id your_publish_id## 如：ohpm config set publish_id VC2A1KN4Y8 此处 亦会 在 ～/.ohpm/.ohpmrc 进行追加: 12key_path=/Users/mcdowell/.ssh_ohpm/fengmapKepublish_id=VC2A1KN4Y8 ‍ ‍ ‍ 执行如下命令发布 HAR，&lt;HAR 路径&gt;需指定为.har 文件的绝对路径 1ohpm publish /Users/mcdowell/project/HarmonyProject/fengmap_harmony/fengmap_harmony_sdk/build/default/outputs/default/fengmap_harmony_sdk.har ⚠️ 注意：其中会让你输入一个密码，就是上面说的上传包的密码。 ‍ 如果在输入密码后，见到这句 Thanks for your contribution, the submitted OHPM library is under review, you can check the package status from https://ohpm.openharmony.cn/#/cn/personalCenter/package​ 那么就表示成功。 ‍ ❗️ 报错： ohpm ERROR: The “paths[1]” argument must be of type string. Received undefined — &gt; 注意 ohpm 版本，低版会出现该问题，尝试升级到最新版本 ‍ ‍ 在 OpenHarmony 三方库中心仓的消息中能查看到你提交的信息，以及审核结果的信息： ​​ ​​ 审核通过后，就可以在 OpenHarmony 三方库中心仓中搜索到了： ‍ ​​ ‍ ​​ ‍ 发布成功 HAR 包的导入和使用 ‍ 在项目的 Terminal 执行导入命令： 1ohpm install @fengmap/sdk ‍ 具体的使用和上面本地 har 包使用一样： 1import &#123; FMMapViewComponent &#125; from &#x27;@fengmap/sdk&#x27; 开始使用 食用即可。 ‍","categories":[{"name":"客户端","slug":"客户端","permalink":"http://mcdowell8023.github.io/categories/%E5%AE%A2%E6%88%B7%E7%AB%AF/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://mcdowell8023.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"HarmonyOS","slug":"HarmonyOS","permalink":"http://mcdowell8023.github.io/tags/HarmonyOS/"},{"name":"拓展","slug":"拓展","permalink":"http://mcdowell8023.github.io/tags/%E6%8B%93%E5%B1%95/"}]},{"title":"HarmonyOS学习笔记-初识","slug":"HarmonyOS学习笔记/HarmonyOS学习笔记-初识","date":"2025-01-16T00:26:17.000Z","updated":"2025-03-02T10:36:39.835Z","comments":true,"path":"2025/01/16/HarmonyOS学习笔记/HarmonyOS学习笔记-初识/","permalink":"http://mcdowell8023.github.io/2025/01/16/HarmonyOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/HarmonyOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%88%9D%E8%AF%86/","excerpt":"","text":"1.1 准备 1.1.1 前置了解 1.1.1.1 开发套件 一套开发多端部署 devEcoStudio 统一开发编辑器 ArkTs 编程语言 类TypeScript ArkUI： 官方提供的 声明式UI开发框架 编辑器汉化 [ 不推荐] settings &gt; plugins &gt; “ installed ” tab 下搜索 chinese , 然后勾选重启 变为 中文 1.1.1.2 UI框架 HarmonyOS提供了一套UI开发框架，即方舟开发框架（ArkUI框架），提供了两种开发范式，分别是基于 ArkTS的声明式开发范式（简称“声明式开发范式”） 数据驱动更新，使用 ArkTS语言 适用于 复杂度较大、系统应用（基于ArkUI进行页面构造布局，并用封装属性来进行页面渲染和布局优化） 兼容JS的类Web开发范式（简称“类Web开发范式”） 数据驱动更新， 使用 JS语言 来开发 界面较为简单的程序应用和卡片，适用于Web前端开发人员 （对于web开发人员只是一个新的框架） 更多UI框架的开发内容及指导，详见UI开发。 1.1.1.3 应用模型 ‍ 应用模型是HarmonyOS为开发者提供的应用程序所需能力的抽象提炼，它提供了应用程序必备的组件和运行机制。有了应用模型，开发者可以基于一套统一的模型进行应用开发，使应用开发更简单、高效。 ‍ Stage模型： HarmonyOS API 9开始新增的模型，是目前主推且会长期演进的模型。在该模型中，由于提供了AbilityStage、WindowStage等类作为应用组件和Window窗口的“舞台”，因此称这种应用模型为Stage模型。Stage模型开发可见Stage模型开发概述。快速入门以此为例提供开发指导。 FA（Feature Ability）模型： HarmonyOS API 7开始支持的模型，已经不再主推。FA模型开发可见FA模型开发概述。快速入门章节不再对此展开提供开发指导。 FA模型和Stage模型的整体架构和设计思想等更多区别，请见应用模型。 1.2 开始开发 1.2.1 下载安装开发工具 请[安装最新版DevEco Studio](https://developer.huawei.com/consumer/cn/download/)。 注意： 5.X以后 不要配置 配置nodejs 【 建议本地开发使用18.x , 镜像源使用 华为，避免后面编译、调试报错 。 如报错：Only files in a module can be previewed. 】 修改npm 镜像源 npm config set registry https://repo.huaweicloud.com/repository/npm/​ 一键安装； mac X86 系统 新版已经不再支持 模拟器 ‍ 1.2.2 创建开发 若首次打开DevEco Studio，请点击Create Project创建工程。如果已经打开了一个工程，请在菜单栏选择File &gt; New &gt; Create Project来创建一个新工程。 选择Application应用开发（本文以应用开发为例，Atomic Service对应为元服务开发），选择模板“Empty Ability”，点击Next进行下一步配置。若开发者需要进行Native相关工程的开发，请选择“Native C++ ”模板，更多模板的使用和说明请见工程模板介绍。 ​​ 进入配置工程界面，Compatible SDK表示兼容的最低API Version，此处以选择“5.0.0(12) ”为例，其他参数保持默认设置即可。 ​​ 点击Finish，工具会自动生成示例代码和相关资源，等待工程创建完成。 目录介绍 AppScope &gt; app.json5：应用的全局配置信息，打包编译阶段使用的配置。详见app.json5配置文件。 entry：HarmonyOS工程模块，编译构建生成一个HAP包。 src &gt; main &gt; ets：【类似原来项目的src】 用于存放ArkTS源码 ,可以存在多个。 src &gt; main &gt; ets &gt; entryability：应用/服务的入口, 一个 entryability 对应一个程序的基本单元（窗口），承载用户信息，可以存在多个。 src &gt; main &gt; ets &gt; entrybackupability：应用提供扩展的备份恢复能力。 src &gt; main &gt; ets &gt; pages：应用页面。 src &gt; main &gt; resources： [ 相当于 assest ] 存放应用/服务所用到的资源文件，如图形、多媒体、字符串、布局文件等。关于资源文件，详见资源分类与访问。 src &gt; main &gt; resources &gt; base &gt; profile &gt; main_pages.json : 路由配置 【通过 ide 增加 页面，会自动增加页面路由】 src &gt; main &gt; module.json5：模块配置文件。主要包含HAP包的配置信息、应用/服务在具体设备上的配置信息以及应用/服务的全局配置信息。具体的配置文件说明，详见module.json5配置文件。 build-profile.json5：当前的模块信息 、编译信息配置项，包括buildOption、targets配置等。 hvigorfile.ts：模块级编译构建任务脚本。 obfuscation-rules.txt：混淆规则文件。混淆开启后，在使用Release模式进行编译时，会对代码进行编译、混淆及压缩处理，保护代码资产。详见开启代码混淆。 oh-package.json5：用来描述包名、版本、入口文件（类型声明文件）和依赖项等信息。 oh_modules：用于存放三方库依赖信息。 build-profile.json5：工程级配置信息，包括签名signingConfigs、产品配置products等。其中products中可配置当前运行环境，默认为HarmonyOS。 hvigorfile.ts：工程级编译构建任务脚本。 oh-package.json5：【类似node项目的 package.json】主要用来描述全局配置，如：依赖覆盖（overrides）、依赖关系重写（overrideDependencyMap）和参数化配置（parameterFile）等。 ‍ 常用开发目录创建 entry &gt; src &gt; main &gt; ets: apis : 用于接口请求开发 声明 utils : 工具函数目录 view : 组件目录 viewModel : 存放数据和约束 pages：页面开发目录 lib： 存放三方插件 ‍ 创建页面 在 pages 页面开发目录 , 右键 新建 &gt; page &gt; Empty Page ( ide 会自动增加页面路由) ; 或者 ArkTS File， 但是此种方式需要 手动增加路由 ‍ 创建组件 在 view 组件目录 , 右键 新建 &gt; ArkTS File 12345678910111213@Preview // 预览组件// @Entry // 组件不该使用@Entry; 页面才使用@Compoentexport struct Header &#123; build()&#123; Column()&#123; Text(&#x27;这是一个Header组件&#x27; ) &#125; .width(&#x27;100%&#x27;) .height(&#x27;100%&#x27;) &#125;&#125; 创建工具类 在 utils 组件目录 , 右键 新建 &gt; ArkTS File 1234567891011121314151617181920// 示例创建一个名称为 dataFormat.est 文件// 用于数据格式化// 公用函数 需要使用class 方式呈现export class DataFormat &#123; // 日期格式化函数 dateFormat(value:Date)&#123; const year = value.getFullyer(); const month = value.gerMonth() + 1; const day = value.getDate(); return `$&#123;year&#125;-$&#123;month&#125;-$&#123;day&#125;` &#125;&#125;export default new DataFormat();//******** 使用 ***********// 引入import DataFormat from &quot;@../utils/dataFormat&quot;// 调用const dateString = DataFormat.dateFormat(new Date()); ‍ 预览器运行 选择pages 下的页面 ets 页面，选择右侧 **Previewer 预览 按钮，进行预览「 支持热更新」; 预览器工具说明一览： ​​ 调试： 顶部 检查按钮点开调试 类似浏览器，可以进行页面调试 刷新： 顶部刷新按钮点击，可以更新页面预览 预览页面 预览组件 ​​ 可以切换设备尺寸 进行预览 ​​设备模拟窗口上面 三个按钮依次 是 返回 、横屏、 更多 更多 ：中可以 切换语言、设置分辨率、显示安全区 预览器debugger 调试： 增加代码断点后，在编辑窗口选择设备为 previewer ，点击 进行 debugger 调试。 使用真机运行应用 需要 搭载HarmonyOS 5.X 系统的手机 手机端点击系统版本，开启开发者模式。 将真机与电脑连接。 使用无线方式需要开启服务，需要安装 hdc 工具包，且官方文档 提到tcp 连接方式存在不稳定情况。推荐线连 具体指导及要求，可查看使用本地真机运行应用/服务。 ide 自动签名： 点击File &gt; Project Structure… &gt; Project &gt; SigningConfigs界面勾选“Support HarmonyOS”和“Automatically generate signature”，点击界面提示的“Sign In”，使用华为账号登录。 【此处需要 完成签名部分，具体看 应用/元服务签名】 等待自动签名完成后，点击“OK”即可。如下图所示： ​ ‍ ‍ 在不签名情况，运行手机在报错日志中的链接也可跳转 如下图所示：​ 在编辑窗口右上角的工具栏，点击 按钮运行。 debugger 调试： 增加代码断点后，在编辑窗口右上角的工具栏，点击 进行 debugger 调试。 debugger 调试 说明 F8：单步跳过。代表 进入下一段代码。 如果当前代码是函数调用，默认不会关注函数内部，只会得到结果 F7: 单步调试。代表进行 下一段代码调试。 如果当前代码是函数调用，默认进入函数内部调试 ‍","categories":[{"name":"客户端","slug":"客户端","permalink":"http://mcdowell8023.github.io/categories/%E5%AE%A2%E6%88%B7%E7%AB%AF/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://mcdowell8023.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"HarmonyOS","slug":"HarmonyOS","permalink":"http://mcdowell8023.github.io/tags/HarmonyOS/"},{"name":"拓展","slug":"拓展","permalink":"http://mcdowell8023.github.io/tags/%E6%8B%93%E5%B1%95/"}]},{"title":"前端项目优化-7.h5离线ZIP包","slug":"web/前端项目优化-7.h5离线ZIP包","date":"2024-11-15T06:37:34.000Z","updated":"2025-03-08T07:16:55.387Z","comments":true,"path":"2024/11/15/web/前端项目优化-7.h5离线ZIP包/","permalink":"http://mcdowell8023.github.io/2024/11/15/web/%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96-7.h5%E7%A6%BB%E7%BA%BFZIP%E5%8C%85/","excerpt":"","text":"Liveme离线包方案详细实现 示例页面 示例页面zip 方案概述 为优化前端项目加载速度、节省网络流量并提升用户体验，我们设计了一套完整的H5离线ZIP包方案。该方案通过预下载热门页面离线包、普通离线包按需下载更新以及主动更新机制，确保用户在不同网络环境下都能快速访问页面。 功能 预下载：提前下载热门页面的离线包，以便用户在需要时能够快速访问。 普通离线包：用户访问页面后，下载并更新离线包，以便下次使用。 主动更新：定期检查并更新离线包 主要为了增强版本控制。 实现 前端-打包 前端 维护 构建 zip 配置文件 前端 打包生成 zip 包 【 会注入 window.KEWLWebZip 变量 (用于配合版本检查)】 前端编写 离线包管理脚本 webzip.js，注入到 需要 离线包 的 页面 中。【版本检查、通知客户端 删除、更新、下载等操作】 构建 基于 构建 zip 配置文件 和打包结果(配置中的项目是否发生了变更)* 生成 /webzip/zipVersion.json 配置文件。 发布服务 客户端-实现 客户端 提供 维护 zip 包 的方法 （包括下载、删除） 客户端 在打开h5页面前需要 根据本地的 /webzip/zipVersion.json 配置文件 判断离线包是否存在, 存在则 加载 离线包，否则 加载 在线页面。 客户端在 打开zip 时候 需要 拼接 WEBHOST=当前包对应的h5域名 地址 客户端 启动后需要打开一个 隐藏的页面，用于 主动更新 离线包[页面执行完毕会主动关闭]。 使用阶段 预下载 客户端 启动后，会下载 /webzip/zipVersion.json 配置文件。 客户端 检测到 配置文件 更新 进行 替换。 空闲时间 扫描 预下载（prefetch）的离线包的下载，zip版本发生变化, 进行下载。 普通离线包 用户访问在线页面后， 前端根据 注入的 zip 变量 执行 离线包管理脚本 webzip.js 完成 版本检查、下载，更新 下载在打开 该页面， 离线包 存在，客户端会优先使用 离线包。 主动更新 由于客户端 每次启动都会 打开这个 /webzip/versionMananger.html 页面。 前端 通过 重新部署 &amp;&amp; 刷新CDN 方式, 就可以 更新页面，从而 主动更新 离线包。 离线包生成与配置实践 离线包生成流程 1. 打包配置文件 prefetch 预加载zip zipList 离线包列表 removeList 移除zip 2. 打包特殊处理 引入 离线包管理脚本 webzip.js 脚本，用于版本检查、加载 离线包。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108import updateLocation2 from &#x27;./location2&#x27;;const KEWLWebZip = window.KEWLWebZip || &#123;&#125;;export const isWebZip = [&#x27;content:&#x27;, &#x27;file:&#x27;].includes(window.location.protocol);KEWLWebZip.isWebZip = isWebZip;KEWLWebZip.jump = (&#123; url, isReplace&#125;) =&gt; &#123; let href = url; if (window.KEWLWebZip.isWebZip) &#123; // 同一个离线包内的页面 if (new RegExp(`/app/$&#123;window.KEWLWebZip.name&#125;`).test(url)) &#123; href = window.location.pathname.replace(/(\\/dist\\/.*)|\\/[^/]+(?!.)/g, url.split(`/app/$&#123;window.KEWLWebZip.name&#125;`)[1]); // 追加WEBHOST参数 if (window.KEWLWebZip.WEBHOST &amp;&amp; href.indexOf(&#x27;WEBHOST&#x27;) == -1) &#123; href += `$&#123;href.indexOf(&#x27;?&#x27;) &gt; -1 ? &#x27;&amp;&#x27; : &#x27;?&#x27;&#125;WEBHOST=$&#123;encodeURIComponent(window.KEWLWebZip.WEBHOST)&#125;`; &#125; &#125; else if (/^\\/\\//g.test(url)) &#123; // 以//开头 href = `$&#123;window.location2.protocol&#125;$&#123;url&#125;`; &#125; else if (/^\\//g.test(url)) &#123; // 以/开头 href = `$&#123;window.location2.origin&#125;$&#123;url&#125;`; &#125; else if (/https:\\/\\/|http:\\/\\/|^\\/\\//g.test(url)) &#123; // http或者https协议链接 href = url; &#125; &#125; if (isReplace) &#123; window.location.replace(href); &#125; else &#123; window.location.href = href; &#125;&#125;;let zipVersions;const fetchZipVersion = () =&gt; new Promise((resolve) =&gt; &#123; const t = new Date().getTime(); window.KEWLHttp &amp;&amp; window.KEWLHttp.get(`$&#123;window.location2.origin&#125;/app/webzip/zipVersion.json?t=$&#123;t&#125;`).then((res) =&gt; &#123; if (res.status == 200) &#123; if (res.data.zips) &#123; zipVersions = res.data.zips; resolve(zipVersions); &#125; &#125; &#125;);&#125;);const checkZipVersion = (name, version, callback) =&gt; &#123; if (zipVersions) &#123; callback(name, version, zipVersions[name]); &#125; else &#123; fetchZipVersion().then(() =&gt; &#123; callback(name, version, zipVersions[name]); &#125;); &#125;&#125;;const findSelfZip = () =&gt; &#123; let prex; let name; let version; if (window.KEWLWebZip.isWebZip) &#123; (&#123; prex, name, version &#125; = window.KEWLWebZip); if (!prex) &#123; prex = `/app/$&#123;name&#125;`; &#125; &#125; else &#123; const result = /\\/app\\/(.*?)\\//g.exec(window.location2.href); if (result &amp;&amp; Array.isArray(result) &amp;&amp; result.length &gt; 1) &#123; [prex, name] = result; &#125; else &#123; // 不符合结构，一般出现在本地开发时 return; &#125; version = 0; &#125; checkZipVersion(name, version, (_, ver, latestVer) =&gt; &#123; if (!latestVer &amp;&amp; window.KEWLWebZip.isWebZip) &#123; // 移除zip包 window.KEWLApp.deleteWebZipRes(prex); // 替换为远程地址，展示最新内容 window.location.replace(window.location2.href); &#125; else if (latestVer &gt; ver) &#123; // 通知客户端下载最新zip包 window.KEWLApp.downloadWebZipRes(name, latestVer); if (window.KEWLWebZip.isWebZip) &#123; // 替换为远程地址，展示最新内容 window.location.replace(window.location2.href); &#125; &#125; &#125;);&#125;;KEWLWebZip.findSelfZip = findSelfZip;KEWLWebZip.fetchZipVersion = fetchZipVersion;KEWLWebZip.checkZipVersion = checkZipVersion;window.KEWLWebZip = KEWLWebZip;export default KEWLWebZip; zip对应的h5打包中，会注入 window.KEWLWebZip 变量 (用于配合版本检查) 123456window.KEWLWebZip = &#123; prex: &quot;/app/$&#123;dir&#125;&quot;, remotePath: &quot;/app/$&#123;dir&#125;$&#123;dest&#125;&quot;, name: &quot;$&#123;dir&#125;&quot;, version: &quot;$&#123;version&#125;&quot;&#125; 3. 收集、打包资源 对比md5值 是否需要进行 离线包 生成 通过脚本收集 页面中 所有的资源，包括 图片、css、js、html等。 将收集到的资源 进行打包，生成 zip 包。使用时戳作为 文件后缀，标识文件更新时间。 4. 根据配置 和 打包结果 更新 zipVersion.json 配置文件 /webzip/zipVersion.json 配置文件（用于客户端维护zip依据） 文件本身版本号 分类型记录： 预加载（提前下载）、普通加载。 记录 离线包的路径、离线包的版本号、更新时间。 12345678910&#123; &quot;status&quot;: 200, &quot;version&quot;: &quot;20240613103717&quot;, &quot;zips&quot;: &#123; &quot;rank-list&quot;: &quot;20240827160843&quot;, &quot;kingdom&quot;: &quot;20240827160612&quot;, &quot;grade&quot;: &quot;20241014104248&quot; &#125;, &quot;prefetch&quot;: [ &#123; &quot;prex&quot;: &quot;/app/grade&quot;, &quot;zipPath&quot;: &quot;/app/grade/dist/grade_20241014104248.zip&quot;, &quot;version&quot;: &quot;4.6.30&quot; &#125;, &#123; &quot;prex&quot;: &quot;/app/kingdom&quot;, &quot;zipPath&quot;: &quot;/app/kingdom/dist/kingdom_20240827160612.zip&quot;, &quot;version&quot;: &quot;4.6.30&quot; &#125; ], &quot;remove&quot;: []&#125; 5. 发布服务 发布服务，将生成的zip包和配置文件上传到服务器。 注意 版本文件 跨域问题。 主动更新 前端 手动 刷新 方式: 增加 webzip/versionMananger.html 页面(用于主动更新) 用于前端通过 更新 html，调用客户端bridge实现 加载、删除 zip 包。 客户端 每次启动都会 隐藏的 打开这个页面。html 设置 缓存10分钟。 当然，如果客户端发现 这个版本的zip已经存在，则不会下载 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no&quot;&gt; &lt;script src=&quot;/app/js/dist/kewlglobal.js?v=202409051029&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;script&gt; if (window.KEWLApp &amp;&amp; window.KEWLApp.downloadWebZipRes) &#123; window.KEWLApp.downloadWebZipRes(&quot;grade&quot;, &quot;20241014104248&quot;); window.KEWLApp.downloadWebZipRes(&quot;kingdom&quot;, &quot;20240827160612&quot;); // 其他的。。。 &#125; window.KEWLApp.closePage() &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 问题处理与优化 多语言静态文件处理 问题：此前为了优化使用axios 延后加载多语言，但是zip后无法请求本地文件。 解决方案：改为全量打包不进行延后加载，确保所有语言资源在离线包中可用。 远程资源处理 问题：非本地的资源无法直接在离线环境下使用。 解决方案：对于远程资源，下载或以base64形式进行打包，确保所有依赖资源在离线包中完整。 script module兼容问题 问题：在content协议下，触发script module兼容问题（MIME类型错误）。 解决方案：将script标签的type改为兼容模式（Legacy） location替换问题 问题：在离线包中直接使用window.location可能导致跳转异常。 解决方案：使用 window.location2 代替 window.location ，并提供配套方法 window.KEWLWebZip.jump 用于跳转。 神策数据上报 问题：需要区分不同离线包的数据上报。 解决方案：在原神策上报的url中拼接 zipVer=[当前zip包版本] ，用于区分不同离线包的数据。 iframe使用 问题：iframe的src需要正确解析。 解决方案：iframe的url必须使用 window.location2 拼接全路径后使用。 示例： 12345// iframe使用示例const iframeUrl = `$&#123;window.location2.origin&#125;/activity/2022/dist/nightClub/index.html?source=2`;const iframe = document.createElement(&#x27;iframe&#x27;);iframe.src = iframeUrl;document.body.appendChild(iframe);","categories":[{"name":"技术帖","slug":"技术帖","permalink":"http://mcdowell8023.github.io/categories/%E6%8A%80%E6%9C%AF%E5%B8%96/"}],"tags":[{"name":"web","slug":"web","permalink":"http://mcdowell8023.github.io/tags/web/"},{"name":"优化","slug":"优化","permalink":"http://mcdowell8023.github.io/tags/%E4%BC%98%E5%8C%96/"},{"name":"离线包","slug":"离线包","permalink":"http://mcdowell8023.github.io/tags/%E7%A6%BB%E7%BA%BF%E5%8C%85/"}]},{"title":"前端项目优化-6.SEO指南","slug":"web/前端项目优化-6.SEO指南","date":"2024-08-27T05:37:34.000Z","updated":"2025-03-08T02:42:04.309Z","comments":true,"path":"2024/08/27/web/前端项目优化-6.SEO指南/","permalink":"http://mcdowell8023.github.io/2024/08/27/web/%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96-6.SEO%E6%8C%87%E5%8D%97/","excerpt":"","text":"百度和谷歌是如何收录的？ 百度和谷歌等搜索引擎的收录过程大致相似，分为爬取、索引、排名三个阶段。每个搜索引擎有其特定的算法，但总体流程是相同的，如下： 爬取阶段（Crawling） 搜索引擎通过其爬虫（如谷歌的 Googlebot、百度的 Baiduspider）不断访问网站的页面，发现并获取最新内容。爬虫通过以下方式找到页面： 站点地图（sitemap.xml） ：网站通过 sitemap.xml 文件告知搜索引擎所有需要抓取的页面路径。 内部链接：爬虫通过页面的内部链接，逐步找到网站的更多页面。 外部链接：如果其他网站链接到某个页面，爬虫会跟随链接抓取。 Robots.txt 文件：爬虫根据 robots.txt 中的规则判断哪些页面允许或不允许抓取。 索引阶段（Indexing） 在获取页面内容后，搜索引擎会将其存储到索引数据库中，便于日后检索。具体过程如下： 解析页面：爬虫分析页面的文本、HTML 标签（如标题、描述、H 标签等）、图片（通过 Alt 属性描述）和视频等内容。 提取关键词：提取页面中最相关的关键词、主题词等，帮助确定页面的内容方向。 分析页面结构：通过页面的内部链接结构，判断页面的内容层次和重要性。 排名阶段（Ranking） 搜索引擎在索引数据库中保存了海量内容，每当用户发起搜索请求时，搜索引擎会根据算法将最相关、质量最优的页面排序展示。这一阶段的工作包括： 关键词匹配：页面内容的关键词是否符合用户搜索意图，标题、描述和正文中的关键词密度和位置都会影响排名。 内容质量：页面内容的原创性、时效性、实用性等因素都会影响搜索引擎的评分。优质内容更可能获得高排名。 页面体验：网站的加载速度、移动端适配度、页面交互体验等也会影响排名。 外部链接质量：指向该页面的外部链接数量和质量也是排名的参考因素。优质链接能帮助搜索引擎判断页面权威性。 用户行为数据：搜索引擎还会参考点击率、停留时长、跳出率等用户数据，以评估页面的受欢迎程度。 1. 关键词调研 确认为后续内容更新提供关键词表（重要） 2.blog系统 持续更新优质内容（worldpress）; 网站页面数量越多，收录的概率越大 网站结构化数据设置 meta ssr 标题标签（Title Tag）：标题是搜索引擎爬虫首先读取的信息之一。一个理想的标题包含核心关键词，并具备吸引力，通常在 50-60 个字符内，以确保在搜索结果中不被截断。 title, 标题建议是语义化加网站信息eg:create a robot | souldeep.ai 描述标签（Meta Description）：描述标签用于向搜索引擎和用户简要说明页面内容。合理利用关键词，并吸引用户点击。建议控制在 150-160 字符以内。 description, 当前页面的功能表示，关键字信息 关键词标签（Meta Keywords）：虽然搜索引擎不再直接依赖该标签，但合理地添加关键词有助于内容分类和组织，特别是内容管理系统（CMS）可以利用该字段做站内搜索。 HTML 标签：合理使用 H1-H6 层次标题、section、article等标签，不仅帮助搜索引擎理解页面内容结构，还能提升用户的阅读体验。 图片标签（Alt 属性）：为图片加上描述，不仅提升无障碍体验，还能被搜索引擎抓取到；图片是网页的重要组成部分，搜索引擎会根据图片的内容和描述来判断页面的质量。 image, 产品或者主图信息 12345678910111213141516171819202122&lt;title&gt;LiveMe - Live Broadcasting Community&lt;/title&gt;&lt;meta property=&quot;title&quot; content=&quot;LiveMe - Live Broadcasting Community&quot;&gt;&lt;meta property=&quot;description&quot; content=&quot;LiveMe is a leading live broadcasting platform offering diverse content, including talent shows, celebrity interviews, live concerts, gaming streams, and interactive features like video chat. Join our vibrant community and explore endless live content in a safe and stable environment.&quot;&gt;&lt;meta property=&quot;keywords&quot; content=&quot;LiveMe, live broadcasts, live streaming, social media platform, video chat, online community, live content, mobile broadcasting, talent shows, celebrity livestreams, gaming streams, trivia games, interactive broadcasts, real-time interaction, virtual gifts, live video chat, streaming platform, live events, popular streamers, influencer marketing, live performances, audience engagement, live entertainment, global community, livestream income, digital creators, online video, mobile app, live streaming app, content creators, live engagement&quot;&gt;&lt;meta property=&quot;og:title&quot; content=&quot;LiveMe - Live Broadcasting Community&quot;&gt;&lt;meta property=&quot;og:image&quot; content=&quot;https://www.liveme.com/images/share.jpg&quot;&gt;&lt;meta property=&quot;og:url&quot; content=&quot;LiveMe - Live Broadcasting Community&quot;&gt;&lt;meta property=&quot;og:type&quot; content=&quot;website&quot;&gt;&lt;meta property=&quot;fb:app_id&quot; content=&quot;531652053656781&quot;&gt;&lt;meta property=&quot;og:description&quot; content=&quot;LiveMe is a leading live broadcasting platform offering diverse content, including talent shows, celebrity interviews, live concerts, gaming streams, and interactive features like video chat. Join our vibrant community and explore endless live content in a safe and stable environment.&quot;&gt;&lt;meta property=&quot;og:sitename&quot; content=&quot;LiveMe&quot;&gt;&lt;meta property=&quot;twitter:title&quot; content=&quot;LiveMe - Live Broadcasting Community&quot;&gt;&lt;meta property=&quot;twitter:description&quot; content=&quot;LiveMe is a leading live broadcasting platform offering diverse content, including talent shows, celebrity interviews, live concerts, gaming streams, and interactive features like video chat. Join our vibrant community and explore endless live content in a safe and stable environment.&quot;&gt;&lt;meta property=&quot;twitter:image&quot; content=&quot;https://www.liveme.com/images/share.jpg&quot;&gt;&lt;meta property=&quot;twitter:card&quot; content=&quot;summary&quot;&gt; 富媒体检测 https://search.google.com/test/rich-results?hl=zh-cn 结构化数据文档：https://developers.google.com/search/docs/appearance/structured-data/search-gallery?hl=zh-cn 123456789101112131415161718192021222324252627282930313233343536&lt;script type=&quot;application/ld+json&quot;&gt; &#123; &quot;@context&quot;: &quot;https://schema.org&quot;, // 定 义 了词 汇 的 上 下文，这里 使用 的 是 Schema.org &quot;@graph&quot;: [&#123; // 使用 图 表 表示 法 列 出 所 有顶 级 对 象 &quot;@type&quot;: &quot;WebApplication&quot;, // 定 义 类型 为Web应用 程 序 &quot;@id&quot;: &quot;https://blog.huddles.app/#webapp&quot;, // 应用 程 序 的 唯一标 识 符，一 般网 站首页 &quot;name&quot;: &quot;huddles.app - Your meeting assistant app&quot;, // 应用 程 序 的 名 称 ，网 站 title &quot;description&quot;: &quot;Let AI streamline your meetings with automated agendas, notes, and summaries. Focus on the conversation, from one-on-ones to team gatherings.&quot;,// 应用 程 序 的 描 述，网 站 的 描 述 &quot;offers&quot;: &#123;// 描 述应用 程 序 的报 价 信 息 &quot;@type&quot;: &quot;Offer&quot;, // 定 义 类型 为Offer &quot;category&quot;: &quot;free&quot;, // 报 价 类 别 &quot;price&quot;: &quot;0&quot;, // 价 格 &quot;priceCurrency&quot;: &quot;USD&quot; // 价 格货 币 &#125;, &quot;aggregateRating&quot;: &#123; // 应用 程 序 的 综 合 评 分 &quot;@type&quot;: &quot;AggregateRating&quot;, // 定 义 类型 为综 合 评 分 &quot;worstRating&quot;: 0, // 最 低 评 分 &quot;bestRating&quot;: 5, // 最高 评 分 &quot;ratingValue&quot;: 4.998437135249128, // 平 均 评 分值 &quot;ratingCount&quot;: 252741 // 评 分 总数 &#125;, &quot;applicationCategory&quot;: &quot;Commercial applications&quot;, // 应用 程 序 类 别 &quot;operatingSystem&quot;: &quot;window,mac,linux&quot;, // 支 持 的 操 作 系 统 &quot;publisher&quot;: &#123; // 出 版者信 息 &quot;@type&quot;: &quot;Organization&quot;, // 定 义 类型 为组 织 &quot;image&quot;: &quot;https://huddles.app/images/logo.svg&quot;, // 组 织 的 图片 &quot;url&quot;: &quot;https://blog.huddles.app/&quot;, // 组 织 的 URL &quot;logo&quot;: &quot;https://huddles.app/images/logo.svg&quot;, // 组 织 的标志 &quot;name&quot;: &quot;Huddles&quot;, // 组 织 的 名 称 &quot;description&quot;: &quot;Let AI streamline your meetings with automated agendas, notes, and summaries. Focus on the conversation, from one-on-ones to team gatherings.&quot;, // 组 织 的 描 述 &quot;email&quot;: &quot;contact@huddles.app&quot;, // 联 系 邮箱 &quot;telephone&quot;: &quot;+1-800-123-4567&quot; // 联系电话 &#125; &#125;] &#125;&lt;/script&gt; 请放进head标签内，并把中文都去掉 搜索引擎内容体现： 外部链接与内容营销 外部链接是衡量页面权威性的关键因素。优质的外链能提升页面权重和搜索引擎排名。以下是一些有效的外链建设方法： 高质量外链：从权威网站获取高质量链接，通过内容合作、行业交流等方式建立链接关系。 内容营销：创作有价值的内容，如行业报告、数据分析、深度文章，吸引他站自发链接，增加网站可信度。 合作与资源互换：与同行或行业网站建立合作关系，互相推荐优质内容。 社交媒体链接：在 Facebook、Twitter、LinkedIn 等平台分享内容，获得自然的外部链接。 论坛与社区互动：在 Quora、Reddit 等社区中提供专业回答，附上相关内容的链接，有助于提升曝光度和网站权重。 网站收录优化与站点地图 Sitemap.xml：使用 sitemap.xml 提供页面结构，便于搜索引擎了解网站架构。 1https://example.com/sitemap.xml Robots.txt 文件：通过 robots.txt 限制不需要被抓取的页面，如后台、隐私页面等，优化抓取效率，更多的robots.txt 文件说明，请参考我之前写的一篇文章一文看懂网络爬虫的实现原理。 123User-agent: *Disallow: /private/Sitemap: https://example.com/sitemap.xml 网站性能与用户体验提升 关注网站优化，因为FCP、LCP 直接影响排名 SEO 数据监控与持续优化 SEO 是一个持续优化的过程，通过数据监测和迭代调整保持良好的排名效果。 Google Search Console：定期查看流量分析、抓取状态、外链质量等数据，优化站点。 SEO 工具分析：使用 Ahrefs、Semrush 等工具监测关键词排名、外链质量、页面性能等，优化内容和结构。 研发重点关注 worldpress系统搭建，模板系统的使用 网站结构化数据 Google搜索SEO参考文档：https://developers.google.com/search/docs/fundamentals/seo-starter-guide?hl=zh-cn","categories":[{"name":"技术帖","slug":"技术帖","permalink":"http://mcdowell8023.github.io/categories/%E6%8A%80%E6%9C%AF%E5%B8%96/"}],"tags":[{"name":"web","slug":"web","permalink":"http://mcdowell8023.github.io/tags/web/"},{"name":"优化","slug":"优化","permalink":"http://mcdowell8023.github.io/tags/%E4%BC%98%E5%8C%96/"},{"name":"SEO","slug":"SEO","permalink":"http://mcdowell8023.github.io/tags/SEO/"}]},{"title":"前端项目优化-4.效率提升-构建优化","slug":"web/前端项目优化-5-效率提升-构建优化","date":"2024-07-07T06:48:10.000Z","updated":"2025-03-06T10:06:55.047Z","comments":true,"path":"2024/07/07/web/前端项目优化-5-效率提升-构建优化/","permalink":"http://mcdowell8023.github.io/2024/07/07/web/%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96-5-%E6%95%88%E7%8E%87%E6%8F%90%E5%8D%87-%E6%9E%84%E5%BB%BA%E4%BC%98%E5%8C%96/","excerpt":"","text":"开发时性能优化 其实在很多文章中，这一步也被划分到了加载性能或者网络层面中，但笔者还是觉得这个东西对于用户来说是没有感知的，只是会影响我们日常开发或者说打包的速度，应该单独提出来说。 这一步其实主要是构建打包方面的问题，其实具体的操作与Vite和Webpack等工具是强耦合的，在此我还是只提方向举一小部分例，具体实现还需要各位针对不同工具去实践 缩小加载范围：配置include/exclude缩小Loader对文件的搜索范围，好处是避免不必要的转译。不然所有node_modules都跑一边那不是卡死了。 打包缓存：很多工具都可以开启打包的缓存，这一步能大大减少构建时间。如Umi的MFSU或者hardsource-webpack-plugin等实现缓存效果的工具都是笔者见过效果立竿见影的。 提前构建：配置DllPlugin将第三方依赖提前打包，好处是将DLL与业务代码完全分离且每次只构建业务代码。（这个玩意儿非常老了，并且我在三年前的实践中就感觉他速度提升不是很明显，可以不用提及） 并行构建：释放CPU多核并发的优势。诸如happyPack、thread-loader 等工具都可以在不同阶段开启CPU多核进行并行构建，大大提升开发时效率。 可视化分析：对打包后的文件大小进行可视化分析，能够更好的分析哪些包比较大，或者小的进行合并。如Vite的rollup-plugin-visualizer、和Webpack的webpack-bundle-analyzer。 Tree-Shaking 基于ES6模板语法（import与exports），主要是借助ES6模块的静态编译思想， 编译阶段利用ES6 Module判断哪些模块已经加载，确定模块的依赖关系，以及输入和输出的变量 判断那些模块和变量未被使用或者引用，进而删除对应代码，削减项目的体积。 原理 在vue3源码引入tree shaking特性，按需加载组件，将全局 API 进行分块。 // webpack.config.js module.exports = { optimization: { usedExports: true, // 启用Tree Shaking minimize: true, // 启用代码压缩 }, }; 静态分析：打包工具（如Webpack、Rollup）对项目中的所有ES6模块进行静态分析，构建模块依赖图。 标记未使用代码：通过依赖图，标记出未被引用的模块和函数。 代码删除：在打包阶段，删除所有标记为未使用的代码。 在Vue2中，无论我们使用什么功能，它们最终都会出现在生产代码中。主要原因是Vue实例在项目中是单例的，捆绑程序不能检测该对象的哪些属性在代码中被使用到。 ES5 构建： Vue 2的构建版本基于 ES5 ，它不太支持按需引入。 组件导入方式： 在 Vue 2中，大部分组件是通过直接引入 Vue 对象的属性来使用的，这导致整个 Vue 对象以及所有的属性都会被包含进最终的构建中，无法精确地按需引入。 组件间关系： Vue 2组件在定义和使用时的关系较为复杂，可能会造成不同组件之间的依赖关系和引用关系，这也会影响 Tree-shaking 的效果。 当使用 Vue 时有下面一些办法来减小打包产物体积： 尽可能地采用构建步骤 如果使用的是相对现代的打包工具，许多 Vue 的 API 都是可以被 tree-shake 的。举例来说，如果你根本没有使用到内置的 组件，它将不会被打包进入最终的产物里。Tree-shaking 也可以移除你源代码中其他未使用到的模块。 当使用了构建步骤时，模板会被预编译，因此我们无须在浏览器中载入 Vue 编译器。这在同样最小化加上 gzip 优化下会相对缩小 14kb 并避免运行时的编译开销。 在引入新的依赖项时要小心包体积膨胀！在现实的应用中，包体积膨胀通常因为无意识地引入了过重的依赖导致的。 如果使用了构建步骤，应当尽量选择提供 ES 模块格式的依赖，它们对 tree-shaking 更友好。举例来说，选择 lodash-es 比 lodash 更好。 查看依赖的体积，并评估与其所提供的功能之间的性价比。如果依赖对 tree-shaking 友好，实际增加的体积大小将取决于你从它之中导入的 API。像 bundlejs.com 这样的工具可以用来做快速的检查，但是根据实际的构建设置来评估总是最准确的。 如果你只在渐进式增强的场景下使用 Vue，并想要避免使用构建步骤，请考虑使用 petite-vue (只有 6kb) 来代替。 webpack来优化前端性能 用webpack优化前端性能是指优化webpack的输出结果，让打包的最终结果在浏览器运行快速高效。 压缩代码:删除多余的代码、注释、简化代码的写法等等方式。可以利用webpack的 UglifyJsPlugin 和 ParallelUglifyPlugin 来压缩]S文件，利用cssnano(css-loader?minimize)来压缩css 利用CDN加速:在构建过程中，将引用的静态资源路径修改为CDN上对应的路径。可以利用webpack对于 output 参数和各loader的 publicPath 参数来修改资源路径 Tree Shaking:将代码中永远不会走到的片段删除掉。可以通过在启动webpack时追加参数–optimize-minimize 来实现 Code Splitting:将代码按路由维度或者组件分块(chunk),这样做到按需加载,同时可以充分利用浏览器缓存 提取公共第三方库: Split Chunks Plugin插件来进行公共模块抽取,利用浏览器缓存可以长期缓存这些无需频繁变动的公共代码 Webpack打包原理。Webpack优化 初始化流程：从配置文件和 Shell 语句中读取与合并参数，并初始化需要使用的插件和配置插件等执行环境所需要的参数 编译构建流程：从 Entry 发出，针对每个 Module 串行调用对应的 Loader 去翻译文件内容，再找到该 Module 依赖的 Module，递归地进行编译处理 输出流程：对编译后的 Module 组合成 Chunk，把 Chunk 转换成文件，输出到文件系统 设计理念与功能： Webpack 是一个全能型的模块打包工具，不仅支持 JavaScript 模块的打包，还能处理 CSS、HTML、图片等各种静态资源。 提供了丰富的Loader机制，可以转换非JavaScript资源（如Sass转CSS、图片转Base64编码等）。 支持代码分割（Code Splitting），可以根据路由懒加载代码块，有效提升页面加载速度。 将构建后的 JavaScript 包拆分为多个较小的，可以按需或并行加载的文件。通过适当的代码分割，页面加载时需要的功能可以立即下载，而额外的块只在需要时才加载，从而提高性能。可以通过分析 ES Module（ESM）动态导入的语法来自动进行代码分割 内置了热模块替换（Hot Module Replacement, HMR），实现开发过程中的实时刷新。 配合Plugin系统，可以实现复杂的构建流程定制，比如提取公共代码、压缩代码、优化图片等。 Loader与Plugin loader 是文件加载器，运行在打包文件之前，能够加载资源文件，并对这些文件进行一些处理，诸如编译、压缩等，最终一起打包到指定的文件中 plugin 赋予了 webpack 各种灵活的功能，例如打包优化、资源管理、环境变量注入等，目的是解决 loader 无法实现的其他事，在整个编译周期都起作用 使用场景： 大型SPA（Single Page Application）或企业级Web应用，这类项目往往需要处理多种资源和复杂的构建流程。 需要做代码分割和按需加载的场景。 对于有大量第三方库依赖和复杂业务逻辑的项目。 热模块替换（HMR）原理 通过webpack-dev-server创建两个服务器：提供静态资源的服务（express）和Socket服务 express server 负责直接提供静态资源的服务（打包后的资源直接被浏览器请求和解析） socket server 是一个 websocket 的长连接，双方可以通信 当 socket server 监听到对应的模块发生变化时，会生成两个文件.json（manifest文件）和.js文件（update chunk） 通过长连接，socket server 可以直接将这两个文件主动发送给客户端（浏览器） 浏览器拿到两个新的文件后，通过HMR runtime机制，加载这两个文件，并且针对修改的模块进行更新 rollup和webpack有什么区别 https://juejin.cn/post/7097493230572273700 Rollup 设计理念与功能： Rollup 主要是针对库（library）开发设计的，专注于ES6模块规范，采用严格静态分析的方式，因此具有出色的tree-shaking能力。 不像Webpack那样内置处理非JavaScript资源的能力，Rollup专注于JavaScript模块的打包和优化，更适合构建无运行时副作用的、纯净的JavaScript库。 输出的bundle倾向于更小、更纯净，适合那些希望发布最小化且高效利用模块化的库。 使用场景： 开发和发布独立的JavaScript库或组件，特别是那些遵循ES6模块规范的库。 当项目主要关注代码大小和纯净性，而非需要处理大量非JS资源的时候。 Rollup Webpack 应用场景 更适合用于库的打包，尤其是那些专注于 ES6 模块的库 能够分析所有的 ES6 模块，删除不需要的代码，并将计算合并在一起，从而产生出更小更快的代码，这样的输出可以在所有的现代浏览器中逐字解析 用于复杂应用的打包，这种应用大多是由多个单独的模块组成的，并且使用了多种资源（例如图片、样式表等）。 Webpack 适合这种复杂应用的打包，因为它能够处理 JavaScript 资源以外的任何文件，同时还支持各种插件，例如代码压缩、代码分离、热更新等等。 打包方式 默认是只生成一个文件，会从入口文件开始遍历整个依赖图，并只将项目的所需部分包含在生成的 JavaScript 文件中。这种方式有效地清除了生成文件不需要的部分并生成更小，更快的输出。 更好地利用 Tree Shaking 等技术消除不必要的代码。 将所有的文件打包在一起，以形成一个或多个文件，这些文件包含了所有的 JavaScript、样式表、图像和字体等等。同时还需要处理比较复杂的代码和依赖关系，还需要进行一系列的优化和处理，比如加载和解析模块，分离出共享代码等，所以 Webpack 会相对慢一些。。 访问速度 输出文件更小，所以它需要更少的时间去下载，同时它不包含任何多余的代码，因此它可以更快地加载和运行。 Webpack 打包后的文件较大，所以它需要花费更长的时间下载。此外，由于其中包含运行时环境，因此它需要时间来解析代码 生态和扩展性 扩展性就比较弱，它不能很好的处理 JavaScript 之外的其他资源，但是我们可以使用一些 Rollup 的插件来帮助我们处理其他类型的文件，来实现更加丰富的功能 扩展性非常强大，它有着众多的插件和 Loader 可以使用，因此我们可以为我们的应用添加各种功能和特性，而不用自己去实现一个 选择Webpack： 当项目包含多个资源类型，需要综合处理HTML、CSS、图片等资源时。 当项目需要实现复杂的代码分割和动态加载策略时。 当项目规模较大，需要高度定制化构建流程时。 选择Rollup： 当项目主要是编写一个独立的、面向外部发布的JavaScript库时。 当你需要最大程度地优化代码大小，去除无用的模块时。 当项目比较简单，不涉及过多的非JS资源处理，只需要专注JS模块打包优化时。 Rollup 是 ESModule 的产物，那么为什么 ESModule 会比 CommonJS 快呢？ ESModule 和 CommonJS 都是模块化的标准化方案，但它们在加载模块时的实现方式不同。 CommonJS require 是同步加载模块，也就是说，一个模块在被引入后，引入模块的代码会等待模块加载完成才继续往下执行。 CommonJS 模块是 ESModule 提出前的一种暂时性解决方案，未来发展缓慢。 而 ESModule import 是异步加载模块，它允许浏览器在解析 JavaScript 代码时，将模块的加载放到后台去，让执行线程不被阻塞。这种并行加载的方法能够提高 JavaScript 代码的执行效率。 ESModule 可以在编译时进行静态优化，还支持 Tree shaking，可以在代码打包时删除未使用的代码，从而减少打包后代码的体积和加载时间，这也是 ESModule 比 CommonJS 更快的原因之一。同时还提供了一些高级特性，比如循环引用和实时绑定 最关键的两个原因就是 TreeShaking 和 异步加载 同时 ESModule 的兼容性更佳，在未来将变得更加重要。 vite是怎么实现的 https://blog.csdn.net/weixin_44803406/article/details/135654812 Vite是一个基于ES模块的前端构建工具，与传统的构建工具（如Webpack）不同，Vite在开发模式下使用原生ES模块化。它通过服务端渲染（SSR）将源代码转换为浏览器可识别的模块，实现了快速的启动时间和开发体验。相较于Webpack等工具，Vite在开发环境下提供了更快的冷启动和热模块替换（HMR）。 核心特性 极快的开发服务器启动时间：Vite 通过利用 ES Modules 的原生支持，在开发模式下不需要打包整个应用，而是直接在浏览器中加载模块。这大大缩短了开发服务器的启动时间。 即时热模块替换（HMR）：Vite 提供了几乎即时的热模块替换功能，当你修改代码时，仅更新发生变化的模块，而不是整个页面刷新，从而显著提高开发效率。(Vite通过WebSocket与开发服务器保持连接，当源代码发生变化时，服务器会推送更新的模块到客户端，实现即时的热模块替换，无需刷新整个页面) 原生 ES 模块支持：Vite 充分利用了现代浏览器对 ES 模块的原生支持，避免了传统的打包过程，使得开发和生产环境的表现更加一致。 插件系统：Vite 支持丰富的插件生态系统，允许开发者根据需要扩展构建过程。 多种框架支持：除了 Vue.js，Vite 还支持 React、Svelte 等多种前端框架。 Vite 中的 Tree Shaking 是如何工作的。 A: Tree Shaking是一种通过静态分析代码，删除未使用代码的技术。在 Vite 中，Tree Shaking通过原生ES模块的特性，只导入用到的代码，未使用的代码不会被打包。 如何在 Vite 项目中实现服务端渲染（SSR）？ A: 安装 vite-plugin-vue@ssr 插件，并在配置文件中使用。npm install -D vite-plugin-vue@ssr // vite.config.js import VitePluginVue from ‘vite-plugin-vue’; export default { plugins: [VitePluginVue({ ssr: true })], }; 如何自定义 Vite 的配置？ 在项目根目录下创建 vite.config.js 文件，然后在文件中导出配置对象。 // vite.config.js export default { server: { //server用于配置开发服务器，例如端口、代理等。常见的配置项有 port、outDir、proxy 等 port: 3000, }, build: { // build 主要用于生产环境的配置，包括输出目录、资源引用路径等 outDir: ‘dist’, }, }; 在 Vite 中配置环境变量 在项目根目录下创建 .env 文件，例如 .env.development 和 .env.production，然后在配置文件中使用 import.meta.env 来访问环境变量 // .env.development VITE_APP_MODE=development // 在代码中使用 console.log(import.meta.env.VITE_APP_MODE); Vite 中使用插件 使用 vite.config.js 文件中的 plugins 字段来配置插件 // vite.config.js import VitePluginSass from ‘vite-plugin-sass’; export default { plugins: [VitePluginSass()], }; 用过哪些 Vite 插件？请分享一些你认为有用的插件。 一些常用的插件包括 vite-plugin-compression（用于启用 Gzip 压缩）、vite-plugin-vue（用于 Vue 项目）等。 npm install -D vite-plugin-compression // vite.config.js import ViteCompressionPlugin from ‘vite-plugin-compression’; export default { plugins: [ ViteCompressionPlugin({ algorithm: ‘gzip’, ext: ‘.gz’, }), ], }; Vite 中进行代码分割（Code Splitting） Vite默认支持动态导入实现代码分割，也可以手动配置 import.meta.glob 来进行文件的自动导入和分割。 // vite.config.js export default { build: { chunkSizeWarningLimit: 2000, }, }; Vite 中添加 Sass 支持，你会怎么做 npm install -D vite-plugin-sass // vite.config.js import VitePluginSass from ‘vite-plugin-sass’; export default { plugins: [VitePluginSass()], }; Vite 中创建一个新项目？ 使用命令 npm create vite my-project，也可以指定模板（如 vue、react）来创建具体的项目。 Vite 是如何支持模块化开发的？有什么优势？ Vite使用原生ES模块化，无需预打包，支持按需加载，提高了开发体验。可以直接在项目中使用 import/export 语法。 怎样在 Vite 中调试独立文件，而不需要重新构建整个项目？ 使用命令 vite serve --open src/main.js，其中 src/main.js 指定了入口文件，只会编译和加载该文件及其依赖。 Vite 与 Vue CLI 的提升和区别 Vue CLI 其实包含两个，一个是早期的 Vue CLI，打包基于 webpack，另一个是最新的 CLI，打包基于 vite Vue CLI 的背后是 vue-cli-service 提供支持 任何包的 package.json 文件中，都有两个参数用来指定入口，分别为：main、lib ， Main 指定的是包作为依赖时的入口文件配置 lib 指定的是当该包被全局安装时创建软链接的文件。 Vue CLI 是 Vue.js 的一个官方脚手架工具，提供了项目初始化、开发服务器启动、构建等功能。但随着项目规模的增大，Vue CLI 在开发服务器启动和热更新方面逐渐显现出性能瓶颈。Vite 的出现正是为了解决这些问题。 Vite 相较于 Vue CLI 在性能上有显著提升，主要体现在以下几个方面： 开发服务器启动时间：Vite 利用 ES 模块的特性，避免了传统打包工具（如 Webpack）的打包过程，从而使开发服务器的启动时间大大缩短。一个简单的 Vue 项目，Vite 可以在几百毫秒内启动，而 Vue CLI 可能需要几秒钟。 热更新速度：Vite 的热更新速度几乎是实时的，因为它仅重新加载发生变化的模块。而 Vue CLI 在进行热更新时，可能需要重新打包整个应用，导致更新速度较慢。 Vite Vue CLI 启动时间 通常只需几百毫秒 通常需要几秒钟到几十秒，取决于项目规模。 构建 比 Vue CLI 快，尤其是在大型项目中 利用了现代浏览器的原生 ES 模块支持，避免了打包过程，从而实现了极快的开发服务器启动时间和即时热更新 通常需要几十秒到几分钟，取决于项目规模 使用 Webpack 进行模块打包，这会导致启动时间较长，尤其是在大型项目中。尽管 Vue CLI 提供了热模块替换（HMR），但在处理大量文件时，HMR 的性能可能不如 Vite。 热模块替换（HMR） HMR 几乎是即时的，因为它仅重新加载发生变化的模块，而不需要重新打包整个应用 使用 Webpack 的 HMR 机制，虽然功能强大，但在处理大量文件时可能会出现延迟 插件生态 有一个不断增长的插件生态系统，支持 Vue、React、Svelte 等多种框架。Vite 的插件系统设计得非常灵活，允许开发者根据需要扩展构建过程。 丰富的插件生态系统，提供了大量的官方和社区插件，可以满足各种开发需求。Vue CLI 的插件系统基于 Webpack，因此可以集成各种 Webpack 插件 vite和webpack的区别 https://www.wbolt.com/vite-vs-webpack.html","categories":[{"name":"技术帖","slug":"技术帖","permalink":"http://mcdowell8023.github.io/categories/%E6%8A%80%E6%9C%AF%E5%B8%96/"}],"tags":[{"name":"web","slug":"web","permalink":"http://mcdowell8023.github.io/tags/web/"},{"name":"优化","slug":"优化","permalink":"http://mcdowell8023.github.io/tags/%E4%BC%98%E5%8C%96/"}]},{"title":"前端项目优化-4.性能指标和工具","slug":"web/前端项目优化-4-性能指标和工具","date":"2024-06-23T04:35:04.000Z","updated":"2025-03-07T18:23:53.963Z","comments":true,"path":"2024/06/23/web/前端项目优化-4-性能指标和工具/","permalink":"http://mcdowell8023.github.io/2024/06/23/web/%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96-4-%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%E5%92%8C%E5%B7%A5%E5%85%B7/","excerpt":"","text":"性能指标有哪些 加载时间相关指标‌： FP（First Paint）：页面第一次绘制像素的时间。 FCP：首次内容绘制 控制在 1.8s 以内，页面从开始加载到页面内容的任何部分在屏幕上完成渲染的时间，是测量加载速度感知的重要指标之一。 LCP：最大内容绘制 &lt;= 2.5s 合格，是指根据页面首次开始加载的时间点来报告可视区域内可见的最大图像或者文本块完成渲染的相对时间 TTI（Time to Interactive）：页面变得完全可交互的时间点‌，即页面已呈现，可以响应用户输入。 用户交互相关指标‌： FID（First Input Delay）：用户第一次与页面交互到浏览器实际响应的时间‌，反映了页面的响应速度12。 INP（Interaction to Next Paint）：衡量页面对用户交互的整体响应能力‌，取代了FID。 CLS：累计布局偏移（CLS）是测量视觉稳定性的重要指标。是整个页面声明周期内发生的所有意外布局偏移中最大一连串的布局偏移分数。 页面内容的意外偏移大多是由于异步资源加载，或者动态添加 DOM 元素到页面现有内容上方导致的。罪魁祸首可能是未知尺寸的图像或视频、实际渲染后比后备字体更大或更小的字体等。 资源加载相关指标‌： DNS 解析时间：将域名解析为 IP 地址的时间。 TCP 连接时间：建立 TCP 连接的时间。 SSL 握手时间：完成 SSL 握手的时间（如果使用 HTTPS）。 TTFB（Time to First Byte）：从请求发出到收到第一个字节的时间，反映服务器响应速度。 资源下载时间：下载各种资源（HTML、CSS、JavaScript、图片等）的时间。 其他指标‌： 白屏时间：用户看到空白页面的时间。 SI(Speed Index)：页面内容从开始加载到完全呈现所需的时间。 • 减少主线程工作 • 减少 JavaScript 执行时间 TBT：总阻塞时间，是页面被阻塞响应用户交互的总时间。 TBT = LCP （首次最大内容绘制）和可交互时间之间所有长时间任务的阻塞部分之和。是测量页面加载响应的重要指标。超过 50 毫秒的任务即为长任务，超出 50 毫秒的时间量为阻塞部分 分析工具 NetWork network面板，反应了请求资源 size 、 时长 、 数量 ， 接口响应时长 、 发起数量 、 响应状态 、报文size等; 侧重点在于分析网路链路的情况，主要关注响应时间和请求数量。 瀑布图 每一行都是一次单独的浏览器请求. 这个图越长, 说明加载网页过程中所发的请求越多. 每一行的宽度, 代表浏览器发出请求并下载该资源的过程中所耗费的时间. 构建打包分析工具 webpack-bundle-analyzer 项目构建后生成的bundle包是压缩后的，排查出一些无用的模块，过大的模块 bundle包被解析的一览无余。其中模块面积占的越大说明在bundle包中size越大。 显示包中所有打入的模块 显示模块 size 及 gzip后的size 使用 先install安装 构建包完毕后会自动弹出一个窗口展示上图信息。 1234567const BundleAnalyzerPlugin = require(&#x27;webpack-bundle-analyzer&#x27;).BundleAnalyzerPlugin;module.exports = &#123; plugins: [ new BundleAnalyzerPlugin() ]&#125; 借助 Chrome DevTools： lighthouse, performance 进行性能分析 打开 Chrome DevTools，选择 lighthouse / Performance 选项卡。 点击“Start”按钮开始性能测量。 进行页面操作，触发需要测量的性能指标。 点击“Stop”按钮结束性能测量。 火焰图推荐阅读： 可观测性之巧用 “ 火焰图 ” 快速分析链路性能 在线性能测试工具 Pingdom Load Impact WebPage Test Octa Gate Site Timer Free Speed Test Google Analytics WebPageTest 借助 performance API 进行封装上报 狠狠地研究了下 PerformanceObserver API 使用 Performance API 获取页面性能 Performance 主接口在 Window 和 Worker 全局作用域下都可用，并允许你增加自定义性能条目、清除性能条目，以及查询性能条目。通过 封装并上报三方数据平台（如，神策），进行监控。 一般 常用两种 window.performance 和 PerformanceObserver 。 window.performance: 获取页面加载的性能数据或测量代码执行时间。 PerformanceObserver: 实时监听性能事件（如页面渲染时间、用户交互延迟等）。 两者结合使用可以更全面地监控和优化页面性能。 window.performance 最简单的使用 window.performance.getEntries() 封装并上报，不需要任何参数，返回当前 Performance Timeline 上的所有条目。 返回的是一个 PerformanceEntry 对象的列表，每个对象都包含了一个性能条目的详细信息。 支持 window.performance 的浏览器环境中，可以方便地使用性能测量功能。 12345678910111213141516171819// 获取性能数据const performanceData = window.performance.getEntries()[0];// 计算关键性能指标const metrics = &#123; // DNS解析时间 dnsTime: performanceData.domainLookupEnd - performanceData.domainLookupStart, // TCP连接时间 tcpTime: performanceData.connectEnd - performanceData.connectStart, // 首字节时间 ttfb: performanceData.responseStart - performanceData.navigationStart, // DOM加载时间 domLoadTime: performanceData.domContentLoadedEventEnd - performanceData.navigationStart, // 页面完全加载时间 loadTime: performanceData.loadEventEnd - performanceData.navigationStart&#125;;// 转换为JSON字符串用于上报const metricsString = JSON.stringify(metrics); DNS解析时间： domainLookupEnd - domainLookupStart TCP建立连接时间： connectEnd - connectStart 白屏时间： responseStart - navigationStart dom渲染完成时间： domContentLoadedEventEnd - navigationStart 页面onload时间： loadEventEnd - navigationStart Performance Observer LCP 指视图中最大图像和文本块呈现的时间 1234567891011/******* 关键指标 ******/// FCP 一般来说，LCP数据会取最后一个找到的内容作为结果const observer = new PerformanceObserver((list) =&gt; &#123; list.getEntries().forEach((entry) =&gt; &#123; console.log(entry) &#125;);&#125;);observer.observe(&#123; type: &quot;paint&quot;, buffered: true&#125;); loadingTime 为 最终 LCP 值，其余参数 解析: element: 当前最大的内容绘制元素 loadingTime: 加载时间 renderTime: 渲染时间。如果是跨域请求，则为0。 size: 元素本身的面积 startTime: 如果 renderTime 不为0，则返回 renderTime；否则返回 loadingTime FCP 指的是任何内容的一部分首次在屏幕上呈现的时间。 1234567891011/******* 关键指标 ******/// FCP 与之类似的还有一个指标是 FP(First Paint) ，表示第一个像素绘制到屏幕上的时间。”const observer = new PerformanceObserver((list) =&gt; &#123; list.getEntries().forEach((entry) =&gt; &#123; console.log(entry) &#125;);&#125;);observer.observe(&#123; type: &quot;paint&quot;, buffered: true&#125;); startTime 为 最终 FCP 值，其余参数 解析: duration: 持续时间，这里是0。 startTime: 返回绘制发生时的时间戳。 FID 指的是用户首次与页面交互到浏览器实际能够开始处理程序以响应该交互的时间 12345678910111213/******* 关键指标 ******/// FID指的是用户首次与页面交互到浏览器实际能够开始处理程序以响应该交互的时间// 缩放和滚动以及持续性事件（如mousemove、pointermove、touchmove、wheel和drag）不包括在这个指标中const observer = new PerformanceObserver((list) =&gt; &#123; list.getEntries().forEach((entry) =&gt; &#123; const FID = entry.processingStart - entry.startTime; console.log(entry) &#125;);&#125;);observer.observe(&#123; type: &quot;first-input&quot;, buffered: true&#125;); processingEnd - processingStart 为 最终 FID 值，其余参数 解析: duration: 表示从 startTime 到下一个渲染绘制的时间。 processingStart: 测量用户操作与事件处理程序开始运行之间的时间。 processingEnd: 测量事件处理程序运行所花费的时间。 target: 返回关联事件的 DOM。 INP 指标通过观察用户在页面生命周期内发生的所有点击、触摸和键盘交互的延迟来评估页面对用户交互的整体响应能力。最终的 INP 值是观察到的最长交互，忽略异常值。INP 将于2024年3月12日取代 FID，成为核心 Web Vitals 指标。 NIP 仅会受到以下事件的影响： 用鼠标点击 点击带有触摸屏的设备 按下物理键盘或屏幕键盘上的某个键 与 FID 的关系： INP 考虑了所有页面交互，而 FID 仅考虑第一次交互。 INP 不仅仅关注于首次交互，而是通过对所有交互进行抽样，以全面评估响应能力，使 INP 成为比 FID 更可靠的整体响应能力指标。 由于 Performance API 中没有提供 INP 的响应能力，因此这里不提供具体示例。 只能通过三方工具获取。 CLS 衡量页面在其整个生命周期内发生的最大意外布局偏移分数 在此评估中，仅考虑元素改变其初始位置的情况，对于增加新元素到DOM或元素的宽度、高度改变等情况不予以计算。 12345678910// clsconst observer = new PerformanceObserver((list) =&gt; &#123; list.getEntries().forEach((entry) =&gt; &#123; console.log(entry) &#125;);&#125;);observer.observe(&#123; type: &quot;layout-shift&quot;, buffered: true&#125;); valuet 为 最终 CLS 值，其余参数 解析: value: 返回偏移分数，计算方式为：layout shift score = impact fraction * distance fraction。 hadRecentInput: 如果 lastInputTime 过去小于 500 毫秒，则返回 true。 lastInputTime: 返回最近排除的用户输入的时间，如果没有则返回 0。仅考虑那些用户未期望的偏移，例如在响应用户互动时发生的离散事件，如点击链接、点击按钮或请求API时显示加载等。这些情况被视为合理的偏移。 Long Task 阻塞主线程超过50毫秒的长任务, 可能导致多种不良影响，包括响应事件的延迟和动画卡顿。 当主线程被长任务占用时，浏览器无法及时响应用户输入和处理其他事件，从而影响了用户体验。 主要原因可能是： 长时间运行的事件处理程序（Long-running event handlers） **昂贵的回流（reflow）**和其他重新渲染操作，例如DOM操作、动画等 超过50毫秒的长时间循环 1234567891011// Long Taskconst observer = new PerformanceObserver((list) =&gt; &#123; list.getEntries().forEach((entry) =&gt; &#123; console.log(entry); &#125;);&#125;);observer.observe(&#123; type: &quot;longtask&quot;, buffered: true&#125;); valuet 为 最终 CLS 值，其余参数 解析: duration：表示任务的持续时间，即从开始到结束所经过的时间。 TaskAttributionTiming：是与长任务（Long Task）相关的对象，用于追踪和归因长任务的执行。这个对象可能包含关于长任务的详细信息，例如任务的来源、触发事件等。通过这个对象，开发人员可以更好地了解长任务的上下文和原因，从而进行性能优化和调试。 前端监控 ⭐️浅谈监控异常采集⭐️ 网站压测 Web「性能测试」知多少？","categories":[{"name":"技术帖","slug":"技术帖","permalink":"http://mcdowell8023.github.io/categories/%E6%8A%80%E6%9C%AF%E5%B8%96/"}],"tags":[{"name":"web","slug":"web","permalink":"http://mcdowell8023.github.io/tags/web/"},{"name":"优化","slug":"优化","permalink":"http://mcdowell8023.github.io/tags/%E4%BC%98%E5%8C%96/"}]},{"title":"前端项目优化-3. 体验优化-用户交互","slug":"web/前端项目优化-3-体验优化-用户交互","date":"2024-05-12T08:15:45.000Z","updated":"2025-03-07T18:04:14.559Z","comments":true,"path":"2024/05/12/web/前端项目优化-3-体验优化-用户交互/","permalink":"http://mcdowell8023.github.io/2024/05/12/web/%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96-3-%E4%BD%93%E9%AA%8C%E4%BC%98%E5%8C%96-%E7%94%A8%E6%88%B7%E4%BA%A4%E4%BA%92/","excerpt":"","text":"良好的用户体验设计，是产品每一个环节共同努力的结果。 除去一些很难一蹴而就的，本文将就页面展示、交互细节、可访问性三个方面入手，罗列一些在实际的开发过程中，积攒的一些有益的经验。通过本文，你将能收获到： 了解到一些小细节是如何影响用户体验的 了解到如何在尽量小的开发改动下，提升页面的用户体验 了解到一些优秀的交互设计细节 了解基本的无障碍功能及页面可访问性的含义 了解基本的提升页面可访问性的方法 页面展示 就整个页面的展示，页面内容的呈现而言，有一些小细节是需要我们注意的。 整体布局 先来看看一些布局相关的问题。 对于大部分 PC 端的项目，我们首先需要考虑的肯定是最外层的一层包裹。假设就是 .g-app-wrapper 。 123&lt;div class=&quot;g-app-wrapper&quot;&gt;&lt;/div&gt; 首先，对于 .g-app-wrapper ，有几点，是我们在项目开发前必须弄清楚的： 项目是全屏布局还是定宽布局？ 对于全屏布局，需要适配的最小的宽度是多少？ 对于定宽布局，就比较方便了，假设定宽为 1200px ，那么： 1234.g-app-wrapper &#123; width: 1200px; margin: 0 auto;&#125; 利用 margin: 0 auto 实现布局的水平居中。在屏幕宽度大于 1200px 时，两侧留白，当然屏幕宽度小于 1200px 时，则出现滚动条，保证内部内容不乱。 对于现代布局，更多的是全屏布局。其实现在也更提倡这种布局，即使用可随用户设备的尺寸和能力而变化的自适应布局。 通常而言是左右两栏，左侧定宽，右侧自适应剩余宽度，当然，会有一个最小的宽度。那么，它的布局应该是这样： 1234&lt;div class=&quot;g-app-wrapper&quot;&gt; &lt;div class=&quot;g-sidebar&quot;&gt;&lt;/div&gt; &lt;div class=&quot;g-main&quot;&gt;&lt;/div&gt;&lt;/div&gt; 12345678910111213.g-app-wrapper &#123; display: flex; min-width: 1200px;&#125;.g-sidebar &#123; flex-basis: 250px; margin-right: 10px;&#125;.g-main &#123; flex-grow: 1;&#125; 利用了 flex 布局下的 flex-grow: 1 ，让 .main 进行伸缩，占满剩余空间，利用 min-width 保证了整个容器的最小宽度。 当然，这是最基本的自适应布局。对于现代布局，我们应该尽可能的考虑更多的场景。做到： 底部 footer 下面一种情形也是非常常见的一个情景。 页面存在一个 footer 页脚部分，如果整个页面的内容高度小于视窗的高度，则 footer 固定在视窗底部，如果整个页面的内容高度大于视窗的高度，则 footer 正常流排布（也就是需要滚动到底部才能看到 footer）。 看看效果： 嗯，这个需求如果能够使用 flex 的话，使用 justify-content: space-between 可以很好的解决，同理使用 margin-top: auto 也非常容易完成： 123456&lt;div class=&quot;g-container&quot;&gt; &lt;div class=&quot;g-real-box&quot;&gt; ... &lt;/div&gt; &lt;div class=&quot;g-footer&quot;&gt;&lt;/div&gt;&lt;/div&gt; 123456789101112.g-container &#123; height: 100vh; display: flex; flex-direction: column;&#125;.g-footer &#123; margin-top: auto; flex-shrink: 0; height: 30px; background: deeppink;&#125; Codepen Demo – sticky footer by flex margin auto 当然，实现它的方法有很多，这里仅给出一种推荐的解法。 处理动态内容 - 文本超长 对于所有接收后端接口字段的文本展示类的界面。都需要考虑全面（防御性编程：所有的外部数据都是不可信的），正常情况如下，是没有问题的。 但是我们是否考虑到了文本会超长？超长了会折行还是换行？ 对于单行文本，使用单行省略： 123456&#123; width: 200px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;&#125; 当然，目前对于多行文本的超长省略，兼容性也已经非常好了： 12345678&#123; width: 200px; overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical;&#125; 处理动态内容 - 保护边界 对于一些动态内容，我们经常使用 min/max-width 或 min/max-height 对容器的高宽限度进行合理的控制。 在使用它们的时候，也有一些细节需要考虑到。 譬如经常会使用 min-width 控制按钮的最小宽度： 123.btn &#123; ... min-width: 120px;&#125; 当内容比较少的时候是没问题的，但是当内容比较长，就容易出现问题。使用了 min-width 却没考虑到按钮的过长的情况： 这里就需要配合 padding 一起： 1234.btn &#123; ... min-width: 88px; padding: 0 16px&#125; 借用Min and Max Width/Height in CSS中一张非常好的图，作为释义： 0 内容展示 这个也是一个常常被忽略的地方。 页面经常会有列表搜索，列表展示。那么，既然存在有数据的正常情况，当然也会存在搜索不到结果或者列表无内容可展示的情形。 对于这种情况，一定要注意 0 结果页面的设计，同时也要知道，这也是引导用户的好地方。对于 0 结果页面，分清楚： 数据为空：其中又可能包括了用户无权限、搜索无结果、筛选无结果、页面无数据 异常状态：其中又可能包括了网络异常、服务器异常、加载失败等待 不同的情况可能对应不同的 0 结果页面，附带不同的操作引导。 譬如网络异常： 或者确实是 0 结果： 关于 0 结果页面设计，可以详细看看这篇文章：如何设计产品的空白页面？ 小小总结一下，上述比较长的篇幅一直都在阐述一个道理，开发时，不能仅仅关注正常现象，要多考虑各种异常情况，思考全面。做好各种可能情况的处理。 图片相关 图片在我们的业务中应该是非常的常见了。有一些小细节是需要注意的。 给图片同时设置高宽 有的时候和产品、设计会商定，只能使用固定尺寸大小的图片，我们的布局可能是这样： 对应的布局： 123456&lt;ul class=&quot;g-container&quot;&gt; &lt;li&gt; &lt;img src=&quot;http://placehold.it/150x100&quot;&gt; &lt;p&gt;图片描述&lt;/p&gt; &lt;/li&gt;&lt;/ul&gt; 123ul li img &#123; width: 150px;&#125; 当然，万一假设后端接口出现一张非正常大小的图片，上述不加保护的布局就会出问题： 所以对于图片，我们总是建议同时写上高和宽，避免因为图片尺寸错误带来的布局问题： 1234ul li img &#123; width: 150px; height: 100px;&#125; 同时，给 &lt;img&gt; 标签同时写上高宽，可以在图片未加载之前提前占住位置，避免图片从未加载状态到渲染完成状态高宽变化引起的重排问题。 object-fit 当然，限制高宽也会出现问题，譬如图片被拉伸了，非常的难看： 这个时候，我们可以借助 object-fit ，它能够指定可替换元素的内容（也就是图片）该如何适应它的父容器的高宽。 12345ul li img &#123; width: 150px; height: 100px; object-fit: cover;&#125; 利用 object-fit: cover ，使图片内容在保持其宽高比的同时填充元素的整个内容框。 object-fit 还有一个配套属性 object-position ，它可以控制图片在其内容框中的位置。（类似于 background-position ），m默认是 object-position: 50% 50% ，如果你不希望图片居中展示，可以使用它去改变图片实际展示的 position 。 123456ul li img &#123; width: 150px; height: 100px; object-fit: cover; object-position: 50% 100%;&#125; 像是这样， object-position: 100% 50% 指明从底部开始展示图片。这里有一个很好的 Demo 可以帮助你理解 object-position 。 CodePen Demo – Object position 考虑屏幕 dpr – 响应式图片 正常情况下，图片的展示应该没有什么问题了。但是对于有图片可展示的情况下，我们还可以做的更好。 在移动端或者一些高清的 PC 屏幕（苹果的 MAC Book），屏幕的 dpr 可能大于 1。这种时候，我们可能还需要考虑利用多倍图去适配不同 dpr 的屏幕。 正好， &lt;img&gt; 标签是有提供相应的属性 srcset 让我们进行操作的。 123&lt;img src=&#x27;photo@1x.png&#x27; srcset=&#x27;photo@1x.png 1x, photo@2x.png 2x, photo@3x.png 3x&#x27; /&gt; 当然，这是比较旧的写法， srcset 新增了新的 w 宽度描述符，需要配合 sizes 一起使用，所以更好的写法是： 1&lt;img src=&quot;photo.png&quot; sizes=“(min-width: 600px) 600px, 300px&quot; srcset=“photo@1x.png 300w, photo@2x.png 600w, photo@3x.png 1200w,&gt; 利用 srcset ，我们可以给不同 dpr 的屏幕，提供最适合的图片。 上述出现了一些概念，dpr，图片的 srcset ，sizes 属性，不太了解的可以移步 前端基础知识概述 图片丢失 好了，当图片链接没问题时，已经处理好了。接下来还需要考虑，当图片链接挂了，应该如何处理。 处理的方式有很多种。最好的处理方式，是我最近在张鑫旭老师的这篇文章中 – 图片加载失败后CSS样式处理最佳实践 看到的。这里简单讲下： 利用图片加载失败，触发 &lt;img&gt; 元素的 onerror 事件，给加载失败的 &lt;img&gt; 元素新增一个样式类 利用新增的样式类，配合 &lt;img&gt; 元素的伪元素，展示默认兜底图的同时，还能一起展示 &lt;img&gt; 元素的 alt 信息 1&lt;img src=&quot;test.png&quot; alt=&quot;图片描述&quot; onerror=&quot;this.classList.add(&#x27;error&#x27;);&quot;&gt; 123456789101112131415img.error &#123; position: relative; display: inline-block;&#125;img.error::before &#123; content: &quot;&quot;; background: url(error-default.png);&#125;img.error::after &#123; content: attr(alt);&#125; 我们利用伪元素 before ，加载默认错误兜底图，利用伪元素 after ，展示图片的 alt 信息： OK，到此，完整的对图片的处理就算完成了，完整的 Demo 你可以戳这里看看： CodePen Demo – 图片处理 交互设计优化 接下来一个大环节是关于一些交互的细节。对于交互设计，一些比较通用的准则： Don’t make me think 符合用户的习惯与预期 操作便利 做适当的提醒 不强迫用户 过渡与动画 在我们的交互过程中，适当的增加过渡与动画，能够很好的让用户感知到页面的变化。 譬如我们页面上随处可见 loading 效果，其实就是这样一种作用，让用户感知页面正在加载，或者正在处理某些事务。 滚动优化 滚动也是操作网页中非常重要的一环。看看有哪些可以优化的点： 滚动平滑：使用 scroll-behavior: smooth 让滚动丝滑 使用 scroll-behavior: smooth ，可以让滚动框实现平稳的滚动，而不是突兀的跳动。看看效果，假设如下结构： 123456789101112&lt;div class=&quot;g-container&quot;&gt; &lt;nav&gt; &lt;a href=&quot;#1&quot;&gt;1&lt;/a&gt; &lt;a href=&quot;#2&quot;&gt;2&lt;/a&gt; &lt;a href=&quot;#3&quot;&gt;3&lt;/a&gt; &lt;/nav&gt; &lt;div class=&quot;scrolling-box&quot;&gt; &lt;section id=&quot;1&quot;&gt;First section&lt;/section&gt; &lt;section id=&quot;2&quot;&gt;Second section&lt;/section&gt; &lt;section id=&quot;3&quot;&gt;Third section&lt;/section&gt; &lt;/div&gt;&lt;/div&gt; 不使用 scroll-behavior: smooth ，是突兀的跳动切换： 给可滚动容器添加 scroll-behavior: smooth ，实现平滑滚动： 123&#123; scroll-behavior: smooth;&#125; 使用 scroll-snap-type 优化滚动效果 sroll-snap-type 可能算得上是新的滚动规范里面最核心的一个属性样式。 scroll-snap-type：属性定义在滚动容器中的一个临时点（snap point）如何被严格的执行。 光看定义有点难理解，简单而言，这个属性规定了一个容器是否对内部滚动动作进行捕捉，并且规定了如何去处理滚动结束状态。让滚动操作结束后，元素停止在适合的位置。 看个简单示例： 当然， scroll-snap-type 用法非常多，可控制优化的点很多，限于篇幅无法一一展开，具体更详细的用法可以看看我的另外一篇文章 – 使用 sroll-snap-type 优化滚动 控制滚动层级，避免页面大量重排 这个优化可能稍微有一点难理解。需要了解 CSS 渲染优化的相关知识。 先说结论，控制滚动层级的意思是尽量让需要进行 CSS 动画（可以是元素的动画，也可以是容器的滚动）的元素的 z-index 保持在页面最上方，避免浏览器创建不必要的图形层（GraphicsLayer），能够很好的提升渲染性能。 这一点怎么理解呢，一个元素触发创建一个 Graphics Layer 层的其中一个因素是： 元素有一个 z-index 较低且包含一个复合层的兄弟元素 根据上述这点，我们对滚动性能进行优化的时候，需要注意两点： 通过生成独立的 GraphicsLayer，利用 GPU 加速，提升滚动的性能 如果本身滚动没有性能问题，不需要独立的 GraphicsLayer，也要注意滚动容器的层级，避免因为层级过高而被其他创建了 GraphicsLayer 的元素合并，被动的生成一个 Graphics Layer ，影响页面整体的渲染性能 如果你对这点还有点懵，可以看看这篇文章 – 你所不知道的 CSS 动画技巧与细节 点击交互优化 在用户点击交互方面，也有一些有意思的小细节。 优化手势 – 不同场景应用不同 cursor 对于不同的内容，最好给与不同的 cursor 样式，CSS 原生提供非常多种常用的手势。 在不同的场景使用不同的鼠标手势，符合用户的习惯与预期，可以很好的提升用户的交互体验。 首先对于按钮，就至少会有 3 种不同的 cursor，分别是可点击，不可点击，等待中： 12345&#123; cursor: pointer; // 可点击 cursor: not-allowed; // 不可点击 cursor: wait; // loading&#125; 除此之外，还有一些常见的，对于一些可输入的 Input 框，使用 cursor: text ，对于提示 Tips 类使用 cursor: help ，放大缩小图片 zoom-in 、 zoom-out 等等： 一些常用的简单列一列： 按钮可点击: cursor: pointer 按钮禁止点击：cursor: not-allowed 等待 Loading 状态：cursor: wait 输入框：cursor: text; 图片查看器可放大可缩小：cursor: zoom-in/ zoom-out 提示：cursor: help; 当然，实际 cursor 还支持非常多种，可以在 MDN 或者下面这个 CodePen Demo 中查看这里看完整的列表： CodePen Demo – Cursor Demo 点击区域优化 – 伪元素扩大点击区域 按钮是我们网页设计中十分重要的一环，而按钮的设计也与用户体验息息相关。 考虑这样一个场景，在摇晃的车厢上或者是单手操作着屏幕，有的时候一个按钮，死活也点不到。 让用户更容易的点击到按钮无疑能很好的增加用户体验及可提升页面的访问性，尤其是在移动端，按钮通常都很小，但是受限于设计稿或者整体 UI 风格，我们不能直接去改变按钮元素的高宽。 那么这个时候有什么办法在不改变按钮原本大小的情况下去增加他的点击热区呢？ 这里，伪元素也是可以代表其宿主元素来响应的鼠标交互事件的。借助伪元素可以轻松帮我们实现，我们可以这样写： 12345678.btn::before &#123; content: &quot;&quot;; position: absolute; top: -10px; right: -10px; bottom: -10px; left: -10px;&#125; 当然，在 PC 端下这样子看起来有点奇怪，但是合理的用在点击区域较小的移动端则能取到十分好的效果，效果如下： 在按钮的伪元素没有其它用途的时候，这个方法确实是个很好的提升用户体验的点。 快速选择优化 – user-select: all 操作系统或者浏览器通常会提供一些快速选取文本的功能，看看下面的示意图： 快速单击两次，可以选中单个单词，快速单击三次，可以选中一整行内容。但是如果有的时候我们的核心内容，被分隔符分割，或者潜藏在一整行中的一部分，这个时候选取起来就比较麻烦。 利用 user-select: all ，可以将需要一次选中的内容进行包裹，用户只需要点击一次，就可以选中该段信息： 123.g-select-all &#123; user-select: all&#125; 给需要一次选中的信息，加上这个样式后的效果，这个细节作用在一些需要复制粘贴的场景，非常好用： CodePen – user-select: all 示例 选中样式优化 – ::selection 当然，如果你想更进一步，CSS 还有提供一个 ::selection 伪类，可以控制选中的文本的样式（只能控制 color , background , text-shadow ），进一步加深效果。 CodePen – user-select: all &amp;&amp; ::selection 控制选中样式 添加禁止选择 – user-select: none 有快速选择，也就会有它的对立面 – 禁止选择。 对于一些可能频繁操作的按钮，可能出现如下尴尬的场景： 文本按钮的快速点击，触发了浏览器的双击快速选择，导致文本被选中： 翻页按钮的快速点击，触发了浏览器的双击快速选择： 对于这种场景，我们需要把不可被选中元素设置为不可被选中，利用 CSS 可以快速的实现这一点： 12345&#123; -webkit-user-select: none; -ms-user-select: none; user-select: none;&#125; 这样，无论点击的频率多快，都不会出现尴尬的内容选中： 跳转优化 现阶段，单页应用（Single Page Application）的应用非常广泛，Vue 、React 等框架大行其道。但是一些常见的写法，也容易衍生一些小问题。 譬如，点击按钮、文本进行路由跳转。譬如，经常会出现这种代码： 1234567891011121314&lt;template&gt; ... &lt;button @click=&quot;gotoDetail&quot;&gt; Detail &lt;/button&gt; ...&lt;template&gt;...gotoDetail() &#123; this.$router.push(&#123; name: &#x27;xxxxx&#x27;, &#125;);&#125; 大致逻辑就是给按钮添加一个事件，点击之后，跳转到另外一个路由。当然，本身这个功能是没有任何问题的，但是没有考虑到用户实际使用的场景。 实际使用的时候，由于是一个页面跳转，很多时候，用户希望能够保留当前页面的内容，同时打开一个新的窗口，这个时候，他会尝试下的鼠标右键，选择在新标签页中打开页面，遗憾的是，上述的写法是不支持鼠标右键打开新页面的。 原因在于浏览器是通过读取 &lt;a&gt; 标签的 href 属性，来展示类似在新标签页中打开页面这种选项，对于上述的写法，浏览器是无法识别它是一个可以跳转的链接。简单的示意图如下： 所以，对于所有路由跳转按钮，建议都使用 &lt;a&gt; 标签，并且内置 href 属性，填写跳转的路由地址。实际渲染出来的 DOM 可能是需要类似这样： 1&lt;a href=&quot;/xx/detail&quot;&gt;Detail&lt;/a&gt; 易用性 易用性也是交互设计中需要考虑的一个非常重要的环节，能做的有非常多。简单的罗列一下： 注意界面元素的一致性，降低用户学习成本 延续用户日常的使用习惯，而不是重新创造 给下拉框增加一些预设值，降低用户填写成本 同类的操作合并在一起，降低用户的认知成本 任何操作之后都要给出反馈，让用户知道操作已经生效 先探索，后表态 这一点非常的有意思，什么叫先探索后表态呢？就是我们不要一上来就强迫用户去做一些事情，譬如登录。 想一想一些常用网站的例子： 类似虎牙、Bilibili 等视频网站，可以先观看体验，一定观看时间后才会要求登录（登录享受蓝光） 电商网站，只有到付款的时候，才需要登录 上述易用性和先探索，后表态的内容，部分来源于：Learn From What Leading Companies A/B Test，可以好好读一读。 字体优化 字体的选择与使用其实是非常有讲究的。 如果网站没有强制必须使用某些字体。最新的规范建议我们更多的去使用系统默认字体。也就是 CSS Fonts Module Level 4 – Generic font families 中新增的 font-family: system-ui 关键字。 font-family: system-ui 能够自动选择本操作系统下的默认系统字体。 默认使用特定操作系统的系统字体可以提高性能，因为浏览器或者 webview 不必去下载任何字体文件，而是使用已有的字体文件。 font-family: system-ui 字体设置的优势之处在于它与当前操作系统使用的字体相匹配，对于文本内容而言，它可以得到最恰当的展示。 举两个例子，天猫的字体定义与 Github 的字体定义： 天猫：font-family: &quot;PingFang SC&quot;,miui,system-ui,-apple-system,BlinkMacSystemFont,Helvetica Neue,Helvetica,sans-serif; Github：font-family: -apple-system,BlinkMacSystemFont,Segoe UI,Helvetica,Arial,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol; 简单而言，它们总体遵循了这样一个基本原则： 1、尽量使用系统默认字体 使用系统默认字体的主要原因是性能，并且系统字体的优点在于它与当前操作系统使用的相匹配，因此它的文本展示必然也是一个让人舒适展示效果。 2、兼顾中西，西文在前，中文在后 中文或者西文（英文）都要考虑到。由于大部分中文字体也是带有英文部分的，但是英文部分又不怎么好看，但是英文字体中大多不包含中文。通常会先进行英文字体的声明，选择最优的英文字体，这样不会影响到中文字体的选择，中文字体声明则紧随其次。 3、兼顾多操作系统 选择字体的时候要考虑多操作系统。例如 MAC OS 下的很多中文字体在 Windows 都没有预装，为了保证 MAC 用户的体验，在定义中文字体的时候，先定义 MAC 用户的中文字体，再定义 Windows 用户的中文字体； 4、兼顾旧操作系统，以字体族系列 serif 和 sans-serif 结尾 当使用一些非常新的字体时，要考虑向下兼容，兼顾到一些极旧的操作系统，使用字体族系列 serif 和 sans-serif 结尾总归是不错的选择。 对于上述的一些字体可能会有些懵，譬如 -apple-system , BlinkMacSystemFont ，这是因为不同浏览器厂商对规范的实现有所不同，对于字体定义更多的相关细节，可以再看看这篇文章 – Web 字体 font-family 再探秘 可访问性（A11Y） 可访问性，在我们的网站中，属于非常重要的一环，但是大部分前端（其实应该是设计、前端、产品）同学都会忽视它。 我潜伏在一个叫无障碍设计小组的群里，其中包含了很多无障碍设计师以及患有一定程度视觉、听力、行动障碍的用户，他们在群里经常会表达出一个观点，就是国内的大部分 Web 网站及 APP 基本没有考虑过残障人士的使用（或者可访问性做的非常差），非常的令人揪心。 尤其在我们一些重交互、重逻辑的网站中，我们需要考虑用户的使用习惯、使用场景，从高可访问性的角度考虑，譬如假设用户没有鼠标，仅仅使用键盘，能否顺畅的使用我们的网站？ 假设用户没有鼠标，这个真不一定是针对残障人士，很多情况下，用户拿鼠标的手可能在干其他事情，比如在吃东西，又或者在 TO B 类的业务，如超市收银、仓库收货，很可能用户拿鼠标的手操作着其他设备（扫码枪）等等。 本文不会专门阐述无障碍设计的方方面面，只是从一些我觉得前端工程师需要关注的，并且仅需要花费少量代价就能做好的一些无障碍设计细节。记住，无障碍设计对所有人都更友善。 色彩对比度 颜色，也是我们天天需要打交道的属性。对于大部分视觉正常的用户，可能对页面的颜色敏感度还没那么高。但是对于一小部分色弱、色盲用户，他们对于网站的颜色会更加敏感，不好的设计会给他们访问网站带来极大的不便。 什么是色彩对比度 是否曾关心过页面内容的展示，使用的颜色是否恰当？色弱、色盲用户能否正常看清内容？良好的色彩使用，在任何时候都是有益的，而且不仅仅局限于对于色弱、色盲用户。在户外用手机、阳光很强看不清，符合无障碍标准的高清晰度、高对比度文字就更容易阅读。 这里就有一个概念 – 颜色对比度，简单地说，描述就是两种颜色在亮度（Brightness）上的差别。运用到我们的页面上，大多数的情况就是背景色（background-color）与内容颜色（color）的对比差异。 最权威的互联网无障碍规范 —— WCAG AA规范规定，所有重要内容的色彩对比度需要达到 4.5:1 或以上（字号大于18号时达到 3:1 或以上），才算拥有较好的可读性。 借用一张图 – 知乎 – 助你轻松做好无障碍的15个UI设计工具推荐： 很明显，上述最后一个例子，文字已经非常的不清晰了，正常用户都已经很难看得清了。 检查色彩对比度的工具 Chrome 浏览器从很早开始，就已经支持检查元素的色彩对比度了。以我当前正在写作的页面为例子， Github Issues 编辑页面的两个按钮： 审查元素，分别可以看到两个按钮的色彩对比度： 可以看到，绿底白字按钮的色彩对比度是没有达到标准的，也被用黄色的叹号标识了出来。 除此之外，在审查元素的 Style 界面的取色器，改变颜色，也能直观的看到当前的色彩对比度： 焦点响应 类似百度、谷歌的首页，进入页面后会默认让输入框获得焦点： 并非所有的有输入框的页面，都需要进入页面后进行聚焦，但是焦点能够让用户非常明确的知道，当前自己在哪，需要做些什么。尤其是对于无法操作鼠标的用户。 页面上可以聚焦的元素，称为可聚焦元素，获得焦点的元素，则会触发该元素的 focus 事件，对应的，也就会触发该元素的 :focus 伪类。 浏览器通常会使用元素的 :focus 伪类，给元素添加一层边框，告诉用户，当前的获焦元素在哪里。 我们可以通过键盘的 Tab 键，进行焦点的切换，而获焦元素则可以通过元素的 :focus 伪类的样式，告诉用户当前焦点位置。 当然，除了 Tab 键之外，对于一些多输入框、选择框的表单页面，我们也应该想着如何简化用户的操作，譬如用户按回车键时自动前进到下一字段。一般而言，用户必须执行的触按越少，体验越佳。👍 下面的截图，完全由键盘操作完成： 通过元素的 :focus 伪类以及键盘 Tab 键切换焦点，用户可以非常顺畅的在脱离鼠标的情况下，对页面的焦点切换及操作。 然而，在许多 reset.css 中，经常能看到这样一句 CSS 样式代码，为了样式的统一，消除了可聚焦元素的 :focus 伪类： 123:focus &#123; outline: 0;&#125; 我们给上述操作的代码。也加上这样一句代码，全程再用键盘操作一下： 除了在 input 框有光标提示，当使用 Tab 进行焦点切换到 select 或者到 button 时，由于没有了 :focus 样式，用户将完全懵逼，不知道页面的焦点现在处于何处。 保证非鼠标用户体验，合理运用 :focus-visible 当然，造成上述结果很重要的一个原因在于。 :focus 伪类不论用户在使用鼠标还是使用键盘，只要元素获焦，就会触发。 而其本身的默认样式又不太能被产品或者设计接受，导致了很多人会在焦点元素触发 :focus 伪类时，通过改变 border 的颜色或者其他一些方式替代或者直接禁用。而这样做，从可访问性的角度来看，对于非鼠标用户，无疑是灾难性的。 基于此，在W3 CSS selectors-4 规范 中，新增了一个非常有意思的 :focus-visible 伪类。 :focus-visible ：这个选择器可以有效地根据用户的输入方式(鼠标 vs 键盘)展示不同形式的焦点。 有了这个伪类，就可以做到，当用户使用鼠标操作可聚焦元素时，不展示 :focus 样式或者让其表现较弱，而当用户使用键盘操作焦点时，利用 :focus-visible ，让可获焦元素获得一个较强的表现样式。 看个简单的 Demo： 1&lt;button&gt;Test 1&lt;/button&gt; 1234567button:active &#123; background: #eee;&#125;button:focus &#123; outline: 2px solid red;&#125; 使用鼠标点击： 可以看到，使用鼠标点击的时候，触发了元素的 :active 伪类，也触发了 :focus 伪类，不太美观。但是如果设置了 outline: none 又会使键盘用户的体验非常糟糕。尝试使用 :focus-visible 伪类改造一下： 1234567891011button:active &#123; background: #eee;&#125;button:focus &#123; outline: 2px solid red;&#125;button:focus:not(:focus-visible) &#123; outline: none;&#125; 看看效果，分别是在鼠标点击 Button 和使用键盘控制焦点点击 Button： CodePen Demo – :focus-visible example 可以看到，使用鼠标点击，不会触发 :foucs ，只有当键盘操作聚焦元素，使用 Tab 切换焦点时， outline: 2px solid red 这段代码才会生效。 这样，我们就既保证了正常用户的点击体验，也保证了一批无法使用鼠标的用户的焦点管理体验。 值得注意的是，有同学会疑惑，这里为什么使用了 :not 这么绕的写法而不是直接这样写呢： 1234567button:focus &#123; outline: unset;&#125;button:focus-visible &#123; outline: 2px solid red;&#125; 为的是兼容不支持 :focus-visible 的浏览器，当 :focus-visible 不兼容时，还是需要有 :focus 伪类的存在。 使用 WAI-ARIA 规范增强语义 – div 等非可获焦元素模拟获焦元素 还有一个非常需要注意的点。 现在很多前端同学在前端开发的过程中，喜欢使用非可获焦元素模拟获焦元素，譬如： 使用 div 模拟 button 元素 使用 ul 模拟下拉列表 select 等等 当下很多组件库都是这样做的，譬如 element-ui 和 ant-design。 在使用非可获焦元素模拟获焦元素的时候，一定要注意，不仅仅只是外观长得像就完事了，其行为表现也需要符合原本的 button 、 select 等可聚焦元素的性质，能够体现元素的语义，能够被聚焦，能够通过 Tab 切换等等。 基于大量类似的场景，有了 WAI-ARIA 标准，WAI-ARIA是一个为残疾人士等提供无障碍访问动态、可交互Web内容的技术规范。 简单来说，它提供了一些属性，增强标签的语义及行为： 可以使用 tabindex 属性控制元素是否可以聚焦，以及它是否/在何处参与顺序键盘导航 可以使用 role 属性，来标识元素的语义及作用，譬如使用 &lt;div id=&quot;saveChanges&quot; tabindex=&quot;0&quot; role=&quot;button&quot;&gt;Save&lt;/div&gt; 来模拟一个按钮 还有大量的 aria-* 属性，表示元素的属性或状态，帮助我们进一步地识别以及实现元素的语义化，优化无障碍体验 使用工具查看标签的语义 我们来看看 Github 页面是如何定义一个按钮的，以 Github Issues 页面的 Edit 按钮为例子： 这一块，清晰的描述了这个按钮在可访问性相关的一些特性，譬如 Contrast 色彩对比度，按钮的描述，也就是 Name ，是给屏幕阅读器看到的， Role 标识是这个元素的属性，它是一个按钮， Keyboard focusable 则表明他能否被键盘的 Tab 按钮给捕获。 分析使用非可聚焦元素模拟的按钮 这里，我随便选取了我们业务中一个使用 span 模拟按钮的场景，是一个面包屑导航，点击可进行跳转，发现惨不忍睹： HTML 代码： 1&lt;span class=&quot;ssc-breadcrumb-item-link&quot;&gt; Inbound &lt;/span&gt; 基本上可访问性为 0，作为一个按钮，它不可被聚焦，无法被键盘用户选中，没有具体的语义，色彩对比度太低，可能视障用户无法看清。并且，作为一个能进行页面跳转的按钮，它没有不是 a 标签，没有 href 属性。 即便对于面包屑导航，我们可以不将它改造成 &lt;a&gt; 标签，也需要做到最基本的一些可访问性改造： 1&lt;span role=&quot;button&quot; aria-label=&quot;goto inbound page&quot; tabindex=&quot;0&quot; class=&quot;ssc-breadcrumb-item-link&quot;&gt; Inbound &lt;/span&gt; 不要忘了再改一下颜色，达到最低色彩对比度以上，再看看： OK，这样，一个最最最基本的，满足最低可访问性需求的按钮算是勉强达标，当然，这个按钮可以再更进一步进行改造，涉及了更深入的可访问性知识，本文不深入展开。 分析组件库的 A11Y 最后，在我们比较常用的 Vue - element-ui、React - ant-design 中，我们来看看 ant-design 在提升可访问性相关的一些功能。 以 Select 选择框组件为例，ant-design 利用了大量的 WAI-ARIA 属性，使得用 div 模拟的下拉框不仅仅在表现上符合一个下拉框，在语义、行为上都符合一个下拉框，简单的一个例子： 看看使用 div 模拟下拉框的 DOM 部分： 再看看在交互体验上： 上述操作全是在键盘下完成，看着平平无奇，实际上组件库在正常响应可获焦元素切换的同时，给用 div 模拟的 select 加了很多键盘事件的响应，可以利用回车，上下键等对可选项进行选择。其实是下了很多功夫。 对于 A11Y 相关的内容，篇幅及内容非常之多，本文无法一一展开，感兴趣的可以通读下下列文章： WAI-ARIA basics WAI-ARIA 1.1 Web中的焦点管理 无障碍功能 提升Web用户体验的71个设计要点 公众号 – 无障碍设计小组","categories":[{"name":"技术帖","slug":"技术帖","permalink":"http://mcdowell8023.github.io/categories/%E6%8A%80%E6%9C%AF%E5%B8%96/"}],"tags":[{"name":"web","slug":"web","permalink":"http://mcdowell8023.github.io/tags/web/"},{"name":"优化","slug":"优化","permalink":"http://mcdowell8023.github.io/tags/%E4%BC%98%E5%8C%96/"}]},{"title":"前端项目优化-2. 性能优化-不同节点的优化","slug":"web/前端项目优化-2-性能优化-不同节点的优化","date":"2024-04-10T02:35:18.000Z","updated":"2025-03-08T05:05:57.115Z","comments":true,"path":"2024/04/10/web/前端项目优化-2-性能优化-不同节点的优化/","permalink":"http://mcdowell8023.github.io/2024/04/10/web/%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96-2-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E4%B8%8D%E5%90%8C%E8%8A%82%E7%82%B9%E7%9A%84%E4%BC%98%E5%8C%96/","excerpt":"","text":"性能优化的方向 说起性能优化，就得从 《从浏览器输入URL到页面渲染完成经历了哪些过程？》 这个问题。 基本总结下来就是分为两块 两部分： 加载层面 和 渲染层面 加载层面 就是项目文件的网络加载过程 加载层面就是网络在加载文件，核心要点就是快速加载 主要优化方向： 网络快 DNS 策略选择： 使用可靠的DNS服务提供商，避免 用户所在区域因为区域问题 导致 DNS 查询失败 使用 dns-prefetch/ preconnect，将域名解析的 IP 地址缓存到本地。 1234&lt;!-- 三方资源 DNS 预解析： --&gt;&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//example.com&quot;&gt;&lt;!-- 预链接，预先解析DNS 同时 还将进行 TCP 握手和建立传输层协议 --&gt;&lt;link rel=&quot;preconnect&quot; href=&quot;http://example.com&quot;&gt; 使用CDN 加速，将文件放在离用户更近的地方。优先 使用 CDN 预热 使用HTTP2.0，并行加载多个资源，有效减少加载时间 「通过多路复用、头部压缩等技术，可以显著提高网络性能」 避免重定向 减少请求数量，避免进入等待队列「 此处需要权衡取舍，避免单个文件过大 导致加载缓慢」：图片转化成base64、精灵图 提高服务器性能 配置更高的服务器、使用SSD硬盘、增加服务器带宽 负载均衡：将用户请求分配到多台服务器，减少单台服务器的负载，Nginx。 文件小 [可能会导致HTTP请求过多, 注意平衡] 树摇-Tree Shaking Webpack 5 默认支持 Tree Shaking，并在生产模式下自动启用。 使用 ES Module 语法（import 和 export），而不是 CommonJS 的 require 和 module.exports，以充分利用 Webpack 的静态分析功能。 在 package.json中设置 sideEffects 属性来标记模块是否存在副作用，这样可以更精确地优化。 Vite Vite 基于 Rollup，默认支持 Tree Shaking，无需额外配置。 按需加载 使用的时候才加载 如： 路由懒加载、组件懒加载、 暂时不需要的文件动态导入 动态导入组件、路由懒加载: 使用 ES6 的() =&gt; import() 语法动态导入路由组件。 123456const LazyComponent = () =&gt; import( /* webpackChunkName: &quot;lazy-component&quot; */ &#x27;./components/LazyComponent.vue&#x27;);export default &#123; components: &#123; LazyComponent &#125;&#125;; import().then动态加载 模块: 任何你觉得比较占体积的包或者文件 都可以进行 动态导入。 123import(&#x27;./store/modules/largeModule&#x27;).then(module =&gt; &#123; // 使用 module 中的内容&#125;); vue3 中的 动态组件 使用 defineAsyncComponent 进行异步组件加载 支持指定加载中组件和错误处理组件，以及相关的延时和超时设置。 12345678910111213import &#123; defineAsyncComponent&#125; from &#x27;vue&#x27;;import LoadingComponent from &#x27;./LoadingComponent.vue&#x27;;import ErrorComponent from &#x27;./ErrorComponent.vue&#x27;;const AsyncComponent = defineAsyncComponent(&#123; loader: () =&gt; import(&#x27;./MyComponent.vue&#x27;), loadingComponent: LoadingComponent, errorComponent: ErrorComponent, delay: 200, timeout: 3000,&#125;); Vue3 中的异步组件：&lt;Suspense&gt;组件 包裹异步组件，提供加载中和错误处理的功能。 12345678910111213141516171819202122&lt;template&gt; &lt;Suspense&gt; &lt;template #default&gt; &lt;AsyncComponent /&gt; &lt;/template&gt; &lt;template #fallback&gt; &lt;div&gt;Loading...&lt;/div&gt; &lt;/template&gt; &lt;/Suspense&gt;&lt;/template&gt;&lt;script&gt;import &#123; defineAsyncComponent &#125; from &#x27;vue&#x27;;const AsyncComponent = defineAsyncComponent(() =&gt; import(&#x27;./MyComponent.vue&#x27;));export default &#123; components: &#123; AsyncComponent, &#125;,&#125;;&lt;/script&gt; 借助 Aiosx 进行 对非必要 文件 进行动态加载， 如 多语言模块等 代码分割 Webpack 的 SplitChunks Webpack 提供了代码分割的功能，可以自动将代码拆分为多个块，按需加载这些块 12345678// webpack.config.jsmodule.exports = &#123; optimization: &#123; splitChunks: &#123; chunks: &#x27;all&#x27; &#125; &#125;&#125;; vite中进行代码分割 基于 Rollup 的 manualChunks 123456789101112131415// vite.config.jsexport default defineConfig(&#123; build: &#123; rollupOptions: &#123; output: &#123; manualChunks: &#123; // 手动指定分块 &#x27;vue-vendor&#x27;: [&#x27;vue&#x27;, &#x27;vue-router&#x27;], &#x27;element-plus&#x27;: [&#x27;element-plus&#x27;], &#x27;lodash-es&#x27;: [&#x27;lodash-es&#x27;], &#125; &#125; &#125; &#125;&#125;); 基于 viteplugin-chunk-split 12345678910111213141516171819202122232425262728293031// vite.config.tsimport &#123; defineConfig&#125; from &#x27;vite&#x27;;import vue from &#x27;@vitejs/plugin-vue&#x27;;import &#123; chunkSplitPlugin&#125; from &#x27;vite-plugin-chunk-split&#x27;;export default defineConfig(&#123; plugins: [ vue(), chunkSplitPlugin(&#123; customSplitting: &#123; &#x27;vue-vendor&#x27;: [&#x27;vue&#x27;, &#x27;vue-router&#x27;], &#x27;element-plus&#x27;: [&#x27;element-plus&#x27;], // 支持正则表达式。src 中 components 下的所有文件会被打包为 `components-util` 的 chunk 中 &#x27;components-util&#x27;: [/src\\/components/] &#125; &#125;) ], build: &#123; rollupOptions: &#123; output: &#123; chunkFileNames: &#x27;assets/[name].[hash].js&#x27;, entryFileNames: &#x27;assets/[name].[hash].js&#x27;, assetFileNames: &#x27;assets/[ext]/[name].[hash].[ext]&#x27;, &#125; &#125; &#125;&#125;); 动态垫片 通过垫片服务根据UserAgent返回当前浏览器代码垫片，好处是无需将繁重的代码垫片打包进去。 每次构建都配置@babel/preset-env和core-js根据某些需求将Polyfill打包进来，这无疑又为代码体积增加了贡献 压缩资源 服务开启 Gzip 压缩 对常用文本资源 开启Gzip： HTML 文件：text/html（nginx 服务器默认就会压缩）、application/xhtml+xml CSS 文件：text/css JS 文件：application/x-javascript、application/javascript、text/javascript JSON 文件（或者API请求结果）：application/json、application/geo+json、application/ld+json application/manifest+json、application/x-web-app-manifest+json XML 文件：application/xml、application/atom+xml、application/rdf+xml、application/rss+xml SVG 文件：image/svg+xml; 前端借助构建工具，预先生成gz文件，缺点是构打包后构建的产物体积会变大，优点是不耗费服务器的性能。 webpack安装 compression-webpack-plugin Vite 使用vite-plugin-compression 来实现 1234567891011121314const CompressionPlugin = require(&#x27;compression-webpack-plugin&#x27;)configurewebpack: (config) =&gt; &#123; if (process.env.NODE ENV === &#x27;production&#x27;) &#123; // 为生产环境修改配置. config.mode = &#x27;production&#x27; return &#123; plugins: [new CompressionPlugin(&#123; test: /\\.js$|\\.html$|\\.css/， //匹配文件名 threshold: 10240， //对超过10k的数据进行压缩 deleteoriginalAssets: false //是否网除原文件 &#125;)] &#125; &#125; Nginx 服务器开启 Gzip 压缩 12345//Nginx 服务器配置文件中http &#123; gzip on; gzip_types text / plain text / css application / javascript;&#125; 具体可参考启用 Gzip 压缩 最小化代码 去除冗余字符（例如不必要的注释、空格符和换行符等），减少文件大小。 JavaScript 代码的最小化和压缩： Rollup.js 和 Webpack 中都得到了应用，以降低代码体积、减少下载时间。 CSS，在 Webpack 中，通常会利用 mini-css-extract-plugin 插件进行优化。 压缩字体 TTF 字体更换为 WOFF2，体积减小 近60% 字体文件 取子集 按需压缩：借助三方工具 MP4 视频 优化 编码视频选择 “为 web 优化” 或 “为串流优化”的选项，将名称为 moov 的特殊 atom (包含 元数据信息)置于文件开头，让视频不必下载完成就可以播放，带来更好的用户体验 【译】优化 MP4 视频以便更快的网络串流 图像处理 使用图片压缩工具，将图片压缩到合适大小，减少请求次数。 选择适合的图片格式。图像格式及应用场景： SVG：用于 icon 和 logo，包含几何图形，无论缩放如何都保持清晰。 JPEG：适用于摄影图片，通过有损和无损优化减小文件大小。（适用于非透明的 banner图） PNG：适用于高分辨率图片，无损压缩，而 WebP 整体上更小。 WebP：适用于高分辨率图片，支持无损和有损压缩，文件大小更小。（注意兼容性问题） Video：对于动画，建议使用 video 而不是 GIF，因为 GIF 有颜色限制且文件大小较大。 远端图片控制：借助图床压缩服务，进行图片尺寸裁剪、压缩 等操作。 性能优化——图片压缩、加载和格式选择 缓存类 前端性能优化(三)——浏览器九大缓存方法 利用http缓存 静态资源 优先 强缓存 同域公共资源提取，最大化利用 缓存共享 前端性能优化-开启 HTTP 缓存 利用indexDB 缓存 利用indexDB 缓存 进行 图片、视频、音频等资源的缓存。如：地图项目常用于缓存瓦片数据。 特点： indexDB大小取决于你的硬盘，存储的数据量非常大。 可以直接存储任何类型的数据，如 js任何类型的数据 、blob流。 可以创建索引，提供高性能搜索功能。 采用事务，保证数据的准确性和一致性。 ServiceWorker Service Worker 是一种在浏览器后台运行的脚本，它可以拦截网络请求，缓存资源，提供离线访问等功能。 Service Worker 借助了 cacheStorage 进行缓存 通常借助 workbox-webpack-plugin 进行配置。 12345678910111213141516171819202122232425//webpack.config.js:const WorkboxPlugin = require(&#x27;workbox-webpack-plugin&#x27;);module.exports = &#123; // Other webpack config... plugins: [ // Other plugins... new WorkboxPlugin.GenerateSW(&#123; clientsClaim: true, skipWaiting: true, runtimeCaching: [&#123; urlPattern: /.\\/*/, // 需要缓存的路径 handler: &#x27;StaleWhileRevalidate&#x27;, // 缓存策略 options: &#123; cacheName: &#x27;my-webcache&#x27;, expiration: &#123; maxEntries: 2000, &#125;, &#125;, &#125;], &#125;) ]&#125;; 或者直接使用 workbox-build 进行构建。 调试示例 ServiceWorker 让你的网页拥抱服务端的能力 WorkBox 之底层逻辑Service Worker 使用 Service Worker 让首页秒开 前端更新部署后通知用户刷新 离线包 离线包个家实现方式各有不同，本质是要依赖 客户端完成。 相较于 ServiceWorker 方案，离线包 可以解决用户第一次访问 慢的问题。 货拉拉H5离线包原理与实践 离线包实现详解 Hybrid App 离线包方案实践 渲染层面 就是我们拿到文件后页面开始渲染并且交互的过程 渲染层面的配置就 落实到我们前端的具体技术细节上 阻塞策略： 位置放底部，让JS不阻塞HTML和CSS的解析 脚本与DOM/其它脚本的依赖关系很强：对 &lt;script&gt;设置defer 脚本与DOM/其它脚本的依赖关系不强：对 &lt;script&gt;设置async CSS策略： 避免-多层的嵌套规则 避免-为ID选择器添加多余选择器 避免-使用通配选择器，只对目标节点声明规则 DOM策略：（减少回流重绘） 缓存DOM计算属性 避免频繁操作 DOM 使用display控制DOM显隐，将DOM离线化 修改DOM时把其包装成微任务 使用 transform 代替 top/left 修改位置 代码实践策略： 懒加载策略 图片-懒加载：非必要图片 延后加载 图片-渐进式处理： 使用响应式图像 (srcset 和 sizes 属性) 根据设备尺寸加载合适的图像 小图先出，大图后出 前端体验优化之渐进式图片 代码业务懒加载（路由、模块、 多语言） 视频 利用 Video标签的Preload 延后加载 none: 表示视频不应预加载。 metadata: 表示仅获取视频元数据（例如长度）。 auto: 表示整个视频文件可以下载，即使用户预计不会使用它。 空字符串: auto 值的同义词。 1234567&lt;video controls preload=&quot;none&quot; poster=&quot;placeholder.jpg&quot;&gt; &lt;source src=&quot;video.mp4&quot; type=&quot;video/mp4&quot;&gt; &lt;p&gt; Your browser doesn&#x27;t support HTML video. Here is a &lt;a href=&quot;myVideo.mp4&quot; download=&quot;myVideo.mp4&quot;&gt;link to the video&lt;/a&gt; instead. &lt;/p&gt;&lt;/video&gt; 预加载策略 借助 进行 预加载、预渲染、预获取 12345678&lt;!-- 顾名思义，提前加载资源（未用到），首先要确定这个资源一定会在未来用到，然后提前加载，放入浏览器缓存中 --&gt;&lt;link rel=&quot;prefetch&quot; href=&quot;image.png&quot;&gt;&lt;!-- 指定的预获取资源具有最高的优先级，在所有 prefetch 项之前进行 --&gt;&lt;link rel=&quot;subresource&quot; href=&quot;styles.css&quot;&gt;&lt;!-- # Prerender 预先加载的资源文件，也就是说可以让浏览器提前加载指定页面的所有资源 --&gt;&lt;link rel=&quot;prerender&quot; href=&quot;http://example.com/index.html&quot;&gt; 使用 js 预加载资源，为后面页面、模块使用做准备 对于 UI 改动，推荐使用requestAnimationFrame 浏览器会在下次重绘时调用该方法，相较于 setInterval 或 setTimeout，它能够更智能地在浏览器的帧渲染中进行优化。 使用 setInterval 或 setTimeout 有可能导致回调在帧的某个点运行，可能在帧的末尾，这通常导致错过一帧，从而导致界面卡顿。 而 requestAnimationFrame 可以确保回调在浏览器准备好进行下一次重绘时执行，使得动画效果更加流畅。 避免长任务，代码优化 （执行时间超过 50 毫秒的任务） 使用 requestIdleCallback 空闲时间处理任务， 是一种优化手段 可在 主线程 空闲时调度执行低优先级或后台任务，以提高页面的响应性 利用 Promise.then 、queueMicrotask 微任务 进行包装，延后任务处理 scheduler.postTask 允许以更细粒度的方式调度任务，并且是一种帮助浏览器确定任务优先级的方法，确保低优先级任务可以释放main thread的机制。尽管目前大多数浏览器并不全面支持，但可在这里获取详细信息。 使用 Web Workers 处理耗时任务【web worker 可以让主线程另起新的线程来运行脚本】 相关推荐： 如何减少卡顿的代码级别详细文章 7种在 JavaScript 中分解长任务的技术 一文彻底了解Web Worker，十万条数据都是弟弟 首页处理 loding 骨架屏 SSR ( 需要注意 html体积，尽量只预先渲染 首屏内容) (一文彻底说清楚SSR渲染)[https://mp.weixin.qq.com/s/6pnp8F6j8MSxP7iPp_YepA]","categories":[{"name":"技术帖","slug":"技术帖","permalink":"http://mcdowell8023.github.io/categories/%E6%8A%80%E6%9C%AF%E5%B8%96/"}],"tags":[{"name":"web","slug":"web","permalink":"http://mcdowell8023.github.io/tags/web/"},{"name":"优化","slug":"优化","permalink":"http://mcdowell8023.github.io/tags/%E4%BC%98%E5%8C%96/"}]},{"title":"前端项目优化-1. 梳理源头-输入url到页面呈现","slug":"web/前端项目优化-1-梳理源头-从输入url到页面呈现","date":"2024-03-04T14:22:22.000Z","updated":"2025-03-07T18:04:01.150Z","comments":true,"path":"2024/03/04/web/前端项目优化-1-梳理源头-从输入url到页面呈现/","permalink":"http://mcdowell8023.github.io/2024/03/04/web/%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96-1-%E6%A2%B3%E7%90%86%E6%BA%90%E5%A4%B4-%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%91%88%E7%8E%B0/","excerpt":"","text":"从更高维度审视页面 作为一名合格的开发者, 要能站在用户体验角度来考虑页面性能。我们看下面几个常见的用户体验指标: 页面加载时长: 当用户请求一个网站时，如果在 1 秒内看不到关键内容，用户会产生任务被中断的感觉。 用户交互反馈时长: 当用户点击某些按钮时，如果 100ms 内无法响应，用户会感受到延迟。 Web 动画中的帧数: 如果 Web 中的动画没有达到 60fps，用户会感受到动画的卡顿。 通常，这些指标是由一系列的复杂因素导致的。如果你要开发流畅的页面，或者诊断 Web 页面中的性能问题，那你就需要了解 URL 是怎么变成页面的，以及在这个过程中都发生了什么。 比如， 首屏的显示就涉及了 DNS、HTTP、DOM 解析、CSS 阻塞、JavaScript 阻塞等技术因素，其中一项没处理好就可能导致整个页面的延时。 Chrome 多进程架构 首先，在开始讲解整个过程前，我们需要认识一下 Chrome 多进程架构。因为，从浏览器输入 URL 到页面渲染的整个过程都是由 Chrome 架构中的各个进程之间的配合完成。 Chrome 的多进程架构： 浏览器主进程，它负责用户界面（地址栏、菜单等等）、子进程的管理（例如，进程间通信和数据传递）、存储等等 渲染进程，它负责将接收到的 HTML 文档和 JavaScript 等转化为用户界面 网络进程，它负责网络资源的请求，例如 HTTP请求、WebSocket 模块 GPU（图形处理器）进程，它负责对 UI 界面的展示 插件进程，它负责对插件的管理 输入 URL 到页面呈现的过程 简单来说，整个过程可以分为以下几个步骤： DNS 解析: 用户输入 URL 后，浏览器会先进行 DNS 解析，将域名解析为 IP 地址。 建立 TCP 连接: 浏览器通过 IP 地址找到服务器后，会建立 TCP 连接。 发送 HTTP 请求: 浏览器向服务器发送 HTTP 请求。 服务器处理请求: 服务器接收到请求后，会处理请求，返回相应的数据。 浏览器接收响应: 浏览器接收到响应后，会解析响应数据，生成 DOM 树。 浏览器渲染页面: 浏览器解析 CSS，生成 CSSOM 树。 将 DOM 树和 CSSOM 树结合成 Render 树。 浏览器根据 Render 树进行页面布局和绘制。 用户可以看到页面上的内容。 关闭 TCP 连接: 当浏览器不再需要服务器返回的数据时，会关闭 TCP 连接。 页面加载完成: 页面加载完成后，用户可以看到页面上的内容。 用户可以与页面上的内容进行交互。 用户可以点击页面上的链接，转到其他页面。 用户可以输入表单数据，提交给服务器。 用户可以执行页面上的 JavaScript 代码。 解析输入 发生这个过程的前提，用户在地址栏中输入了 URL，而地址栏会根据用户输入，做出如下判断： 非URL结构的字符串，则会用浏览器默认的搜索引擎搜索该字符串 URL 结构字符串，则会 解析URL结构，浏览器进程会将完整的 URL 通过IPC，发送给网络进程 通信过程 HTTP请求流程 构建请求 首先会构建请求行，它包括：请求方法、请求url、协议版本 1GET /index.html HTTP1.1 查找HTTP缓存 根据上次请求的结果，查找缓存，分别依据强缓存 cache-control / expires 和协商缓存 last-modified / Etag 进行判断。 如果命中缓存，会直接返回缓存数据，并直接结束请求。 缓解服务器端压力，提升性能（获取资源的耗时更短了）； 对于网站来说，缓存是实现快速资源加载的重要组成部分。 具体看 (网络协议-HTTP核心问题## HTTP 缓存)[] 准备IP 和 端口 DNS 解析得到IP 首先，进行 DNS 解析域名得到对应的 IP。 DNS 解析会 经过 递归查询 客户端、系统 缓存 在到 本地 DNS 服务器，如果没有再到 遍历查询 根域名服务器、顶级域名服务器、权威 DNS 服务器。最终得到 IP 地址。 具体看 (网络协议-DNS)[] 等待 TCP 队列 浏览器对 TCP 连接数的限制, 超过 6个 TCP 链接 会进入等待队列 现代浏览器 为了优化性能和 避免过多的并发连接对服务器造成压力，会 限制对 单个域名限制 6 个并发 TCP 连接。 TCP 连接复用的限制 HTTP/1.0 中，每个请求都需要建立一个新的 TCP 连接，连接完成后立即关闭（每次都要三次握手，四次挥手） HTTP/1.1 中，尽管支持持久连接（Keep-Alive），允许复用 TCP 连接，但 每个 TCP 连接一次只能处理一个请求 HTTP/2 中，虽然 支持多路复用（一个 TCP 连接可以同时处理多个请求），但如果 某个请求被阻塞，其他请求可能会被间接阻塞 (TCP 阻塞机制 ) HTTP/3：基于 QUIC 协议（UDP），彻底解决了 TCP 的队头阻塞问题: 即使某个流（请求）被阻塞，其他流仍然可以继续传输，不会影响整个连接 如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。 建立 TCP 连接 不用等待 TCP 队列后, 拿到 IP 后， 首先，建立 TCP 连接，即三次握手过程： 客户端发送标有 SYN = 1，seq = x 的数据包，表示 将要发送请求(x 为随机数)。 服务器发送标有 SYN = 1，ACK=1, ack = x + 1，seq = y 的数据包，表示 已经收到通知，告知客户端发送请求(y 为随机数)。 客户端发送标有 ACK = 1, ack = y + 1，seq = x + 1 的数据包，表示 确认收到服务器的响应。 进行http 通信 然后，利用 TCP 通道进行数据传输： 发起 HTTP 请求 请求行 请求头 请求体（只有post请求有，get请求没有） 接收 服务器处理响应 响应行：版本协议、状态码 响应头 响应体 发包收包，不断重复这个过程 TCP 的重发机制：客户端在发送一个数据包后，未接收到服务端的确定消息，则重新发送该数据包 当接收完所有的数据包后，接收端会按照 TCP 头中的需要进行排序，形成完整的数据 关闭 TCP 连接 最后，断开 TCP 连接，即四次握手过程： 终止一个连接要经过 4次握手。 因为 CP 连接是 **全双工** (即数据在两个方向上能同时传递，同时双向传输数据)， 因此**每个方向必须单独地进行关闭** 。 这原则就是 当一方完成它的数据发送任务后，就能发送一个 FIN 来终止这个方向连接。当一端收到一个 FIN，它必须通知 应用层 另一端已经 终止了数据传送。 四次挥手过程如下： 客户端发送一个 FIN，用来关闭客户端到服务器的数据传送。 服务器收到这个 FIN，发送一个 ACK 给客户端，确认序号为收到的seq number + 1。 服务器完成发送数据，向客户端发送一个 FIN。 客户端发送一个 ACK 给服务器，确认序号为收到的seq number + 1。 数据处理 当网络进程接收到的响应报文状态码，进行相应的操作。 状态码为 200 OK 时，会解析响应报文中的 Content-Type 首部字段 解析 MIME 类型。 Content-Type 会出现 application/javascript、text/css、text/html，即对应 Javascript 文件、CSS 文件、HTML 文件。 创建渲染进程 浏览器网络线程 进行 网络通信获取HTML代码，然后进入渲染主线程的消息队列进行包装，得到渲染任务后，则需要创建渲染进程，用于后期渲染。 而对于渲染进程，如果是同一站点是可以共享一个渲染进程，例如 a.abc.com 和 c.abc.com 可以共享一个渲染渲染进程。 否则，需要重新创建渲染进程 需要注意的是，同站指的是顶级域名和二级域名相等 开始渲染 在创建完渲染进程后，网络进程会将接收到的 HTML、JavaScript 等数据传递给渲染进程。而在渲染进程接收完数据后，此时用户界面上会发生这几件事： 更新地址栏的安全状态 更新地址栏的 URL 前进后退此时 enable，显示正在加载状态 更新网页 渲染过程 大家都知道页面渲染的过程也是面试中单独会考的点，并且时常会由这个点延申出另一个问题，即如何避免回流和重绘。 渲染过程，是整个从理器输入 URL 到页面渲染过程的最后一步。而页面渲染的过程可以分为 9 个步骤： 解析html-Parse HTML 生成 DOM 树 解析 CSS 生成 CSSOM 加载或执行 JavaScript 生成渲染树（Render Tree） 布局 分层-Layer 生成绘制-Paint列表 分块-Tiling 光栅化-Raster 画-Draw（合成） 构建DOM树 &amp;&amp; 解析CSS生成CSSOM 该步骤主要生成DOM树和CSSOM树。html代码解析后生成DOM树，css代码解析后生成CSSOM树。 注意的是这个 DOM 树不同于 Chrome-devtool 中 Element 选项卡的 DOM 树，它是存在内存中的，用于提供 JavaScript 对 DOM 的操作。 在解析过程中，为了提⾼解析效率，浏览器会启动⼀个预解析器率先下载和解析 CSS。 CSS Object Model 是一组允许用 JavaScript 操纵 CSS 的 API。详细 API 讲解可以看 MDN 加载 JavaScript 通常情况下，在构建 DOM 树或 CSSOM 的同时，如果也要加载 JavaScript，会造成前者的构建的暂停。 因为JS可能会改变DOM树， 所以需要先解析，但如果声明是异步加载，那就不会暂停。当然 预解析线程可以分担⼀点下载 JS 的任务。 ⚠️ 可以通过 defer 或 sync 来实现异步加载 JavaScript。 sync ： 虽然 可以实现异步加载 JavaScript，但是 仍然会造成阻塞 defer ： 则是 等待 CSSOM 和 DOM 树构建完后才执行 JavaScript 编译和运行 JavaScript 的过程 由于 JavaScript 是解释型的语言。所以这个过程会是这样的： 针对每句代码进行分行处理，即 Token 化 根据 Token，生成 AST（Abstract Sytanx Tree） 抽象语法树和创建上下文 解释器解析和执行 AST，生成字节码。 编译器针对需要反复执行的代码，生成对应的机器码，提高运行效率 生成渲染树（Render Tree） 在有了 DOM 树和 CSSOM 之后，需要将两者结合生成渲染树 Render Tree，并且这个过程会去除掉那些 display: node 的节点。此时，渲染树就具备元素和元素的样式信息。 布局（第二次称回流） 根据 Render Tree 渲染树，对树中每个节点进行计算，确定每个节点在页面中的宽度、高度和位置。 布局树和可见内容是一一对应的，与 DOM树并不一定一一对应 1、display值为none的元素，只是不可见，DOM树 添加，布局树 不添加。 2、before伪类添加的元素，由于不算做一个单独的元素，DOM树 不添加，布局树添加。 3、浏览器在渲染过程中为了保持布局的连贯性和符合CSS规范会自动创建一些布局盒子：匿名行盒与匿名块盒，DOM树 不添加，布局树添加。 需要注意的是，第一次确定节点的大小和位置的过程称为布局，而第二次才被称为回流 分层 在现代浏览器中，为了优化渲染性能，渲染树被分解成多个层（Layers）。每个层可以独立于其他层进行渲染和合成，这有助于减少绘制和合成的工作量。 跟堆叠上下文有关的属性，会影响分层，比如 z-index ， opacity 、 transform 、 filter ，或者元素被设置为 will-change ，以及部分 3D 的效果、动画 和过度效果可能也会被分为新的层。[内容溢出存在滚轮的情况也会进行分层] 告知浏览器提前优化 will-change 相关拓展 opacity属性 与 堆叠上下文有关，因为 当元素的opacity值小于1时，它将创建一个内部的堆叠上下文。 这意味着，即使元素的z-index值较低，它的不透明部分仍然可以覆盖在其后面的元素的不透明部分。 这可能导致一些不可预见的层叠效果，因为元素的不透明度会影响其在堆叠上下文中的行为。 例如，假设有两个元素A和B，A在B的上方，A的z-index值较高，但A的opacity为0.5，B的opacity为1。在这种情况下，A的不透明部分将覆盖B，但A的半透明部分将允许B的内容显示出来。这是因为A的半透明部分创建了一个内部堆叠上下文，而B的内容在这个内部堆叠上下文中显示。 堆叠上下文的层级规则如下 根元素（通常是HTML元素）形成一个堆叠上下文。 定位元素（position属性为relative、absolute或fixed）可以形成新的堆叠上下文。 元素的z-index属性可以指定其在堆叠上下文中的层级。 某些CSS属性和值，如opacity、transform、filter等，可以创建新的堆叠上下文。 绘制-Paint (重绘在这里) 为分层结果的每⼀层⽣成如何 绘制的指令，并不是真的绘制。 到这里渲染主线程的工作 就 结束了，剩下的任务交给其他线程完成。 分块-Tiling 有了绘制列表后，渲染引擎中的合成线程会 根据 当前视口的大小 将图层进行分块处理。 这一步会将每⼀层分为多个小的区域。 分块的目的是对分层结果进行进一步细分，通过只渲染用户可以看到的部分（即视口中的部分），浏览器可以更快地完成绘制工作。 当用户滚动页面时，浏览器可以丢弃不在视口中的块，并重新绘制新进入视口的块。 此来减少内存使用，提高渲染效率，优化重绘制，改善滚动性能。 光栅化 光栅化: 合成线程会对视口附近的图块生成位图，以此提高渲染效率。 这一过程需要GPU加速 【例如使用 wil-change、opacity，就会通过 GPU 加速显示】 而渲染进程也维护了一个栅格化的线程池，专门用于将图块转为位图。 画-Draw（合成） 合成线程 计算每个位图在屏幕上的位置，交给GPU进行最终呈现。 而这个整个从绘制-Paint 阶段 生成绘制列表、光栅化、显示的过程，就是我们常说的重绘的过程 完整过程的分工情况如图： 相关问题 什么是回流/重排（reflow）？ reflow 的本质就是重新计算 layout 树。 第一次确定节点的大小和位置，称之为布局（layout） 之后对节点的大小、位置修改重新计算称之为回流 “重排/回流&quot;必然导致&quot;重绘” 比如改变一个网页元素的位置，就会同时触发&quot;重排&quot;和&quot;重绘&quot;，因为布局改变了 所以回流是一件很消耗性能的事情 什么属性会导致回流呢？ width top position.. （比如 DOM 结构发生改变 / 修改了布局） 什么是重绘 （repaint） repaint 的本质就是重新根据分层信息计算了绘制指令。 当第一次渲染内容称之为绘制（paint） 之后重新渲染称之为重绘 重绘不会带来重新布局，所以并不一定伴随重排。 浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。 什么属性会导致重绘呢？ color background box-shadow.. (比如修改背景色、文字颜色、边框颜色、样式等) 为什么transform效率高 因为 transform 既不会影响布局也不会影响绘制指令，它影响的只是渲染流程的最后一个「draw」阶段 由于 draw 阶段在合成线程中，所以 transform 的变化几乎不会影响渲染主线程。 反之，渲染主线程无论如何忙碌，也不会影响 transform 的变化。 缓存技术方案实践 静态资源优化方案与思考 配置超长时间的本地缓存 —— 节省带宽，提高性能 采用内容摘要作为缓存更新依据 —— 精确的缓存控制 静态资源 CDN 部署 —— 优化网络请求 更资源发布路径实现非覆盖式发布 —— 平滑升级 充分利用浏览器缓存机制 对于某些不需要缓存的资源，可以使用 Cache-control: no-store ，表示该资源不需要缓存 对于频繁变动的资源（比如经常需要刷新的首页，资讯论坛新闻类），可以使用 Cache-Control: no-cache 并配合 ETag 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新。 对于代码文件来说，通常使用 Cache-Control: max-age=31536000 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件。 静态资源文件通过 Service Worker 进行缓存控制和离线化加载 首屏加载 浏览器从响应用户输入网址地址，到首屏内容渲染完成的时间，此时整个网页不一定要全部染完成，但需要展示当前视窗需要的内容 利用 performance.timing 提供的数据 通过 DOMContentLoad 或者 performance 来计算出首屏时间 // 方案- document.addEventListener(‘DoMcontentLoaded’,(event)=&gt;{ console.log(‘first contentful painting’); }); // 方案二: performance.getEntriesByName(“first-contentful-paint”)[0].startTime // performance.getEntriesByName(“first-contentful-paint”)[θ] //会返回一个 PerformancePaintTiming的实例，结构如下: ｛ name:“first-contentful-paint”, entryType:“paint”, startTime:587.88888802123415, duration: 0 }｝ 首屏性能优化 性能优化 （1） 减少http请求的次数：CSS Sprites，JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存，图片服务器。 （2）前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数 （3）用innerHTML代替DOM操作，减少DOM操作次数，优化JavaScript性能。 （5）少用全局变量，缓存DOM节点查找的结果。减少IO读取操作。。 1.资源加载优化 减少资源大小 代码、图片压缩，可以利用打包工具 对HTML、CSS、JavaScript这些文件去除冗余字符（例如不必要的注释、空格符和换行符等），再进行压缩，减小文件数据大小，加快浏览器解析文件编码。 代码拆分 Gzip 1. 浏览器和服务器都需要支持gzip编码 2. 采用 LZ77 算法与 Huffman 编码来压缩文件，是一种无损压缩算法 3. 压缩比率在3-10倍左右（纯文本），可以大大节省服务器的网络带宽 重复度越高的文件可压缩的空间就越大，图片的重复度是很低，不适合 原理 1. 浏览器请求url，并在请求头中设置属性accept-encoding: gzip。这表明该浏览器是支持gzip，该参数浏览器在请求资源时会自动带上。 2. 服务器在接收到浏览器发送的请求之后，服务器会返回压缩后的文件，并在响应头中包含content-encoding: gzip。若是没有gzip文件，会返回为压缩的文件。 3. 浏览器接收到服务器的响应之后，根据content-encoding: gzip响应头使用gzip策略自动解压压缩后的资源，通过content-type内容类型决定怎么编码读取该文件内容。 应用 前端借助构建工具，预先生成gz文件，缺点是构打包后构建的产物体积会变大，优点是不耗费服务器的性能。 webpack安装compression-webpack-plugin Vite 使用vite-plugin-compression 来实现 在 vue.congig.js 中引入并修改 webpack 配置 const CompressionPlugin=require(‘compression-webpack-plugin’) configurewebpack:(config)=&gt;{ if(process.env.NODE ENV === ‘production’){ // 为生产环境修改配置. config.mode =‘production’ return { plugins:[new CompressionPlugin({ test:/.js|\\.html|.css/，//匹配文件名 threshold:10240，//对超过10k的数据进行压缩 deleteoriginalAssets:false//是否网除原文件 })] } } //在服务器我们也要做相应的配置 如果发送请求的浏览器支持 gzip， //Nginx 服务器配置文件中 http { gzip on; gzip_types text/plain text/css application/javascript; } 减少HTTP请求次数 HTTP强缓存 Expires（http1.0）和Cache-Control(http1.1 Service Worker 离线缓存 本地存储(合理利用 localStorage等) 合并文件，合并请求(nginx-http-concat模块。雪碧图等) 使Ajax可缓存。 非必须组件延迟加载。 未来所需组件预加载 提高http请求响应速度 CDN 内容分发网络 CDN服务商，网站的静态资源如图片、CSS文件、JavaScript文件等都可以缓存到CDN节点上，当用户访问网站时，CDN会根据用户的地理位置，从最近的节点提供资源，极大减少了资源加载时间。CDN还提供了缓存功能，可以进一步提高资源加载速度。 HTTP弱缓存 last-modified 和 etag 减少DNS查找时间 减少外部资源的引用 使用DNS预解析，DNS缓存将资源分布到恰当数量的主机名，平衡并行下载和DNS查询 使用可靠的DNS服务提供商 http2 新型的网络协议，通过多路复用、头部压缩等技术，可以显著提高网络性能。通过在服务器上启用HTTP/2，可以显著提高页面加载速度，Nginx配置。 server { listen 443 ssl http2; 其他配置 } 提高服务器性能 配置更高的服务器、使用SSD硬盘、增加服务器带宽 负载均衡：将用户请求分配到多台服务器，减少单台服务器的负载，Nginx。 优化资源加载时机 按需加载 UI框架按需加载 懒加载，图片懒加载 1）小图标合并成雪碧图，进而减少img的HTTP请求次数； 2）图片加载较多时，采用懒加载的方案，滚动页面可视区时再加载渲染图片 预加载(preload 等 优化资源、内容加载方式 客户端内H5页可考虑离线包等方式 内容直出 2.页面渲染优化 优化html代码 js外链放在底部，加上时间戳 避免阻塞页面的渲染。当浏览器遇到JavaScript文件时，会停止解析HTML，直到JavaScript文件加载完毕并执行完毕，这会导致页面渲染被阻塞。 CSS文件应该放在HTML文档的头部 确保在页面渲染之前，样式已经加载完毕。如果CSS文件放在底部，会导致页面在没有样式的情况下渲染，产生闪烁和白屏现象。 减少DOM数量 优化渲染关键路径方案 异步加载非关键资源，优化渲染关键路径，优化页面渲染性能，减少页面白屏时间。 优化JS：JavaScript文件加载会阻塞DOM树的构建，可以给标签添加异步属性，浏览器的HTML解析就不会被js文件阻塞。async属性表示脚本在下载完成后立即执行，而 defer 属性表示脚本在HTML解析完成后再执行。 优化CSS：浏览器每次遇到标签时，浏览器就需要向服务器发出请求获得CSS文件，然后才继续构建DOM树和CSSOM树，可以合并所有CSS成一个文件，减少HTTP请求，减少关键资源往返加载的时间，优化渲染速度。 优化js、css代码 使用webworker 为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。 长任务分片执行 减少重排、重绘 降低css选择器复杂性 当需要设置的样式很多时设置className而不是直接操作style 避免使用CSS Expression（css表达式）又称Dynamic properties(动态属性) 优化动面效果 使用requestAnimationFrame 使用 transform和opacity 属性来实现动面 合理使用wi-change战transiateZ来提升某些元素到新的合成层 使用SSR 组件或页面通过服务器生成html字符串，再发送到浏览器 从头搭建一个服务端渲染是很复杂的vue 应用建议使用 Nuxt.js 实现服务端渲染 页面卡顿定位工具 加载慢原因 原因 JavaScript 代码出现严重错误导致后续的脚本执行中断 网络延时问题 资源文件体积是否过大 资源是否重复发送请求去加载了 加载脚本的时候，渲染内容堵塞了 URL 网址无效或者含有中文字符 浏览器兼容问题 https://cloud.tencent.com/developer/article/1733071 https://zhuanlan.zhihu.com/p/144934079 检查网络连接是否正常，尝试刷新页面或重新加载。 查看浏览器控制台是否有报错信息，如果有，根据报错信息进行代码修复。 分析网页加载过程，查看是否有资源加载失败或加载时间过长的情况，逐个排查并修复。 考虑使用一些工具进行网页性能分析，找出加载速度慢的原因，并进行相应的优化。 如果问题仍然存在，可以寻求专业的前端开发人员的帮助，进行深入的调试和修复。 离线包 各域名下的 /app/webzip/zipVersion.json 开启允许跨域 每次 新增域名 需要 对其 开启允许跨域 以往都是在 s3 桶上直接配置； 少部分 app-h5部署在nodestatic目录的项目 需要 在 node 服务中配置跨域具体参照 pro 项目 离线包中使用 window.location2 代替 window.location。 window.location2 仅提供 location 的取值操作 （PS：如 reload 和 replace 方法 无法实现） 如果需要跳转 需要使用配套方法 window.KEWLWebZip.jump 依赖资源（例如 kewlglobal.js）更新，需要同步更新对应 zip 包 需要 重新打 zip 包,来更新 对应项目的 kewlglobal.js 因为替换 location，所以神策采用了本地版本 /app/js/dev/src/lib/sensorsdata.min.js zip 包 关于 svga 的部分： 服务端下发 – 图床上地址： 根据接口而来，不参与 zip 打包，无需关注 写死在 h5 本地，此处需要注意： 必须 放在 public目录 或者 assets 目录 iframe 使用 url 必须使用 window.location2 拼接全路径后使用 1const iframeUrl = `$&#123;window.location2.origin&#125;/activity/2022/dist/nightClub/index.html?source=2` 为排查 方便排查，在zip 情况时，神策上报的 url 中拼接了 zipVer=[当前zip包版本] CSS优化 内联首屏关键CSS 异步加载CSS 使用javascript将link标签插到head标签最后 设置link标签media属性为noexis，浏览器会认为当前样式表不适用当前类型，会在不阻塞页面渲染的情况下再进行下载。加载完成后，将media的值设为screen或all，从而让浏览器开始解析CSS 通过rel属性将link元素标记为alternate可选样式表，也能实现浏览器异步加载。同样别忘了加载完成之后，将rel设回stylesheet 资源压缩 利用webpack、rollup等模块化工具，将css代码进行压缩 合理使用选择器 不嵌套使用过多复杂选择器，最好不要三层以上 使用id选择器就没必要再进行嵌套 通配符和属性选择器效率最低，避免使用 减少使用昂贵的属性 如box-shadow/border-radius/filter/透明度/:nth-child等 不要使用@import @import会影响浏览器的并行下载，使得页面在加载时增加额外的延迟，增添了额外的往返耗时 而且多个@import可能会导致下载顺序紊乱 cssSprite，合成所有icon图片，减少了http请求，用宽高加上backgroud-position的背景图方式显现出我们要的icon图，background-repeat，background-position的组合background-image进行背景定位 把小的icon图片转成base64编码 CSS3动画或者过渡尽量使用transform和opacity来实现动画，不要使用left和top属性 CSS模块化 针对问题 高耦合——改样式的时候，会同时影响其他地方的样式，导致意外的样式问题 低复用——重复编写相同的样式，即枯燥乏味又导致 CSS 体积过大，从而影响开发体验与页面加载体验 https://segmentfault.com/a/1190000039772466 如果某个页面有几百个函数需要执行，可以怎么优化页面的性能? 异步执行:将函数调用转换为异步操作，使用setTimeout或requestAnimationFrame 等方法将函数分散到多个时间片中执行。这样可以避免一次性执行大量函数造成的阻塞。 分批处理:将函数分批执行，而不是一次性执行所有函数。可以使用循环和计数器来控制每个批次的函数数量，并在每个批次之间添加适当的延迟，以确保主线程有足够的空闲时间处理其他任务。 Web Worker:将函数放入Web Worker中执行，以在后台线程中进行计算，避免阻塞主线程。Web Worker可以独立于主线程运行，并发出消息来与主线程通食 函数优化:检查需要执行的函数是否可以进行优化，例如减少计算量、缓存结果、避免重复计算等。通过优化单个函数的执行效率，可以减少整体执行的时间和资源消耗 任务调度库:使用第三方任务调度库，如 async.js 或 p-queue 等，来管理并行执行和限制同时执行的函数数量。这些库提供了更灵活的任务管理和控制，可以根据需求进行配置和调整。 列表有 100000 个数据，这个该怎么进行展示? 我们需要思考的问题:该处理是否必须同步完成? 数据是否必须按顺序完成? 将数据分页，利用分页的原理，每次服务器端只返回一定数目的数据，浏览器每次只对一部分进行加载， 使用懒加载的方法，每次加载一部分数据，其余数据当需要使用时再去加载 使用数组分块技术，基本思路是为要处理的项目创建一个队列，然后设置定时器每过一段时间取出一部分数据，然后再使用定时器取出下一个要处理的项目进行处理，接着再设置另一个定时器。 虚拟列表，每次只渲染需要视口的部分 Vue 的响应性系统默认是深度的。虽然这让状态管理变得更直观，但在数据量巨大时，深度响应性也会导致不小的性能负担，因为每个属性访问都将触发代理的依赖追踪。 Vue 确实也为此提供了一种解决方案，通过使用 shallowRef() 和 shallowReactive() 来绕开深度响应。浅层式 API 创建的状态只在其顶层是响应式的，对所有深层的对象不会做任何处理。这使得对深层级属性的访问变得更快，但代价是，我们现在必须将所有深层级对象视为不可变的，并且只能通过替换整个根状态来触发更新 1234567891011121314151617181920const shallowArray = shallowRef([ /* 巨大的列表，里面包含深层的对象 */])// 这不会触发更新...shallowArray.value.push(newObject)// 这才会触发更新shallowArray.value = [...shallowArray.value, newObject]// 这不会触发更新...shallowArray.value[0].foo = 1// 这才会触发更新shallowArray.value = [ &#123; ...shallowArray.value[0], foo: 1 &#125;, ...shallowArray.value.slice(1)]","categories":[{"name":"技术帖","slug":"技术帖","permalink":"http://mcdowell8023.github.io/categories/%E6%8A%80%E6%9C%AF%E5%B8%96/"}],"tags":[{"name":"web","slug":"web","permalink":"http://mcdowell8023.github.io/tags/web/"},{"name":"优化","slug":"优化","permalink":"http://mcdowell8023.github.io/tags/%E4%BC%98%E5%8C%96/"},{"name":"追本溯源","slug":"追本溯源","permalink":"http://mcdowell8023.github.io/tags/%E8%BF%BD%E6%9C%AC%E6%BA%AF%E6%BA%90/"}]},{"title":"直播动画方案","slug":"直播/直播动画方案","date":"2024-01-20T01:38:07.000Z","updated":"2025-03-07T17:28:11.944Z","comments":true,"path":"2024/01/20/直播/直播动画方案/","permalink":"http://mcdowell8023.github.io/2024/01/20/%E7%9B%B4%E6%92%AD/%E7%9B%B4%E6%92%AD%E5%8A%A8%E7%94%BB%E6%96%B9%E6%A1%88/","excerpt":"","text":"首先梳理web场景下，动画播放的几种方式。 ‍ 方案对比 目前较常见的动画实现方案有原生动画、帧动画、gif/webp、lottie/SVGA，对于复杂动画特效的实现做个简单对比 方案 优势 劣势 css动画 使用方便 还原程度 取决工程师和 动画复杂程度； 复杂动画实现成本高 序列帧动画 实现成本低 还原程度中，比较固定，部分复杂特效不支持，且资源消耗大 gif 实现成本低 还原度低，只支持8位（256）颜色，且资源消耗大，质量较大。最重要的 不能交互 webp 实现成本低 还原程度中，资源消耗大；考虑IOS兼容问题，最重要的 不能交互 Lottie/SVGA 实现成本低 部分复杂特效不支持 透明mp4视频 性能好，一次接入永久使用 还原度高 css动画 在实现简单页面交互上是比较常用，当设计师提供较高要求的 动画效果，就比较挠头了。 gif 实现简单，质量较大。最重要的 不能交互。 Webp Webp相比PNG和JPEG格式体积可以减少25%，在移动端的平台支持上也很全面，支持24位RGB色；缺点是资源体积比较大，而且使用的软解效率低下，低端机上有明显卡顿问题。且在比较低版本的ios 机型存在 比较大的兼容问题。 最重要的 不能交互。 Lottie​/​SVGA 在不涉及mask和mattes等特性时性能非常优秀，主要耗时基本集中在Canvas#draw()上而已。然而在设计实现复杂遮罩、光影渐变上效果一般且异常消耗性能。对于直播场景的复杂特效动画而言，他们就不是一个很合适的实现方案了。 ‍ 透明mp4视频 方案 透明视频 由于出色的还原度和良好的性能，非常适合 复杂直播场景。 又详细分为以下几类： 方案 优势 劣势 video + css 滤色(cssmix-blend-mode: screen;​) 工作量小、体积小 只适用于黑色背景视频 webm透明视频 原生支持 兼容性差（透明只在Chrome和Opera中得到支持） canvas 绘制透明视频 动画效果好 CPU占用高 webgl绘制透明视频 动画效果好，CPU占用小 学习成本 video + css 滤色 实现透明 实现过程： 一个黑色背景的 **特效图片** 或者 **视频** 覆盖在目标 层上，加上 `mix-blend-mode: screen;`​ css 样式，即可实现 透明 图片或视频 播放动画的效果。 ‍ 其实现逻辑基于 混色计算方式： C = 255 - (255-A) ✖️ (255-B) / 255 如： A 是 红色 RGB(255,0,0); B 是 蓝色 RGB(0,0,255) 那么： R = 255 - (255 - 255) * (255 - 0) / 255 = 255 G = 255 - (255 - 0) * (255 - 0) / 255 = 0 B = 255 - (255 - 0) * (255 - 255) / 255 = 255 直观特性： 任何颜色和黑色执行滤色，还是呈现原来的颜色； 任何颜色和白色执行滤色得到的是白色； 任何颜色和其他颜色执行滤色模式混合后的颜色会更浅，有点类似漂白的效果。 详细讲解 戳 深入理解CSS mix-blend-mode滤色screen混合模式 ‍ 其实这种 过于简单粗暴了，如果我们的动画 背景是 黑色透明度的呢？ 上面的计算可是 没有 Alpha 通道的。这时候就要说到 绘制透明视频了 ‍ webgl绘制透明视频 原理 首先看段 视频, 这是我们设计师 实际导出 的动画视频（别误会，右侧 不是出了问题）。​​​ ‍ 我们会发现视频播放 右侧 类似高度曝光的视频，其实 记录的 Alpha 通道 的值，通常被放在 R通道。 所以 我们取出 右侧视频区域的R通道的值，与左侧原视频的RGB值 进行重新组合，绘制 RGBA 的 图片即可。然后 一帧一帧的播放 绘制即可。即可实现 上面的 第二张图的 透明视频的动画效果。 ‍ 基本原理 如果还有不明白 可以看下 这里的解释 主要有两个部分，一个是视频播放器，负责视频解码；另一个是绘制器，负责将解析出来的每一帧画面进行透明度 混合，再绘制到 Canvas 画布上。 视频播放器 ： 在素材是 MP4 的情况下，其实使用 浏览器的 video 就完全可以胜任了【 毕竟使用其他播放器解码又要增加代码体积了 】 绘制器： 至于 到底使用canvs 还是 webGL 其实就是看性能了。毕竟 webGL直接使用 GPU硬件，性能上要高上不少。 实现 视频播放器： 12345678910111213141516171819202122232425262728293031323334const src = `https://s3.amazonaws.com/liveme.storage.test/liveglb/202004171204/gifts/resource_manage/f8d6b_md5_f71ec37a5350a219500fef89335c3be9_.mp4`let playing = false;const video = document.createElement(&quot;video&quot;);video.autoplay = false;video.mute = true;video.volume = 0;video.muted = true;video.loop = loop;video.setAttribute(&quot;x-webkit-airplay&quot;, &quot;true&quot;);video.setAttribute(&quot;webkit-playsinline&quot;, &quot;true&quot;);video.setAttribute(&quot;playsinline&quot;, &quot;true&quot;);video.style.display = &quot;none&quot;;video.src = src;video.crossOrigin = &quot;anonymous&quot;;video.addEventListener(&quot;play&quot;, () =&gt; &#123;// 使用 requestAnimationFrame 开始绘制 window.requestAnimationFrame(() =&gt; &#123; drawFrame(); &#125;);&#125;);document.body.appendChild(video);// 绘制 函数function drawFrame() &#123; if (playing) &#123; // webGL 绘制 drawWebglFrame(); &#125; // 下一帧继续绘制 window.requestAnimationFrame(() =&gt; &#123; drawFrame(); &#125;);&#125; ‍ ‍ 绘制器 在使用 webGL 绘制前 ，我们需要了解一些概念。 WebGL 主要是 低级光栅化 API, 不是 3D API。要使用 WebGL 绘制图像，您必须传递表示 图像的向量。然后，它使用 OpenGL SL 将给定的 矢量 转换为 像素格式，并在屏幕上显示图像。 着色器 着色器 是使用 OpenGL ES 着色语言(GLSL) 编写的程序，它携带着 记录着像素点的位置和颜色 的信息。GLSL编写 着色器程序，并将代码文本传递给 WebGL，在 GPU 执行时编译​ 着色器 分为： 顶点着色器和片段着色器 顶点着色器 ： 主要记录着像素点的位置， 决定了 3D 物体在屏幕上的位置和形状​ 每次渲染一个形状时，顶点着色器 会在形状中的 每个顶点运行。 它的工作是将 输入顶点 从原始坐标系转换到 WebGL 使用的 裁剪空间 坐标系，其中每个轴的坐标范围从 -1.0 到 1.0，并且不考虑纵横比，实际尺寸或任何其他因素； 顶点着色器根据需要，也可以完成其他工作。例如，决定哪个包含 texel 面部纹理的坐标，可以应用于顶点；通过 法线 来确定 应用到顶点的光照因子等。 然后将这些信息存储在 变量（varyings)或属性 (attributes)属性中，以便与片段着色器共享。 片段着色器： 主要记录着像素点的颜色​ 片段着色器在 顶点着色器 处理完图形 的顶点后，会被要绘制的每个图形的每个像素点调用一次。 它的职责是 确定像素的颜色，通过指定应用到像素的纹理元素（也就是图形纹理中的像素），获取纹理元素的颜色，然后将 适当的光照应用于颜色。之后颜色存储在特殊变量 gl_FragColor 中，返回到 WebGL 层。该颜色将最终绘制到屏幕上图形对应像素的对应位置。 基本过程 12345创建着色器（顶点、片段）程序 ====&gt; 绘制创建缓冲区并绑定 ｜｜ ｜｜ 读取黄缓冲区变量 ====&gt; 赋值给顶点着色器的变量（片段着色器 从顶点着色器读取 ） ====&gt; 绘制 那么我们的思路就是 在着色器上 使用 左侧的视频帧 为底 + 右侧视频帧 的R通道最为 A通道， 那么 123456789101112131415161718192021222324252627282930313233343536 // 位置缓冲区（Position Buffer）初始化： // [具体看 裁剪空间] 中心是0，0，0 左侧 xyz 分别在 -1单位。 右侧 xyz 分别在 1 单位。都是向量单位 const positionVertice = new Float32Array([-1.0, 1.0, 1.0, 1.0, -1.0, -1.0, 1.0, -1.0 ]); const positionBuffer = gl.createBuffer(); // 创建buffer gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer); // 把缓冲区对象绑定到目标 gl.bufferData(gl.ARRAY_BUFFER, positionVertice, gl.STATIC_DRAW); // 向缓冲区对象写入刚定义的顶点数据 // 纹理缓冲区（Texture Buffer）初始化： const textureBuffer = gl.createBuffer(); /*** 定义纹理区域 ***/ // 这里将纹理 右侧 部分映射到整个画布上 给着色器 读取使用 const textureVertice = new Float32Array([ 0.0,1.0, // 左上角 0.5,1.0, // 右上角 0.0,0.0, // 左下角 0.5,0.0, // 右下角 ]); // 这部分根据 direction 选项（left 或 right）设置纹理坐标，用于将视频帧映射到矩形上。 gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer);// 片元着色器， gl_FragColor 即为每像素的颜色const vShader = ` precision lowp float; // 设置浮点数精度 varying vec2 v_texCoord; // 从顶点着色器接收的纹理坐标 uniform sampler2D u_sampler; // 纹理采样器 void main(void) &#123; // 设置像素颜色： // RGB 从当前纹理坐标采样 gl_FragColor = vec4(texture2D(u_sampler, v_texCoord).rgb, // Alpha 从偏移后的纹理坐标采样 R 通道 texture2D(u_sampler, v_texcoord+vec(0.5, 0)).r); &#125;`; ‍ 如果 ，我们的资源 反过来呢？ 右侧的视频帧 为底 + 左侧视频帧 的R通道最为 A通道。 如何处理？对坐标转换下。 123456789101112131415161718192021222324.... // 这里将纹理 右侧 部分映射到整个画布上 给着色器 读取使用 const textureVertice = new Float32Array([ 0.5, 1.0, 1.0, 1.0, 0.5, 0.0, 1.0, 0.0 ]);....// 片元着色器， gl_FragColor 即为每像素的颜色const vShader = ` precision lowp float; // 设置浮点数精度 varying vec2 v_texCoord; // 从顶点着色器接收的纹理坐标 uniform sampler2D u_sampler; // 纹理采样器 void main(void) &#123; // 设置像素颜色： // RGB 从当前纹理坐标采样 gl_FragColor = vec4(texture2D(u_sampler, v_texCoord).rgb, // Alpha 从偏移后的纹理坐标采样 R 通道 texture2D(u_sampler, v_texcoord+vec(-0.5, 0)).r); &#125;`; ‍ 当然别忘了， canvas 在 高清屏幕 绘制模糊的问题，canvas-更正分辨率​ 当然要修正下。 好上完整代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273// alpha-video-webgl.jsclass AlphaVideo &#123; constructor(option) &#123; const defaultOption = &#123; src: &quot;&quot;, autoplay: true, loop: true, canvas: null, // 默认透明视频展示大小 width: 375, height: 300, // 动画视频 所在位置，left 左，right 右 direction: &quot;left&quot;, onError: function () &#123;&#125;, onPlay: function () &#123;&#125;, &#125;; this.options = &#123; ...defaultOption, ...option, &#125;; this.radio = window.devicePixelRatio; this.directionOption = &#123; // 纹理坐标 left: &#123; // 纹理坐标 textureVertice: [ 0.0,1.0, // 左上角 0.5,1.0, // 右上角 0.0,0.0, // 左下角 0.5,0.0, // 右下角 ], // 纹理 偏移 fsSourceRadio: &#x27;0.5&#x27; &#125;, right: &#123; // 纹理坐标 textureVertice: [ 0.5, 1.0, 1.0, 1.0, 0.5, 0.0, 1.0, 0.0 ], // 纹理 偏移 fsSourceRadio: &#x27;-0.5&#x27; &#125; &#125;; this.initVideo(); this.initWebgl(); if (this.options.autoplay) &#123; this.video.play(); &#125; &#125; initVideo() &#123; const &#123; onPlay, onError, loop, src &#125; = this.options; const video = document.createElement(&quot;video&quot;); video.autoplay = false; video.mute = true; video.volume = 0; video.muted = true; video.loop = loop; video.setAttribute(&quot;x-webkit-airplay&quot;, &quot;true&quot;); video.setAttribute(&quot;webkit-playsinline&quot;, &quot;true&quot;); video.setAttribute(&quot;playsinline&quot;, &quot;true&quot;); video.style.display = &quot;none&quot;; video.src = src; video.crossOrigin = &quot;anonymous&quot;; video.addEventListener(&quot;canplay&quot;, () =&gt; &#123; this.playing = true; onPlay &amp;&amp; onPlay(); &#125;); video.addEventListener(&quot;error&quot;, () =&gt; &#123; onError &amp;&amp; onError(); &#125;); video.addEventListener(&quot;play&quot;, () =&gt; &#123; window.requestAnimationFrame(() =&gt; &#123; this.drawFrame(); &#125;); &#125;); document.body.appendChild(video); this.video = video; &#125; drawFrame() &#123; if (this.playing) &#123; this.drawWebglFrame(); &#125; window.requestAnimationFrame(() =&gt; &#123; this.drawFrame(); &#125;); &#125; drawWebglFrame() &#123; const gl = this.gl; // 配置纹理图像 gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, this.video ); // 绘制 gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4); &#125; play() &#123; this.playing = true; this.video.play(); &#125; pause() &#123; this.playing = false; this.video.pause(); &#125; initWebgl() &#123; // 设置 canvas 尺寸和点击事件 this.canvas = this.options.canvas; this.canvas.width = this.options.width * this.radio; this.canvas.height = this.options.height * this.radio; this.canvas.addEventListener(&quot;click&quot;, () =&gt; &#123; this.play(); &#125;); if (!this.canvas) &#123; this.canvas = document.createElement(&quot;canvas&quot;); document.body.appendChild(this.canvas); &#125; const gl = this.canvas.getContext(&quot;webgl&quot;); // 设置视口大小 gl.viewport( 0,0, this.options.width * this.radio, this.options.height * this.radio ); // 着色器程序设置 const program = this._initShaderProgram(gl); gl.linkProgram(program); gl.useProgram(program); const buffer = this._initBuffer(gl); // 绑定缓冲 gl.bindBuffer(gl.ARRAY_BUFFER, buffer.position); // 顶点位置 a_position 读取 绑定缓冲区 const aPosition = gl.getAttribLocation(program, &quot;a_position&quot;); // 允许属性读取，将缓冲区的值分配给特定的属性 gl.enableVertexAttribArray(aPosition); gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0); gl.bindBuffer(gl.ARRAY_BUFFER, buffer.texture); const aTexCoord = gl.getAttribLocation(program, &quot;a_texCoord&quot;); gl.enableVertexAttribArray(aTexCoord); gl.vertexAttribPointer(aTexCoord, 2, gl.FLOAT, false, 0, 0); // 绑定纹理 const texture = this._initTexture(gl); gl.bindTexture(gl.TEXTURE_2D, texture); const scaleLocation = gl.getUniformLocation(program, &quot;u_scale&quot;); gl.uniform2fv(scaleLocation, [this.radio, this.radio]); this.gl = gl; &#125; // 根据类型创建着色器 _createShader(gl, type, source) &#123; const shader = gl.createShader(type); gl.shaderSource(shader, source); gl.compileShader(shader); if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) &#123; console.error(gl.getShaderInfoLog(shader)); &#125; return shader; &#125; _initShaderProgram(gl) &#123; // 顶点 着色器glsl代码 const vsSource = ` attribute vec2 a_position; // 接收顶点位置 attribute vec2 a_texCoord; // 接收纹理坐标 varying vec2 v_texCoord; // 传递给片段着色器的纹理坐标 uniform vec2 u_scale; // 缩放因子 void main(void) &#123; gl_Position = vec4(a_position, 0.0, 1.0); // 设置顶点位置 v_texCoord = a_texCoord; // 传递纹理坐标 &#125; `; // 片段 着色器 glsl 代码 const fsSource = ` precision lowp float; // 设置浮点数精度， 必须指明float的精度，因为计算过程中片段着色器的精度没有默认 varying vec2 v_texCoord; // 从顶点着色器接收的纹理坐标 uniform sampler2D u_sampler; // 纹理采样器 void main(void) &#123; // 设置像素颜色： // RGB 从当前纹理坐标采样 gl_FragColor = vec4(texture2D(u_sampler, v_texCoord).rgb, // Alpha 从偏移后的纹理坐标采样 R 通道 texture2D(u_sampler, v_texCoord+vec2($&#123;this.directionOption[ this.options.direction].fsSourceRadio&#125;, 0)).r); &#125; `; // 创建 顶点着色器 const vsShader = this._createShader(gl, gl.VERTEX_SHADER, vsSource); // 创建 片段着色器 const fsShader = this._createShader(gl, gl.FRAGMENT_SHADER, fsSource); // 创建 着色器程序 const program = gl.createProgram(); // 将 顶点着色器程序附着到webgl gl.attachShader(program, vsShader); // 将 片段 着色器程序附着到webgl gl.attachShader(program, fsShader); // 关联着色器程序到整个绘制对象中 gl.linkProgram(program); return program; &#125; _initBuffer(gl) &#123; // 位置缓冲区（Position Buffer）初始化： // 这部分定义了一个矩形的四个顶点坐标，范围在 -1 到 1 之间，这是 WebGL 的标准化设备坐标系（NDC）。 const positionVertice = new Float32Array([ -1.0, 1.0, 1.0, 1.0, -1.0, -1.0, 1.0, -1.0, ]); const positionBuffer = gl.createBuffer(); // 创建buffer gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer); // 把缓冲区对象绑定到目标 gl.bufferData(gl.ARRAY_BUFFER, positionVertice, gl.STATIC_DRAW); // 向缓冲区对象写入刚定义的顶点数据 // 纹理缓冲区（Texture Buffer）初始化： const textureBuffer = gl.createBuffer(); // 这里将纹理 部分映射到整个画布上 const textureVertice = new Float32Array(this.directionOption[ this.options.direction].textureVertice); // 这部分根据 direction 选项（left 或 right）设置纹理坐标，用于将视频帧映射到矩形上。 gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer); // gl.STATIC_DRAW 表示数据不会频繁更改，适合静态几何形状 gl.bufferData(gl.ARRAY_BUFFER, textureVertice, gl.STATIC_DRAW); // 位置和纹理坐标都使用 Float32Array 是因为 WebGL 需要类型化数组 // 返回的两个 buffer 会在后续的渲染过程中被使用 // 这段代码是实现透明视频效果的基础，通过合理设置纹理坐标来实现 alpha 通道的映射。 return &#123; position: positionBuffer, texture: textureBuffer, &#125;; &#125; _initTexture(gl) &#123; const texture = gl.createTexture(); gl.bindTexture(gl.TEXTURE_2D, texture); // 对纹理图像进行y轴反转，因为WebGL纹理坐标系统的t轴（分为t轴和s轴）的方向和图片的坐标系统Y轴方向相反。因此将Y轴进行反转。 gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1); // 配置纹理参数 gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE); return texture; &#125;&#125; ‍ 调用测试下： 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;透明视频&lt;/title&gt; &lt;style&gt; .canvas &#123; width: 414px; height: 896px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body style=&quot;background-color: black;&quot;&gt; &lt;canvas class=&quot;canvas&quot; id=&quot;AlphaVideoCanvas&quot; width=&quot;414&quot; height=&quot;896&quot;&gt;&lt;/canvas&gt; &lt;script src=&quot;./alpha-video-webgl.js&quot; inline&gt;&lt;/script&gt; &lt;script&gt; // 动画视频 在左侧 const url_left = `https://s3.amazonaws.com/liveme.storage.test/liveglb/202004171204/gifts/resource_manage/f8d6b_md5_f71ec37a5350a219500fef89335c3be9_.mp4` // 动画视频 在右侧 const url_right = `https://dlied5sdk.myapp.com/music/release/upload/t_mm_file_publish/2868412.mp4`; this.headMv = new AlphaVideo(&#123; src: url_left, width: 414, height: 896 * 375/400, loop: true, // 是否循环播放 canvas: document.getElementById(&#x27;AlphaVideoCanvas&#x27;), // direction: &quot;right&quot;, // 动画视频的播放方向，left:原来视频在左侧 ；right: 原视频在右侧 &#125;); this.headMv.play(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"技术帖","slug":"技术帖","permalink":"http://mcdowell8023.github.io/categories/%E6%8A%80%E6%9C%AF%E5%B8%96/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://mcdowell8023.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"直播","slug":"直播","permalink":"http://mcdowell8023.github.io/tags/%E7%9B%B4%E6%92%AD/"},{"name":"动画","slug":"动画","permalink":"http://mcdowell8023.github.io/tags/%E5%8A%A8%E7%94%BB/"}]},{"title":"网络协议-HTTP核心问题","slug":"网络协议-HTTP核心问题","date":"2023-12-18T06:33:42.000Z","updated":"2025-03-09T04:42:53.560Z","comments":true,"path":"2023/12/18/网络协议-HTTP核心问题/","permalink":"http://mcdowell8023.github.io/2023/12/18/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-HTTP%E6%A0%B8%E5%BF%83%E9%97%AE%E9%A2%98/","excerpt":"","text":"HTTP/1.0、HTTP/1.1、HTTP/2 和 HTTP/3 别再说 http是短链接了！！！ 从 HTTP/1.1 引入后，支持了 keep-alive 就可以保持长链接了。 注意是说保持 长链接状态。 因为 长短链接 说的是tcp连接 是否继续保持。 所以 最多只能说 HTTP/1.0 无法 进行链接 HTTP/1.0、HTTP/1.1、HTTP/2 和 HTTP/3 是互联网上用于客户端和服务器之间通信的不同版本的超文本传输协议（HTTP）。每个版本都引入了新的特性和改进，以提高性能、效率和安全性。以下是它们的主要区别： 1. HTTP/1.0 发布时间：1996年 特点： 简单：每个请求/响应对都需要建立一个新的 TCP 连接。 无连接复用：一个 TCP 连接只能处理一个请求，导致“连接开销”较高。 无持久连接：请求完成后立即关闭连接。 无管道化：请求必须按顺序处理，不能同时发送多个请求。 单工通信：因为它使用短连接，请求完成后立即关闭连接。数据单向传输 缺点： 性能较低，尤其是在加载包含多个资源（如图片、CSS、JavaScript）的页面时。 无法有效利用底层 TCP 连接的性能。 2. HTTP/1.1 发布时间：1997年 改进： 持久连接：通过 Connection: keep-alive 头部，多个请求可以复用同一个 TCP 连接，减少了连接开销[1]。 管道化：允许客户端在同一个连接上发送多个请求，而无需等待前一个请求的响应[2]。 分块传输编码：支持分块传输，允许服务器动态生成响应内容[3]。 请求范围：支持范围请求（Range Requests），允许客户端请求资源的一部分[4]。 半双工通信： 虽然 有了keep-alive,仍然是 请求-应答模型。同一时刻，只能数据单向传输 缺点： 尽管引入了持久连接和管道化，但仍然存在“队头阻塞”问题（Head-of-Line Blocking, HOLB），即一个请求的延迟会影响后续所有请求[5]。 对于包含大量资源的页面，性能瓶颈仍然存在。 3. HTTP/2 发布时间：2015年 改进： 多路复用（Multiplexing）：在同一个 TCP 连接上可以同时发送多个请求和响应，解决了 HTTP/1.1 的队头阻塞问题。 二进制分帧（Binary Framing）：将 HTTP 请求和响应分割成二进制帧，提高传输效率。 头部压缩（HPACK）：通过压缩 HTTP 头部，减少了头部信息的大小，从而提高传输速度。 服务器推送（Server Push）：允许服务器主动推送资源到客户端，减少了客户端的额外请求。 全双工的： 流（stream）的概念，允许多个流复用一条 TCP 连接，双方可以同时发送和接收数据。数据同时双向传输 缺点： 仍然基于 TCP，TCP 的连接建立和拥塞控制机制可能成为性能瓶颈。 部署和调试相对复杂，需要支持 TLS（HTTPS）。 4. HTTP/3 发布时间：2020年 改进： 基于 QUIC 协议：HTTP/3 基于 QUIC（Quick UDP Internet Connections），这是一个基于 UDP 的传输协议。 减少连接延迟：QUIC 的连接建立时间比 TCP 更快，因为它减少了握手的往返次数 更好的拥塞控制：QUIC 提供了更高效的拥塞控制机制，能够更好地适应网络状况 无队头阻塞（No HOLB）：即使在多路复用中，一个请求的延迟也不会影响其他请求 连接迁移：支持在不同网络之间迁移连接（例如从 Wi-Fi 切换到移动网络），而不会中断连接 缺点： 部署难度较高，需要支持 QUIC 和 TLS 1.3 UDP 的不可靠性需要额外的机制来保证数据的完整性和顺序 总结 版本 基础协议 主要特性 优点 缺点 HTTP/1.0 TCP 简单，无持久连接 实现简单 性能低，连接开销大 HTTP/1.1 TCP 持久连接，管道化 性能提升，支持范围请求 队头阻塞 HTTP/2 TCP 多路复用，二进制分帧，头部压缩 高效传输，减少延迟 部署复杂，依赖 TLS HTTP/3 QUIC (UDP) 无队头阻塞，连接迁移，更快的连接建立 最高性能，适应性更强 部署难度高，依赖 UDP HTTP/2 和 HTTP/3 是目前主流的协议，HTTP/3 正在逐步普及。对于现代网站，建议优先支持 HTTP/2 和 HTTP/3，以提升用户体验和性能。 HTTP 和 HTTPS 的区别 核心区别： HTTP 基于 TCP 协议，信息是明文传输； HTTPS 在 TCP 之上引入了 TLS/SSL 协议, 信息是加密传输。 HTTP（HyperText Transfer Protocol，超文本传输协议）和 HTTPS（HyperText Transfer Protocol Secure，安全超文本传输协议）是用于客户端和服务器之间通信的两种协议。 1. 安全性 HTTP： 不加密：HTTP 数据以明文形式传输，包括请求头、请求体、响应头和响应体等。这意味着数据在传输过程中容易被窃听、篡改或伪造。 无身份验证：HTTP 不提供身份验证机制，无法验证服务器或客户端的身份，容易受到中间人攻击（MITM）。 HTTPS： 加密传输：HTTPS 在 HTTP 的基础上引入了 TLS（Transport Layer Security，传输层安全协议）或 SSL（Secure Sockets Layer，安全套接字层）加密。所有数据在传输前都会被加密，确保数据的机密性和完整性。 身份验证：通过数字证书（由证书颁发机构 CA 颁发）验证服务器的身份，客户端可以确信自己正在与合法的服务器通信，防止中间人攻击。 2. 传输方式 HTTP： 基于 TCP：HTTP/1.0 和 HTTP/1.1 使用 TCP 作为传输层协议。 明文传输：数据以明文形式传输，容易被网络设备（如路由器、代理服务器）读取和篡改。 HTTPS： 基于 TLS/SSL：HTTPS 在 TCP 之上引入了 TLS/SSL 层，用于加密数据。 加密传输：数据在传输前被加密，只有合法的接收方才能解密。即使数据被中间设备截获，也无法读取其内容。 证书机制：服务器必须提供有效的 SSL/TLS 证书，客户端通过证书验证服务器的身份。 3. 性能 HTTP： 性能较高：由于没有加密和解密的开销，HTTP 在传输速度上通常比 HTTPS 稍快。 无连接开销：HTTP/1.0 每次请求都需要建立新的 TCP 连接，HTTP/1.1 支持持久连接（Keep-Alive），但仍然存在连接管理的开销。 HTTPS： 加密开销：TLS 握手过程需要额外的计算和网络往返，增加了连接建立的时间和资源消耗。 性能优化：现代 HTTPS 实现（如 HTTP/2 和 HTTP/3）通过多路复用、头部压缩、服务器推送等技术，显著提高了性能，减少了加密开销对性能的影响。 HTTP/2 和 HTTP/3：HTTPS 是 HTTP/2 和 HTTP/3 的默认传输方式，这些协议通过优化传输效率，弥补了加密带来的性能损失。 4. 证书和信任机制 HTTP： 无需证书：HTTP 不需要证书，任何服务器都可以提供服务。 HTTPS： 需要证书：服务器必须安装有效的 SSL/TLS 证书，证书由受信任的证书颁发机构（CA）签发。 证书验证：客户端会验证服务器证书的有效性，包括证书的颁发机构、有效期、域名匹配等。如果证书无效或不可信，客户端会拒绝连接。 5. URL 格式 HTTP： URL 以 http:// 开头，例如 http://example.com。 HTTPS： URL 以 https:// 开头，例如 https://example.com。 6. 浏览器支持和默认行为 HTTP： 浏览器通常会允许用户访问 HTTP 网站，但会显示“不安全”的警告。 HTTPS： 浏览器优先支持 HTTPS，并且会显示“安全”或“锁”图标，表示连接是加密的。 现代浏览器（如 Chrome）会逐步淘汰对 HTTP 的支持，鼓励网站使用 HTTPS。 7. 应用场景 HTTP： 适用于对安全性要求不高的场景，如公共信息页面。 由于性能较高，HTTP 仍然在某些内部网络或局域网中使用。 HTTPS： 适用于所有需要保护用户隐私和数据安全的场景，如电子商务、在线银行、用户登录、个人数据传输等。 已成为现代互联网的标准协议，几乎所有主流网站都已迁移到 HTTPS。 总结 特性 HTTP HTTPS 安全性 明文传输，无加密 加密传输，防止窃听和篡改 身份验证 无 通过 SSL/TLS 证书验证服务器身份 传输方式 基于 TCP 基于 TLS/SSL 加密的 TCP 性能 稍快（无加密开销） 稍慢（加密开销），但可通过 HTTP/2 和 HTTP/3 优化 证书需求 无需证书 需要有效的 SSL/TLS 证书 URL 格式 http:// https:// 浏览器支持 显示“不安全”警告 显示“安全”或“锁”图标 应用场景 公共信息页面 电子商务、在线银行、用户登录等 http请求 有了keep-alive 可以代替websocket 么？ 首先明确长连接：TCP连接一直不断开的连接 keep-alive能实现长连接，但是有时间限制，最多时间长一些而已 目的主要是进行tcp连接复用的, 如 网站加载场景进行多并发 服务不能主动发送消息，虽然 HTTP/2 协议引入了 Server Push（服务器推送）功能,仍然需要客户端发起初始请求来触发 需要服务端支持keep-alive，因为TCP连接的断开是双向的，不是客户端说我要保持连接就行 HTTP 和 TCP 的关系 HTTP（HyperText Transfer Protocol，超文本传输协议）和 TCP（Transmission Control Protocol，传输控制协议）是网络通信中两个不同层次的协议，它们之间存在紧密的关系。 关系：HTTP 协议 基于TCP协议来实现数据的可靠传输。HTTP 请求和响应数据通过 TCP 连接进行传输。 TCP 是 HTTP 的传输基础：HTTP 协议依赖 TCP 提供的可靠传输、流量控制和拥塞控制等特性来 确保数据的 完整性和稳定性。 HTTP 是 TCP 的应用层协议：HTTP 在 TCP 之上运行，通过 TCP 连接发送请求和接收响应。 两者相辅相成：TCP 为 HTTP 提供了可靠的传输通道，而 HTTP 则利用 TCP 的特性实现了高效的超文本数据传输。 层次关系 TCP 是 传输层 协议，位于 OSI 七层模型的第四层。 它的主要作用是为应用程序提供可靠的、面向连接的 字节流服务 。 TCP 负责数据的传输、错误检测与纠正、流量控制以及拥塞控制等。 HTTP 是 应用层 协议，位于 OSI 七层模型的第七层。 它是一种用于客户端和服务器之间传输超文本的协议，主要用于浏览器与服务器之间的通信，以获取网页内容（HTML、图片、CSS、JavaScript 等）。 TCP 为 HTTP 提供的服务 可靠传输：TCP 是一种面向连接的协议，它通过三次握手建立连接，确保数据在传输过程中不会丢失、重复或乱序。 HTTP 协议依赖 TCP 的可靠传输特性，保证请求和响应数据能够完整、准确地到达对方。 流量控制与拥塞控制：TCP 通过 滑动窗口机制对流量进行控制，避免发送方发送过多数据导致接收方处理不过来。 TCP 的拥塞控制机制能够根据网络状况动态调整传输速率，避免网络拥塞。这对于 HTTP 数据传输的稳定性和效率至关重要。 面向字节流：TCP 将数据封装成字节流的形式进行传输，HTTP 请求和响应数据被封装在 TCP 数据包中，通过网络传输到目标地址。 HTTP 如何使用 TCP 建立连接：当客户端（如浏览器）发起 HTTP 请求时，首先需要通过 TCP 建立一个到服务器的连接。这个过程称为 三次握手： 客户端发送一个 SYN 数据包到服务器。 服务器回应一个 SYN-ACK 数据包。 客户端发送一个 ACK 数据包确认连接建立。 数据传输：TCP 连接建立后，客户端通过 TCP 发送 HTTP 请求报文（包括请求行、请求头和请求体），服务器通过 TCP 返回 HTTP 响应报文（包括状态行、响应头和响应体）。 关闭连接：数据传输完成后，客户端和服务器通过 四次挥手 断开 TCP 连接： 客户端发送 FIN 数据包请求关闭连接。 服务器回应 ACK 数据包确认。 服务器发送 FIN 数据包请求关闭连接。 客户端回应 ACK 数据包确认。 HTTP/2 和 HTTP/3 的改进 HTTP/2：引入了多路复用、二进制分帧、头部压缩等技术，但仍然基于 TCP。HTTP/2 的改进主要是在应用层优化数据传输效率，而 TCP 仍然负责底层的可靠传输。 HTTP/3：基于 QUIC 协议（一种基于 UDP 的传输层协议），而不是 TCP。QUIC 提供了类似 TCP 的可靠性，同时减少了连接建立的延迟，并且支持更快的多路复用和拥塞控制。HTTP/3 的出现是为了进一步提升网络性能，但 TCP 仍然是 HTTP 的主要传输协议。 面试常问的 http 状态码 1. 301 Moved Permanently 含义：永久重定向： 表示请求的资源已被永久移动到新的 URL。浏览器会自动将请求的 URL 替换为新的 URL，并且搜索引擎会将旧 URL 的权重和排名转移到新的 URL 应用场景：用于资源的永久重定向，客户端应更新书签或链接。 面试要点：理解其与 302 Found 的区别，以及对搜索引擎优化（SEO）的影响。 2. 302 Found 含义： 临时重定向 ： 浏览器会自动跳转，但 搜索引擎会保留旧 URL 的权重和排名，认为这是一个临时的跳转。 应用场景：用于临时重定向，客户端应继续使用旧的 URI。 面试要点：理解其与 301 的区别，以及浏览器对 302 的默认行为（可能会将 POST 转换为 GET）。 4. 304 Not Modified 含义：请求的资源未被修改，客户端可以 继续使用本地缓存。 应用场景：用于缓存机制，减少不必要的数据传输。 面试要点：理解其与缓存头（如 ETag 和 Last-Modified）的关系，以及如何通过条件请求实现高效的缓存验证。 5. 400 Bad Request 含义：请求格式错误，服务器无法理解。 应用场景：客户端发送了无效的请求数据。 面试要点：理解如何通过合理的错误提示帮助客户端修正请求。 6. 401 Unauthorized 含义： 没登陆 应用场景：客户端未提供有效的认证信息。 面试要点：理解其与 403 Forbidden 的区别，以及如何处理认证失败的情况。 7. 403 Forbidden 含义： 权限不足 应用场景：客户端已认证，但没有足够的权限。 面试要点：理解其与 401 的区别，以及如何处理权限不足的情况。 8. 404 Not Found 含义：请求的资源不存在。 应用场景：客户端请求了一个不存在的资源。 面试要点：理解如何处理 404 错误，例如提供友好的错误页面或日志记录。 9. 405 Method Not Allowed 含义：请求方法不被允许。 请求方法错误 应用场景：客户端使用了不支持的 HTTP 方法（如 POST 请求了一个只支持 GET 的资源）。 面试要点：理解如何在服务器端配置允许的请求方法。 10. 500 Internal Server Error 含义：服务器内部错误，无法处理请求。 应用场景：服务器端发生未处理的异常。 面试要点：理解如何调试和处理服务器错误，以及如何避免将敏感信息暴露给客户端。 11. 502 Bad Gateway 含义：服务器作为 网关 错误。 应用场景：通常出现在微服务架构或反向代理场景中。 面试要点：理解其与 500 的区别，以及如何排查网关或代理问题。 12. 503 Service Unavailable 含义：服务器暂时不可用（例如过载或维护）。 应用场景：服务器负载过高或正在进行维护。 面试要点：理解如何处理服务不可用的情况，例如返回重试时间或使用负载均衡。","categories":[{"name":"基础","slug":"基础","permalink":"http://mcdowell8023.github.io/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://mcdowell8023.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"http","slug":"http","permalink":"http://mcdowell8023.github.io/tags/http/"}]},{"title":"网络协议-浏览器中的HTTP请求","slug":"网络协议-浏览器中的HTTP请求","date":"2023-12-01T04:38:56.000Z","updated":"2025-03-07T17:29:11.129Z","comments":true,"path":"2023/12/01/网络协议-浏览器中的HTTP请求/","permalink":"http://mcdowell8023.github.io/2023/12/01/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84HTTP%E8%AF%B7%E6%B1%82/","excerpt":"","text":"浏览器发起 HTTP 请求的一般步 ： 检查本地缓存：检查是否存在本地缓存，如果存在直接使用。 DNS 解析：将域名解析为 IP 地址。 ARP 查询：获取目标 IP 地址对应的 MAC 地址（如果在同一局域网内）。 TCP 三次握手：通过 TCP 三次握手建立连接。 TLS 握手: 用于在浏览器和服务器之间协商加密参数和验证身份 基于 TCP 数据流 发送 HTTP 请求：通过建立的 TCP 连接将 HTTP 请求发送到服务器。 基于 TCP 数据流 接收 HTTP 响应：接收服务器返回的响应数据。 关闭连接：数据传输完成后，根据 HTTP 协议（如 HTTP/1.1 的 Connection: close 或 HTTP/2 的复用机制）关闭或保持连接。 HTTP 缓存 发起网络请求之前，查找缓存（上一次请求网站的 html、css、js、图片等文件资源的副本）。 如果命中缓存，会拦截请求，直接返回缓存数据，并直接结束请求，而不会再去源服务器重新下载。从而节省了网络请求的时间。 这样做的好处有： 1、减少网络带宽消耗 2、降低服务器压力 3、减少网络延迟，提升性能（获取资源的耗时更短了） HTTP 缓存大小 并没有一个固定的上限，会因浏览器类型、设备存储容量、用户设置以及浏览器的自适应策略而有所不同。 一般来情况下： 桌面浏览器 缓存大小可能在 50MB 到 200MB 之间 移动浏览器 缓存大小可能在 20MB 到 50MB 之间。 HTTP 缓存 控制 HTTP 缓存分两类 1. 新鲜度(过期) 浏览器缓存的有效期，缓存必须满足: 含有完整的过期时间控制头信息，并在有效期内 浏览器已经使用过这个副本，并且在会话中已经检查过新鲜度。 2. 校验值(验证) 服务器返回资源的时候，会在响应头信息中带上资源 实体标签 Entity Tag，用来作为浏览器再次请求过程的校验标识 校验标识不匹配，说明资源已经被修改过或过期，浏览器需要重新请求资源。 HTTP 缓存机制分两种 强缓存 浏览器在请求资源时，会检查 响应请求头 的标识 Cache-Control 或者 Expires ，如果资源在缓存有效期内，直接使用本地副本，不再发起 HTTP 请求。 cache-control 相对过期时间（http1.1）: cache-control: max-age=31536000, 优先级 高于Expires Expires 绝对过期时间（http1.0）: Expires: Wed, 21 Oct 2015 07:28:00 GMT, 是一个时间点, 是服务器时间，如果本地时间与服务器时间不一致，缓存将无法命中 cache-control 参数说明： public 公共缓存，客户端和代理服务器都可缓存。 private 私有缓存，只可以客户端缓存，不能在代理服务器处缓存。 no-cache 不缓存响应内容，需要使用协商缓存来验证缓存是否可重用。一般用在index.html no-store 不使用缓存，请求或响应都不可以缓存。 强缓存 &gt; 协商缓存，如果强缓存生效，直接使用缓存，不会发起请求。 协商缓存 浏览器 通过 响应头 的 Last-Modified 和 ETag 发起请求 服务器 通过 请求头 的 If-Modified-Since 和 If-None-Match与 服务器上 ETag 和 Last-Modified进行对比，如果都没过期，返回304（资源未被修改，直接使用缓存），否则返200状态码。 检查响应头的 Last-Modified 和 ETag 唯一标识符字段，这两个字段的值是服务器上资源的最后修改时间和 ETag 值。 If-Modified-Since 与 Last-Modified 对应，表示上一次请求时Last-Modified的值。 If-None-Match 与 ETag 对应，表示上一次请求时ETag的唯一标识符值（通常是资源的哈希值）。 Last-Modified 与 ETag 一起使用 ETag主要是为了解决Last-Modified比较难解决的问题： 1、Last-Modified 标注的时间仅到秒级, 如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的新鲜度。 2、如果 某些文件会被定期生成内容不变，但Last-Modified改变了，导致文件 无法使用缓存。 3、客户端与 服务器 时间不一致等情形。ETag是 服务器自动生成或开发者生成 对应资源在 服务器的 唯一标识符，更加精准控制缓存。 两者可以一起使用，服务器优先验证ETag，一致时，才会继续比对Last-Mofifed，才决定是否要返回304。 304 状态码：表示 客户端请求的资源未被修改，允许客户端继续使用本地缓存，无需下载。 ⚠️ 缓存验证机制：虽然 304 状态码可以 减少数据传输，但仍然 会发送 HTTP 请求，因此需要合理设置缓存策略（如 Cache-Control 和 Expires）。 Last-Modified / ETag 与 Cache-Control / Expires 一起使用时 优先 检测 Cache-Control / Expires 本地缓存是否还在有效期内，在有效期内，直接使用本地缓存，阻止发送请求。 如果过期，就走完整的协商缓存流程，返回304 或者 200。 一般情况下，两者配合使用， 因为即使设置缓存时间, 当用户点击“刷新”按钮时，浏览器会忽略缓存继续向服务器发送请求，这时 Last-Modified/ETag将能够很好利用 304，从而减少响应开销。 不能缓存的请求 不是所有的请求都能被缓存： post 请求 无法被缓存。 需要根据cookie、认证信息等 决定输入内容 的 动态请求 不能被缓存。 http 响应头 中不包含 Last-Modified/ETag，也**不包含Cache-Control/Expiress**的 请求 无法被缓存。 http 信息头 明确设置 Cache-Control:no-cache 或Cache-Control:max-age=0 ,浏览器 不缓存时。 浏览器缓存机制 HTTP | 强缓存与协商缓存 建立 TCP 连接 只有在以下情况下，浏览器才会建立 TCP 连接： 缓存中没有找到资源：即资源既不在内存缓存中，也不在磁盘缓存中。 缓存资源过期且服务器返回 200 OK：表示资源已更新，需要重新下载。 DNS 解析 域名是我们方便记忆的地址，而 IP 地址才是目标在网络中所被分配的节点。网络通讯大部分是基于TCP/IP的，而TCP/IP是基于IP地址的。 MAC 地址是对应目标网卡所在的固定地址。 DNS协议是应用层协议，通常该协议运行在UDP协议之上，使用的是53端口号。 DNS 解析会进行查询，过程分为以下几个步骤： 递归查询 【递归查询一般发送一次请求就够】 询问 浏览器 DNS 缓存 询问 本地操作系统 DNS 缓存（即查找本地 host 文件） 询问 本地 DNS 解析器 DNS 缓存 询问 本地 DNS 服务器 【ISP（Internet Service Provider）互联网服务提供商（例如电信、移动）的 DNS 服务器】 【 本地 DNS 服务器 没有会进入 迭代查询 阶段 】 本地是个相对概念，指离用户最近的 DNS 服务器， 如 114、8.8.8.8 运营商搭建，提供更快的域名解析服务 迭代查询【迭代过程需要 ISP DNS 服务器 发送多次请求】 从 本地 DNS 服务器 发起请求查询 询问 根服务器、顶级域名服务器、权威域名服务器 根域名：www.hy.com. 中最后一个单个句点（.）或句点用于末尾的名称 [ 默认省略, 由ICANN 规定顶级域名 ] 顶级域名 TLD：.com 二层域名：hy.com 子域：www.hy.com 主机名：h1.www.hy.com 以用户输入的三级域名网址为例，本地DNS 查询 解析过程 如下： 根域名服务器 没有 主机域名记录，返回 根域名服务器的 IP 地址 本地域名服务器向 cn 域名服务器查询，也没有相关记录，返回 二级域名服务器的 IP 地址 本地域名服务器再 二级域名服务器查询，也没有相关记录，但是知道 三级域名服务器可以解析这个域名，返回 三级域名服务器的 IP 地址 本地域名服务器向 三级域名服务器查询，发现有主机域名记录，返回对应的 IP 地址 最后 本地域名服务器将 对应的 IP 地址返回给客户端，整个解析过程完成 为什么DNS可以实现负载均衡？ DNS可以在 冗余的服务器上实现负载均衡，一般的大型网站 使用多台服务器提供服务，因此一个域名 可能会对应 多个服务器地址。这样可以 将用户的请求 均衡的分配 到各个不同的服务器上，这样来实现负载均衡。 建立 TCP 连接 得到 IP 后， 首先，建立 TCP 连接，即三次握手过程： 客户端发送标有 SYN = 1，seq = x 的数据包，表示 将要发送请求(x 为随机数)。 服务器发送标有 SYN = 1，ACK=1, ack = x + 1，seq = y 的数据包，表示 已经收到通知，告知客户端发送请求(y 为随机数)。 客户端发送标有 ACK = 1, ack = y + 1，seq = x + 1 的数据包，表示 确认收到服务器的响应。 SYN 表示 发送请求，ACK 表示 确认收到，seq 表示 序列号，ack 表示 确认号。 seq序列号初始值是随机的，避免重放攻击。 三次握手的设计原因 为了防止已过期的连接请求报文突然又传送到服务器，因而产生错误。 - 例如:客户端发送的第一个连接请求报文段因网络延迟被延迟到达服务器，那么进行三次握手可以防止服务器错误地打开一个已经失效的连接。 三次握手才能让双方均确认自己和对方的发送和接收能力都正常 - 第一次握手：客户端只是发送处请求报文段，什么都无法确认，而服务器可以确认自己的接收能力和客户端的发送能力正常； - 第二次握手：服务器发送确认报文段，客户端可以确认自己和对方的发送、接收能力正常； - 第三次握手：客户端发送确认报文段，服务器可以确认自己的发送能力正常。 告知对方自己的初始序号值，并确认收到对方的初始序号值。 - 依靠 TCP 报文段中维护了 序号字段seq 和 确认序号字段 ack 使得双方都能得到数据确认， 这也是 TCP 能够实现可靠的数据传输 的原因之一。 方便记忆场景： 客户端： SYN：我给你的序号是5 服务端： ACK：我收到了你的序号是5; SYN：我也给你一个序号，是10 客户端： ACK：你的序号是10。现在，我要开始发内容了。 详解 TCP 三次握手、四次挥手，附带精美图解和超高频面试题 TLS 握手 在 TCP 连接建立成功后，浏览器和服务器通过 TLS 握手协商加密参数并验证身份 TLS 握手完成后，所有应用层数据（如 HTTP 请求和响应）都会通过加密通道传输 TLS 握手的主要目的是： 握手的目的是确保通信的安全性，防止中间人攻击 验证服务器（和可选的客户端）身份。 协商加密算法。 生成共享的会话密钥。 确保通信的安全性。 TLS 握手的过程 tls.png 以 TLS 1.2 为例: 浏览器发送 Client Hello 消息。 客户端（浏览器）向服务器发送一个 Client Hello 消息，内容包括： 客户端支持的 TLS 版本。 客户端生成的随机数（Client Random）。 支持的加密算法套件（Cipher Suites）。 支持的压缩算法（可选）。 扩展信息（如支持的椭圆曲线、签名算法等）。 服务器发送 Server Hello 消息。 服务器收到 Client Hello 后，选择一个加密算法套件，并生成自己的随机数（Server Random），然后发送 Server Hello 消息，内容包括： 选定的 TLS 版本。 服务器随机数。 选定的加密算法套件。 会话 ID（可选）。 证书交换 服务器发送自己的证书（或证书链），客户端通过证书颁发机构（CA）验证服务器的身份。 如果服务器需要客户端证书，还会发送 Certificate Request。 密钥协商 客户端生成一个预主密钥（Pre-Master Secret），并使用服务器证书中的公钥加密后发送给服务器。 客户端和服务器分别使用客户端随机数、服务器随机数和预主密钥，通过相同的算法生成主密钥（Master Secret）。 双方使用主密钥生成用于加密通信的会话密钥。 Change Cipher Spec 和 Finished 客户端和服务器分别发送 Change Cipher Spec 消息，通知对方 后续通信将 使用协商好的加密算法和密钥。 双方发送 Finished 消息，验证握手过程的完整性和正确性。 如果验证成功，握手完成，开始加密通信。 TLS 1.3 的改进 TLS 1.3 对握手过程进行了优化，主要改进包括： 减少了握手时间和往返次数，提高了性能和安全性 减少握手往返次数：TLS 1.3 将握手过程减少到 1-RTT（一次往返），甚至在某些情况下可以实现 0-RTT（零往返）。 更安全的密钥交换算法：TLS 1.3 引入了更安全的密钥交换算法（如 ECDHE），并废弃了不安全的算法（如 RSA 密钥交换）。 部分握手信息加密：TLS 1.3 对握手过程中的部分信息进行了加密，增强了安全性。 https 与 http 核心区别： HTTP 基于 TCP 协议，信息是明文传输； HTTPS 在 TCP 之上引入了 TLS/SSL 协议, 信息是加密传输。 HTTP 请求报文 基于 TCP 文件流 发送的资源： 请求行 请求头 请求体（只有post请求有，get请求没有） HTTP 响应报文 响应行：版本协议、状态码 响应头 响应体 断开连接 四次挥手详细过程如下： 客户端发送 关闭连接 FIN =1， seq = x 报文段，并停止发送数据。(x等于 之前发送的所有数据的 最后一个字节的序号加一) 客户端状态 变更为 FIN-WAIT-1状态，等待来自 服务器的确认报文。 服务器 收到 FIN 报文后，发回 确认报文:ACK = 1， ack = x + 1, seq = y，并带上自己的序号y 服务器 变更为 CLOSE-WAIT状态(服务器还可以发送数据)。服务器还会 通知上层的应用程序 对方已经释放连接，没有数据要发送了;TCP 处于半关闭状态 客户端 在收到服务器的 ACK 报文段后, 随即进入 FIN-WAIT-2 状态（还能收到来自服务器的数据） 服务器发 送完所有数据后，会向客户端发送 FIN =1 ACK =1 ack=x+1 seq=z 报文段， 服务器 变更为 LAST-ACK 状态，等待来自客户端的确认报文段。 客户端收到 服务器的 FIN 报文段后，发送 ACK = 1， ack = z + 1, seq = x + 1， 服务器收到 客户端的 ACK 报文 后 变更为 CLOSED 状态，因为 没有等待时间，服务器比客户端更早进入 CLOSED 状态。 客户端 变更 TIME-WAIT 状态，等待 2MSL(两倍的报文段最大存活时间，常用值有30秒、1分钟和2分钟)。 最后，无特殊情况，客户端 进入 CLOSED 状态。 为什么 TCP 关闭连接 为什么 四次而不是三次？ 服务器 收到客户端的 FIN 报文段后，可能还有数据要传输，不能马上关闭连接, 但是会做出应答，返回 ACK 报文段，在数据发送完后，服务器会向客户 单发送 FIN 报文，表示 数据发送完毕，请求关闭连接; 然后客户端再做出应答，因此一共需要四次挥手。 根本原因 ：TCP 连接是 全双工 (即数据在两个方向上能同时传递，同时双向传输数据)， 因此每个方向必须单独地进行关闭 客户端为什么需要在 TIME-WAIT 状态 等待 2MSL 时间才能进入 CLOSED 状态？ 网络并不总是可靠的，如果 客户端发送的 ACK 报文段丢失，服务器在接收不到 ACK 的情况下,会一直重发 FIN 报文段. 为此 客户端为了确保服务器收到了 ACK，会设置一个定时器，并在 TIME-WAIT 状态等待 2MSL 的时间， 收到 服务器的 FIN 报文段，此时 客户端会 重置计时器并再次等待 2MSL 的时间， 没收到 FIN 报文，说明成功收到了 ACK 报文，客户端就可以进入 CLOSED 状态了。","categories":[{"name":"基础","slug":"基础","permalink":"http://mcdowell8023.github.io/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://mcdowell8023.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"http","slug":"http","permalink":"http://mcdowell8023.github.io/tags/http/"}]},{"title":"常见流媒体协议介绍","slug":"rtc/流媒体协议介绍","date":"2022-06-15T10:24:30.000Z","updated":"2025-03-09T07:55:41.196Z","comments":true,"path":"2022/06/15/rtc/流媒体协议介绍/","permalink":"http://mcdowell8023.github.io/2022/06/15/rtc/%E6%B5%81%E5%AA%92%E4%BD%93%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"本文 主要整理自 https://zhuanlan.zhihu.com/p/496823042 前置 整理下常见 流媒体协议 RTP、RTSP、RTMP、HLS、FLV、SRT、WebRTC 一图胜千言，但是注意，图中 的 MP4/FLV指的是 http-flv 和 http-mp4。 这里说的还是流媒体协议，不是封装格式。 从上面我们知道： 基于 UDP 的 流媒体协议 有 RTP、RTCP 基于 TCP 的 流媒体协议 有 RTSP、RTMP、HTTP、HLS、http-flv、http-mp4 HLS、http-flv、http-mp4 本身就是基于 http协议的。 后面会说到 从网络协议说起 但是说流媒体协议就绕不开网络协议。我们要建立网络分层模型的概念，所有流媒体协议都有归属的层级，这个是理解、区分协议的基础。 流媒体协议需要根据目标场景，选择TCP/UDP，再进行应用层协议开发，这里就出现第一个概念，如何选择TCP/UDP？ TCP和UDP特点 TCP 传输的特点：面向连接，保序，可靠 TCP的协议栈完成了拥塞控制，流量控制，乱序重排，丢包重传等工作。 保证数据是有序可靠的。 适合强调数据完整性 的场景：如:文件下载，网页浏览，信令传输。 UDP 传输特点：面向无连接，不保序，不可靠连接 UDP协议 面向无连接，只是简单向对方发送数据，哪怕对方不存在。 协议简单，所以传输效率高，实时高、延迟低。 适合强调实时性高的场景。如: 音视频传输，游戏等。 关于组播与广播，单播 TCP 面向连接，一定是点对点的，一定是两个主机来建立连接的，TCP肯定是单播。 只有UDP才会使用广播和组播 一个主机要向网上的所有其它主机发送帧，这就是广播， 多播（组播）属于单播和广播之间，帧仅传送给属于多播组的多个主机。 在广播电视领域为了减少服务器压力，通常使用组播跟用户推流。如: IPTV，通常机顶盒通过光猫加入某个组播地址，接收 某个CDN的组播流。 从流媒体角度看 TCP自身的拥塞控制机制、传输数据延时大，队头阻塞等问题，音视频的 实时传输 造成一定的困扰。 UDP自身设计原因，公网传输丢包、乱序等极端情况，会导致客户端无法解码。 所以对于流媒体传输，需要对运输层TCP/UDP协议进行高层次的开发，以适应流媒体传输时的应用需求。 常见流媒体协议 RTP 实时传输协议 与 RTCP RTP (Real-time Transport Protocol) 和RTCP(Real-time Transport Control Protocol) 都是 传输层协议 RTCP是RTP的控制部分,通常一起配合使用 应用程序启动一个RTP会话时，将占用两个端口，分别供RTP和RTCP使用 RTP 使用 偶数端口号 收发数据,负责数据传输 通常创建在UDP上，但也能够在TCP或ATM等其余协议之上工作 基于UDP时，和UDP一样，并不提供任何传输可靠性的保证和流量的拥塞控制机制，无法保证实时性 RTP 在 UDP 基础上增加了 Header 头，包含 CSRC标识、时间戳、序列号等信息（用于配合完成 按序传输数据包提供可靠的保证）。 RTCP 使用 相邻的下一位奇数端口号,负责管理传输质量。 负责 收集相关连接信息，实时监控数据传输和服务质量(控制辅助) RTCP来负责 完成 RTP 按序传输数据包提供可靠的保证，流量控制和拥塞控制 在RTP会话期间，各参与者周期性地传送RTCP包，包中含有已发送包的数量、丢失包的数量等统计信息。服务器利用这些信息动态地改变传输速率，甚至改变有效载荷类型。 RTSP 实时流协议 比RTP多了一个S的RTSP是RealTime Streaming Potocol 实时流协议。 基于RTP和RTCP之上的应用层协议。可选择UDP、组播UDP、TCP、RTP为传输机制。 双向实时数据传输协议，它允许客户端向服务器端发送请求, 进行 回放、快进、倒退等操作 充当多媒体服务器的网络远程控制，使实时数据的远程控制成为可能。 比如，音频与视频的快进快退、中止、播放。 一般用作摄像头、监控等硬件设备的实时视频流观看与推送上 泛用性不足，现在的 浏览器都不支持RTSP的播放 RSVP (Resource Reserve Protocol)资源预订协议 主要作用: 预留带宽,提升QoS(服务质量) 音频和视频数据流比传统数据对网络的延时更敏感，要在网络中传输高质量的音频、视频信息，除带宽要求以外，还需其余更多的条件。 使用RSVP预留一部分网络资源，能在一定程度上为流媒体的传输提供QoS保障。 RTP\\RTCP\\RTSP小结 RTP提供时间标志，序列号以及其余可以保证在实时数据传输时处理时间的方法。 RTCP是RTP的控制部分，用来保证服务质量和成员管理。 RTSP具体数据传输交给RTP,提供对流的远程控制。 RSVP预留带宽,提升QoS。 RTMP（Real Time Messaging Protocol）实时消息传输协议 Adobe公司为Flash播放器和服务器之间开发的音视频数据传输的开放协议 传输flv或f4v封装格式 的 媒体流。 基于TCP协议，使用端口1935，能够保持长连接*，并提供低延时**(1-3秒)通信。【通常占用一个通道传输数据和指令，就能保证传输质量】 RTMP是目前低延时直播应用最普遍的协议，几乎全部编码器标准输出协议（H.265 不支持） 全部CDN支持的最好的直播分发协议 实际直播场景中： 由于浏览器摒弃了Flash播放器，所以一般只用作直播源推流、推流到直播CDN等场景。 缺点 协议太老: HEVC/H.265/AV1等视频格式都没有官方定义 连接过程较长，需要 TCP三次握手 和 本身的C0/S0到C2/S2的三次握手，再加上 建立连接 &gt; 建立流 &gt; 播放, 完成一次建连9次会话 无法提供带宽自适应的算法: 拥塞控制完全依赖传输层TCP的拥塞控制算法来进行拥塞管理 因为RTMP是基于TCP之上的，所以也存在三次握手的要求， 另外RTMP还增加了C0/S0到C2/S2的三次握手。 播放RTMP协议的流媒体需要经过：握手 &gt; 建立连接 &gt; 建立流 &gt; 播放 [connection，createstream，play/publish]。 RTMP包括: RTMP基本协议及RTMPT/RTMPS/RTMPE等多种变种 RTMPT： 封装在HTTP请求之上，可穿透防火墙； RTMPS： 在RTMPT基础上 增加了TLS/SSL的安全功能； RTMPE： 在RTMP的基础上 增加了加密功能。 落地 需要流媒体服务软件 RTMP协议需要特定的流媒体服务软件，如SRS、加入了RTMP插件的Nginx等。此类流媒体服务软件实际上就是音视频数据的中转站，数据一般只在内存中循环覆盖，不会写入磁盘。 强制切片机制 RTMP，在封装音视频数据时会强制切片，限制每个数据包的大小。 强制切片也一定程度保证了实时性。 有一定的弱网抵抗能力，因为数据包都不大，当失败时，重新成本小，但也 由于合并数据包会加大CPU压力，所以是有一定的性能消耗的。 HTTP-FLV 可以简单地理解为HTTP协议版本的RTMP HTTP-FLV 与 RTMP基本一样，都是建立在FLV封装之上的。 功能和工作原理上是相似,也有 类似 RTMP切片数据功能 注意: HTTP-FLV 虽然是基于HTTP协议的，但是 是长链接 不同点 RTMP一般用作直播源推流 HTTP-FLV一般用作直播拉流观看(相对略高于RTMP)； 优点在于: 在浏览器中 借助 flvjs 可以在浏览器中实现播放。 落地 HTTP-FLV协议 同样需要特定的流媒体服务软件，如加入了HTTP-FLV插件的Nginx等。 Nginx的HTTP-FLV插件是包含 RTMP功能的，所以一般HTTP-FLV的流媒体服务，推流是以RTMP协议，拉流是用HTTP-FLV协议。 HLS（HTTP Live Streaming） 由Apple公司提出的基于短连接HTTP的媒体流传输协议 严格意义上讲，HLS协议并不是流式协议: 本质是 通过HTTP协议下载静态文件 网络兼容好： 基于HTTP协议，能方便穿透防火墙或代理服务器，CDN支持良好 平台播放兼容好： ios 安卓都支持，PC web safari 都支持, 其他浏览器 可以使用 hls.js 播放 HLS协议实现播放的过程 HLS协议 包含.m3u8索引文件 和 多个很短的.ts媒体文件。 客户端获取到索引文件后，通过http请求获取到.ts文件，下载到本地磁盘，再根据索引顺序播放。 一个 m3u8文件的内容如下 m3u8示例 12345678910111213#EXTM3U # 每个M3U8文件第一行必须是这个tag。#EXT-X-VERSION:3 # 表示 HLS 的协议版本号，该标签与流媒体的兼容性相关#EXT-X-MEDIA-SEQUENCE:0 # 表示播放列表第一个 URL 片段文件的序列号。#EXT-X-ALLOW-CACHE:YES#EXT-X-TARGETDURATION:6 # 表示每个视频分段最大的时长（单位秒）#EXTINF:3.000 #表示其后 URL 指定的媒体片段时长（单位为秒）alilive-E_2_3-1507867721-471441600-1920x1080-1165-3000.ts # 表示媒体片段的 URL#EXTINF:3.000alilive-E_2_3-1507867721-471711600-1920x1080-1165-3000.ts#EXTINF:3.000alilive-E_2_3-1507867721-471981600-1920x1080-1165-3000.ts#EXTINF:3.000alilive-E_2_3-1507867721-472251600-1920x1080-1165-3000.ts 此外 HLS协议的.m3u8索引文件支持二级索引，就是高清、标清、流畅等多个观看地址可以整合到一个索引文件 m3u8 文件格式详解 与HLS协议类似的还有MPEG-DASH协议工作原理都是差不多的，只是局部标准不一样 缺点 延时较高：因为使用HTTP短连接，不断的与server建立连接，TCP的三次握手，四次挥手，交互耗时长。难以用到时延要求更严格的直播场景。 海量碎片：HLS切片一般较小，海量碎片在文件分发、一致性缓存都有较大挑战。 落地-点播 不需要特殊的流媒体服务软件，使用Nginx等HTTP服务就可以了 .m3u8索引文件会记录所有的碎片视频文件地址，HLS在点播的场景下，优势是更加明显的。 由于HLS的相关文件是无状态的静态文件，且每个文件的大小是有限的，所以负载均衡、CDN加速的效果更佳明显。 HLS协议的点播视频，会比.mp4、.flv的视频更快地播放出来，且在加载中跳转视频也会更加顺滑。 落地-直播 转码软件可以直接生成HLS相关文件到磁盘，客户端 通过HTTP服务下载文件即可。 在Nginx加入RTMP插件，转码软件以RTMP协议推流到Nginx，再由Nginx生成HLS相关文件。推荐：前期研发 和 后期对接直播CDN的过度更加顺滑。 http-mp4 是一种 HTTP 伪流媒体,其实不算是流媒体协议，而是基于HTTP协议的点播协议。 本质是需要 特殊的MP4-fMP4 格式的文件，通过HTTP协议下载到进行播放，只是客户端可以边下边播。 这点 通常用于 网站的 视频播放的优化。 实现的条件 必须将 moov 放在 mdat 前面。可以通过 ffmpeg 指定参数 -movflags faststart 进行移动。 HTTP 请求返回的 Content-Type 必须是 video/mp4 。 服务器必须支持 HTTP 1.1 的 Range 。 确保服务器没有对 MP4 文件进行 gzip 压缩，不然怎么读取 moov 啊。 使用HTTP流播放MP4 Nginx 中实现 MP4 视频的边下边播 特殊的MP4-fMP4 MP4 的基本组成单位是 box box类型有很多 ftyp：File Type Box，描述文件遵从的MP4规范与版本； moov：Movie Box，媒体的metadata信息（包含的 trak 记录着视频播放数据的时间和空间信息），有且仅有一个。 mdat：Media Data Box，存放实际的媒体数据(保存着视频音频信息)，一般有多个； 播放MP4的过程： 播放器在播放MP4 的时候，需要先读取metadata，然后再读取媒体数据。才可以播放 视频的拖动，快进，都是需要根据 moov metadata 和拖动至的时间。 但是 MP4文件，不一定 moov 就在文件开头，也有可能在文件末尾。 本地MP4文件，可以快速读取整个文件，找到metadata后，开始播放， 但是 网络上的MP4文件 如果开头找不到 moov metadata ，就只能等下载完毕，才能播放。 要实现 网络上的MP4文件边下边播，就需要将moov metadata 放在文件开头。 使用HTTP流播放MP4 WebRTC（Web Real-Time Communication） WebRTC是网页 实时通信 一个支持网页浏览器 进行实时语音对话或视频对话的技术而无需任何插件。 兼容性好： WebRTC已经不仅仅局限于PC的网页浏览器，Android、iOS平台上很多应用都已经采用了这样技术。 使用是RTP分装码流，建立通信后，会不断以流式发送数据，所以延迟会比RTMP还要低。可以达到1秒内 WebRTC协议 支持 推流 和 拉流，地址一般是以 webrtc://开头的，且 推流和拉流地址一般也是一样的。 应用在直播场景的话，是需要搭建 WebRTC服务器作为 流媒体服务的，流媒体服务软件可以使用SRS。 SRS是国内研发的一个比较流行的开源流媒体服务软件: https://ossrs.io https://ossrs.net https://github.com/ossrs/srs WebRTC跟视频监控，IPTV，会议电视一样都是RTP承载媒体流， WebRTC的码流采用SRTP进行加密，WebRTC优先使用VP9、VP8、H.264，不支持H.265。 WebRTC信令遵守ICE框架，使用 自定义信令 IPTV领域 使用RTSP信令 视频监控走GB28181或者onvif信令， 会议电视走h323或SIP协议。 SRT UDT协议 基于UDP的传输协议，具有非常良好的丢包重传机制，丢包重传的控制消息非常丰富，同时支持ACK、ACKACK、NACK。 引入新的拥塞控制和数据可靠性控制机制 是面向连接的双向的应用层协议 SRT是基于UDT的协议,针对音视频实时性提出的协议。 SRT拥有三大特点，安全，可靠，低延迟。 安全方面，SRT支持AES加密，保障端到端的视频传输安全。 可靠性方面，SRT通过前向纠正技术(FEC)保证传输的稳定性。 低延迟方面，由于SRT建立在UDT协议之上，解决了UDT协议传输延迟高和复杂的传输时序问题，可以做到支持高吞吐量文件和超清视频的实时传输。 SRT协议具有抗丢包、抗拥塞、抗抖动等特性 SRT基于时间的报文发送，使其具有良好的防止流量突发的能力。 音视频流经过网络传输，帧间隔和码率特性会被完全改变，解码这样的信号容易出现故障。 而SRT增加了纠错协议，在封装中包含精准的时间戳，解码接收端可以通过该时间戳重现固定的帧间隔。 还能通过规定延时量，同时划定send buffer（发送端缓冲区）与receive buffer（接收端缓冲区），来自接收端的反馈信号（可以理解为后向纠错）通过一系列的设置、纠错、流量控制，使编码后的视音频码流拥有与原码流几乎一样的码率特性。 推荐阅读： 流媒体传输协议浅析 HLS、FLV、RTMP三种协议快速对比 直播协议详解 RTMP、HLS、HTTP-FLV、WebRTC、RTSP 直播原理解析","categories":[{"name":"技术帖","slug":"技术帖","permalink":"http://mcdowell8023.github.io/categories/%E6%8A%80%E6%9C%AF%E5%B8%96/"}],"tags":[{"name":"追本溯源","slug":"追本溯源","permalink":"http://mcdowell8023.github.io/tags/%E8%BF%BD%E6%9C%AC%E6%BA%AF%E6%BA%90/"},{"name":"直播","slug":"直播","permalink":"http://mcdowell8023.github.io/tags/%E7%9B%B4%E6%92%AD/"},{"name":"音视频","slug":"音视频","permalink":"http://mcdowell8023.github.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"}]},{"title":"SVN - 常用命令","slug":"工具/svn","date":"2022-05-28T10:27:25.000Z","updated":"2025-03-07T18:34:52.411Z","comments":true,"path":"2022/05/28/工具/svn/","permalink":"http://mcdowell8023.github.io/2022/05/28/%E5%B7%A5%E5%85%B7/svn/","excerpt":"","text":"svn 常用命令 上传项目到SVN服务器上 1svn import project_dir（本地项目全路径） http://192.168.1.242:8080/svn/IOS/Ben/remote_dir（svn项目全路径） -m &quot;必填, 不填此命令执行不会成功.&quot; 注: 服务器上remote_dir若不存在, 会自动创建; 只会上传project_dir目录下的文件到remote_dir的目录下 import之后, project_dir并没有自动转化为工作目录, 需要重新checkout(后面会用到) 下载checkout svn项目到本地 svn checkout http://192.168.1.242:8080/svn/IOS/remote_dir (svn项目全路径）project_dir（本地目录全路径) --username 用户名 --password 密码 svn checkout 简写：svn co 添加新文件 svn add file（文件名） svn add *.php(添加当前目录下所有的php文件) 提交到版本库 svn commit -m “LogMessage” [-N] [–no-unlock] PATH(如果选择了保持锁，就使用–no-unlock开关) svn commit -m “提交当前目录下的全部在版本控制下的文件“ * （ *表示全部文件 ） 例如：svn commit -m “add test file for my test” test.php svn commit -m “提交我的测试用test.php“ -N --no-unlock test.php （ 保持锁就用–no-unlock开关 ） 注意：必须带上-m参数，参数可以为空（“”） svn commit 简写：svn ci 更新文件 svn update svn update -r 修正版本 文件名 svn update 文件名 例如： svn update （后面没有目录，默认将当前目录以及子目录下的所有文件都更新到最新版本） svn update -r 200 test.cpp （ 将版本库中的文件 test.cpp 还原到修正版本（revision）200） svn update test.php （ 更新与版本库同步 ） 提交的时候提示过期冲突，需要先 update 修改文件， 然后清除svn resolved，最后再提交commit。 svn update 间写： svn up 查看文件或者目录状态 1）svn status path（目录下的文件和子目录的状态，正常状态不显示） 【?：不在svn的控制中；M：内容被修改；C：发生冲突；A：预定加入到版本库；K：被锁定】 2）svn status -v path(显示文件和子目录状态) 第一列保持相同，第二列显示工作版本号，第三和第四列显示最后一次修改的版本号和修改人。 注：svn status、svn diff、svn revert这三条命令在没有网络的情况下也可以执行的，原因是svn在本地的.svn中保留了本地版本的原始拷贝。 svn status 简写：svn st 删除文件 svn delete path -m “delete test fle” 例如：svn delete svn://192.168.1.1/pro/domain/test.php -m “delete test file” 推荐使用： svn delete test.php svn ci -m 'delete test file‘ svn delete 简写：svn del／remove／rm 查看日志（显示文件的所有修改记录，及其版本号的变化） svn log path svn log -l 3查看最新的三条记录 例如：svn log test.php 查看文件详细信息 svn info path 例如：svn info test.php 比较差异 svn diff path(将修改的文件与基础版本比较) 例如：svn diff test.php svn diff -r m:n path(对版本m和版本n比较差异) 例如：svn diff -r 200:201 test.php svn diff 简写：svn di 合并文件（将两个版本之间的差异合并到当前文件） svn merge -r m:n path 例如： svn merge -r 200:205 test.php（将版本200与205之间的差异合并到当前文件，但是一般都会产生冲突，需要处理一下） SVN 帮助 svn help 全部功能选项 svn help ci 具体功能的说明 版本库下的文件和目录列表 svn list path 显示path目录下的所有属于版本库的文件和目录 svn list 简写：svn ls 创建纳入版本控制下的新目录 svn mkdir newdir 例如： svn mkdir -m “Making a new dir.” svn://localhost/test/newdir 用法: 1、mkdir PATH… 2、mkdir URL… 创建版本控制的目录。 1、每一个以工作副本 PATH 指定的目录，都会创建在本地端，并且加入新增 调度，以待下一次的提交。 2、每个以URL指定的目录，都会透过立即提交于仓库中创建。 （在这两个情况下，所有的中间目录都必须事先存在） 注：添加完子目录后，一定要回到根目录更新svn update一下，不然在该目录下提交文件会提示“提交失败” 注：如果手动在checkout出来的目录里创建了一个新文件夹newsubdir， 再用svn mkdir newsubdir命令后，SVN会提示： svn: 尝试用 “svn add”或 “svn add --non-recursive”代替？ svn: 无法创建目录“hello”: 文件已经存在 此时，用如下命令解决： svn add --non-recursive newsubdir 在进入这个newsubdir文件夹，用ls -a查看它下面的全部目录与文件，会发现多了：.svn目录 再用 svn mkdir -m “添hello功能模块文件” svn://localhost/test/newdir/newsubdir 命令， SVN提示： svn: File already exists: filesystem ‘/data/svnroot/test/db’, transaction ‘4541-1’, path '/newdir/newsubdir ’ 恢复本地修改 svn revert: 恢复原始未改变的工作副本文件 (恢复大部份的本地修改)。 用法: revert PATH… 注意: 本子命令不会存取网络，并且会解除冲突的状况。但是它不会恢复 被删除的目录 svn revert foo.c ＜－ 丢弃对一个文件的修改 svn revert --recursive . ＜－恢复一整个目录的文件，. 为当前目录 代码库URL变更 svn switch (sw): 更新工作副本至不同的URL。 用法: 1、switch URL [PATH] 2、switch --relocate FROM TO [PATH…] 1、更新你的工作副本，映射到一个新的URL，其行为跟“svn update”很像，也会将 服务器上文件与本地文件合并。这是将工作副本对应到同一仓库中某个分支或者标记的 方法。 2、改写工作副本的URL元数据，以反映单纯的URL上的改变。当仓库的根URL变动 (比如方案名或是主机名称变动)，但是工作副本仍旧对映到同一仓库的同一目录时使用 这个命令更新工作副本与仓库的对应关系。 svn switch 间写： svn sw 解决冲突 svn resolved: 移除工作副本的目录或文件的“冲突”状态。 用法: resolved PATH… 注意: 本子命令不会依语法来解决冲突或是移除冲突标记； 它只是移除冲突的相关文件，然后让 PATH 可以再次提交。 输出指定文件或URL的内容 svn cat 目标[@版本]…如果指定了版本，将从指定的版本开始查找。 svn cat -r PREV filename &gt; filename (PREV 是上一版本,也可以写具体版本号,这样输出结果是可以提交的) 查看svn版本 svn —-version 新建分支branchs，在分支上继续开发 1、svn mkdir branches 2、svn copy svn://server/trunk svn://server/branches/ep -m “init ep” 该版本完成，打tag，发布版本 1、svn mkdir tags 2、svn copy svn://server/trunk svn://server/tags/release-1.0 -m “1.0 released” 使用发生的一些问题： 错误： svn: Could not use external editor to fetch log message; consider setting the $SVN_EDITOR environment variable or using the --message (-m) or --file (-F) options svn: None of the environment variables SVN_EDITOR, VISUAL or EDITOR is set, and no ‘editor-cmd’ run-time configuration option was found 问题原因是： 没有设置svn编辑器的环境变量，主要是import、commit中填写comment要用 解决方法： 在 终端中 sudo vim /etc/bashrc 打开文件 加入：export SVN_EDITOR=vim 编辑完以后一般需要让配置文件立即生效，可执行命令： source /etc/bashrc（也可以不进行这一步） 问题： 不小心提交了一些动态改变根本不需要的文件到svn服务器上 解决方法： svn resolved filename 放弃对文件的修改， svn ci -m “update” 提交所有文件 svn rm test.log 删除掉这个文件。 svn ci -m “update” 再次提交 发生冲突： 两人同时修改同一文件同一部分，先后提交，出现冲突 svn ci -m “update” svn: Commit failed (details follow): svn: Aborting commit: ‘test.log’ remains in conflict 解决方法： A. 放弃自己的更新，使用svn revert（回滚），然后提交。在这种方式下不需要使用svn resolved（解决） B. 放弃自己的更新，使用别人的更新。使用最新获取的版本覆盖目标文件，执行resolved filename并提交(选择文件—右键—解决)。 C. 手动解决：冲突发生时，通过和其他用户沟通之后，手动更新目标文件。然后执行resolved filename来解除冲突，最后提交。 坚持使用自己的更新，找到.mine的文件名，恢复为原文件名，然后执行： svn resolved file_name http://www.cnblogs.com/czq1989/p/4913692.html Mac搭建本地svn服务器，并用Cornerstone连接服务器 http://blog.sina.com.cn/s/blog_963453200101eiuq.html svn基本操作 http://blog.sina.com.cn/s/blog_74e9d98d01017pmn.html http://www.cnblogs.com/webrun/p/5460641.html http://blog.csdn.net/windone0109/article/details/4857044 SVN版本冲突解决详解","categories":[{"name":"工具","slug":"工具","permalink":"http://mcdowell8023.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"脚本","slug":"脚本","permalink":"http://mcdowell8023.github.io/tags/%E8%84%9A%E6%9C%AC/"},{"name":"svn","slug":"svn","permalink":"http://mcdowell8023.github.io/tags/svn/"}]},{"title":"docker笔记-容器化部署","slug":"工具/docker笔记-容器化部署","date":"2021-10-28T02:24:19.000Z","updated":"2025-03-08T01:57:56.357Z","comments":true,"path":"2021/10/28/工具/docker笔记-容器化部署/","permalink":"http://mcdowell8023.github.io/2021/10/28/%E5%B7%A5%E5%85%B7/docker%E7%AC%94%E8%AE%B0-%E5%AE%B9%E5%99%A8%E5%8C%96%E9%83%A8%E7%BD%B2/","excerpt":"","text":"Docker容器化部署 一、什么是Docker 1. 容器 操作系统层面的虚拟化技术，比虚拟机技术更为轻便、快捷。 隔离宿主，隔离其他隔离进程。 2. 为啥用 更高效地利用系统资源。 更快速的启动时间（无需启动操作系统）。 一致的运行环境。 持续交付和部署（Dockerfile到处运行）。 更轻松的迁移。 二、Docker容器启动 1. 基本概念 1. 仓库 存放Docker镜像。 2. 镜像 生成Docker容器的依据特殊文件系统。 3. 容器 依据镜像生成的运行实体。 操作教程 2. 镜像 login pull push search images rmi tag build history save load import 3. 容器 1. 本地容器操作 ps inspect top attach events logs wait export port 2. 容器运行 run start/stop/restart kill rm pause/unpause create exec 4. Dockerfile 三、多容器集群管理 1. Docker-Compose Docker-Compose允许用户通过一个单独的docker-compose.yml模板文件（YAML格式）来定义一组相关联的应用容器为一个项目（project），负责实现对Docker容器集群的快速编排。 1. yml文件 volumes healthcheck 1、volumes 2、healthcheck 2. 命令 docker-compose up docker-compose build 2. Docker Swarm Docker容器的集群管理和编排工具。 3. Kubernetes Docker容器的集群管理和编排工具。Google团队发起的开源项目。 pod, service, rc pod configmap service 常用命令 kubectl get describe create update delete 4. 对比 Docker-Compose 在单服务器或主机上创建和编排多容器。 Swarm 在多服务器或主机上创建和编排容器集群。 Kubernetes 在多服务器或主机上创建和编排容器集群。 四、项目现状 成本 费用调研 Node Node服务 Nginx Nginx服务 五、最终方案 多容器互联 Node容器和Nginx容器互联。 遇到问题 CPU，Memory 探针 Node优雅退出 首页静态化挂载卷 六、去掉Nginx CDN按需回源 CDN回源策略 单Node容器","categories":[{"name":"工具","slug":"工具","permalink":"http://mcdowell8023.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://mcdowell8023.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Docker","slug":"Docker","permalink":"http://mcdowell8023.github.io/tags/Docker/"}]},{"title":"webrtc-连接建立","slug":"rtc/webrtc/note9","date":"2021-08-06T05:00:50.000Z","updated":"2025-03-08T10:02:27.030Z","comments":true,"path":"2021/08/06/rtc/webrtc/note9/","permalink":"http://mcdowell8023.github.io/2021/08/06/rtc/webrtc/note9/","excerpt":"","text":"连接建立 WebRTC 之间建立连接的过程是非常复杂的。之所以复杂，主要的原因在于它既要考虑==传输的高效性==，又要保证端与端之间的==连通率==。 当同时存在多个有效连接时，它首先选择传输质量最好的线路，如能用内网连通就不用公网。另外，如果尝试了很多线路都连通不了，那么它还会使用服务端中继的方式让双方连通，总之，是“想尽办法，用尽手段”让双方连通 连接建立的基本原则 在上节中提到，在进行媒体协商后 （offer、Answer 等一系列 操作后），WebRTC 底层会收集，Candidate，并进行连通性检测后建立通道。 也就是本节要说的过程 【收集 Candidate、连通性检测后建立通道】 Candidate 在了解 WebRTC 建立连接的过程之前，必须了解基本概念：ICE Candidate （ICE 候选者）。 打洞技术依靠 要建立的每个对等端来收集 一组可通过 internet 访问他们的潜在访问方式。这些 ip 端口组 称为 ‘地址候选项’，简称‘候选项’。借助 stun 服务，浏览器得到 NAT 类型及 NAT 后的地址（公网 IP 地址）;借助 trun 服务 ，浏览器得到 中继转发所需的地址及端口（中继候选者）。这些都会存到 RTCIceCandidate 对象的 candidate 属性中。 保存 WebRTC 与 远端通信时使用的协议、IP 地址和端口 的集合 它表示 WebRTC 与 远端通信时使用的协议、IP 地址和端口，一般由以下字段组成： 123456789&#123; IP: xxx.xxx.xxx.xxx, // 本地 IP 地址 port: number, // 本地端口号 type: host/srflx/relay, // 候选者类型，包括 host、srflx 和 relay priority: number, // 优先级 protocol: UDP/TCP, // 传输协议 usernameFragment: string // 访问服务的用户名 ...&#125; host 表示本机候选者 （内网连通） srflx 表示内网主机映射的外网的地址和端口 （P2P 方式） relay 表示中继候选者 作用过程 当 WebRTC 通信双方彼此要进行连接时，每一端都会提供许多候选者，比如你的主机有两块网卡，那么每块网卡的不同端口都是一个候选者。 WebRTC 会按照上面描述的格式对候选者进行排序，然后按优先级从高到低的顺序进行连通性测试，当连通性测试成功后，通信的双方就建立起了连接。 先级从高到低：host(本机内网连通)&gt;srflx(内网主机映射的外网的地址和端口)&gt;relay(中继候选者) 先对 host 类型的候选者进行连通性检测(检测内网连通性)，如果它们之间可以互通，则直接建立连接。 同样的道理，如果 host 类型候选者之间无法建立连接，那么 会尝试次优先级的 srflx 类型的候选者。也就是尝试让通信双方直接通过 P2P 进行连接，如果连接成功就使用 P2P 传输数据； 如果失败，就最后尝试使用 relay 方式建立连接。 关于 ICE 用于实现打洞的协议 称为 交互式连接建立协议 （Interactive Connectivity Establishment） ICE (Interactive Connectivity Establishment ： 交互式连接建立)是一个被 WebRTC 使用的框架。一种综合性的 NAT 穿越技术，可以整合各种 NAT 穿越技术如 STUN、TURN（Traversal Using Relay NAT 中继 NAT 实现的穿透）。ICE 会先使用 STUN，尝试建立一个基于 UDP 的连接，如果失败了，就会去 TCP（先尝试 HTTP，然后尝试 HTTPS），如果依旧失败 ICE 就会使用一个中继的 TURN 服务器。 这个框架的算法是寻找最低等待时间的路径去连接两端，通常采用以下顺序寻找： 直接的 UDP 连接 (在且仅在这种情况下，一个 STUN 的服务器会被用来查找主机端面向网络的地址)。 直接的 TCP 连接, 通过 HTTP 端口 直接的 TCP 连接, 通过 HTTPS 端口 间接的连接通过中继器／TURN 服务器 (如果一个直接连接失败了, 比如当一个主机端位于防火墙之后阻止了 NAT 穿越) ICE 状态 ICE 保活 对于每个 ICE 通道，都需要为其会话进行保活。 采用 STUN binding request 或者 STUN binding indication。 如果没有收到响应，则会重传，直到最大重传次数。 收集 Candidate 端对端的建立更主要的工作是 Candidate 的收集。 WebRTC 将 Candidate 分为三种类型： host 类型，即本机内网的 IP 和端口；（ 比较容易获得 ） srflx 类型, 即本机 NAT 映射后的外网的 IP 和端口； relay 类型，即中继服务器的 IP 和端口。 其中，host 类型优先级最高，srflx 次之，relay 最低（前面我们已经说明过了）。 srflx 类型: STUN 服务 srflx 类型的 Candidate 实际上就是内网地址和端口经 NAT 映射后的外网地址和端口。 如果主机没有公网地址，是无论如何都无法访问公网上的资源的。 一般情况下，主机都只有内网 IP 和端口，但是在内网的网关上都有 NAT (Net Address Transport) 功能，==NAT 的作用就是进行内外网的地址转换==。当你要访问公网上的资源时，NAT 首先会将该主机的内网地址转换成外网地址，然后才会将请求发送给要访问的服务器；服务器处理好后将结果返回给主机的公网地址和端口，再通过 NAT 最终中转给内网的主机 引申：获得外网 IP 地址 根据上面描述，其实 只需要在公网上架设一台服务器，并向这台服务器发个请求说，服务器回值。这样你就可以知道自己的公网 IP 了（在百度搜索 ip 获得外网 ip 地址 就是这个原理） 上面的描述已经被定义成了一套规范，即 RFC5389 ，也就是 STUN 协议(Session Traversal Utilities for NAT，NAT 会话穿越应用程序)，我们只要遵守这个协议就可以拿到自己的公网 IP 了,而后 创建 UDP 通信。 这里我们举个例子，看看通过 STUN 协议，主机是如何获取到自己的外网 IP 地址和端口的。 首先在外网搭建一个 STUN 服务器，现在比较流行的 STUN 服务器是 CoTURN，你可以到 GitHub 上自己下载源码编译安装。 当 STUN 服务器安装好后，从内网主机发送一个 binding request 的 STUN 消息到 STUN 服务器。 STUN 服务器收到该请求后，会将请求的 IP 地址和端口填充到 binding response 消息中，然后顺原路将该消息返回给内网主机。此时，收到 binding response 消息的内网主机就可以解析 binding response 消息了，并可以从中得到自己的外网 IP 和端口 relay 类型:TURN 服务 relay 服务是通过 TURN 协议实现的。所以我们经常说的 relay 服务器或 TURN 服务器它们是同一个意思，都是指中继服务器 relay 类型 候选者的优先级最低，通率最高。 在其他候选者都无法连通的情况下，relay 候选者就成了最好的选择【最佳备胎】。 relay 型候选者的获取也是通过 STUN 协议完成的，只不过它使用的 STUN 消息类型与获取 srflx 型候选者的 STUN 消息的类型不一样而已。 RFC5766 的 TURN 协议描述了如何获取 relay 服务器（即 TURN 服务器）的 Candidate 过程。其中最主要的是 Allocation 指令。通过向 TURN 服务器发送 Allocation 指令，relay 服务就会在服务器端分配一个新的 relay 端口，用于中转 UDP 数据报。 按优先级顺序进行连通性检测 NAT 打洞 /P2P 穿越 当收集到 Candidate 后，WebRTC 就开始按优先级顺序进行连通性检测了。 它首先会判断两台主机是否处于同一个局域网内，如果双方确实是在同一局域网内，那么就直接在它们之间建立一条连接。 但如果两台主机不在同一个内网，WebRTC 将尝试 NAT 打洞（P2P 穿越）。 NAT 打洞是极其复杂的过程 首先需要对 NAT 类型做判断， 检测出其类型后，才能判断出是否可以打洞成功， 只有存在打洞成功的可能性时才会真正尝试打洞。 WebRTC 将 NAT 分类为 4 种类型，分别是 完全锥型 NAT IP 限制型 NAT 端口限制型 NAT 对称型 NAT 对称型 NAT 与 对称型 NAT 是无法进行 P2P 穿越的； 对称型 NAT 与 端口限制型 NAT 也是无法进行 P2P 连接的 流程总结 交互通信 ：呼叫要交换两种信息，一是候选地址（交换候选者），二是媒体信息（交换 SDP 媒体协商）。 信令与视频通话 webrtc 时序图 呼叫建立过程 场景预制说明 通信的双方我们称为 client_A 和 client_B； client_A 为呼叫方，client_B 为被呼叫方； TURN_C 为中继服务器，也称为 relay 服务器或 TURN 服务器。 client_A 创建 RTCPeerConnection 后（操作 本地 媒体轨道 addTracks），使用 createOffer 创建 Offer，得到 SDP。 client_A 使用 setLocalDescription，设置本地 SDP 信息 （媒体信息描述）,client_A 开始 收集 ICE 候选者,[ 本地地址 host类型（从网卡获得）、反射地址 srvflx类型（连接stun 服务获 取）、中继地址 relay 类型（从trun 服务或其他媒体中继服务获得）] client_A 随后 通过 信令服务 将 SDP 发送 给 client_B client_B 通过 信令服务 ，接收到 client_A 的 SDP ，创建 RTCPeerConnection 后（操作 本地 媒体轨道 addTracks），通过 setRemoteDescription，设置远端的 SDP （连接另一端的描述） client_B 通过 createAnswer，创建 Answer ，lient_B 开始 收集 ICE 候选者（方式与 步骤2 相同），随后 通过 信令服务 将 SDP 发送 给 client_A client_A 接收到 client_B 的 SDP 通过 setRemoteDescription，设置远端的 SDP 到 本地远端域 ,到此媒体协商完毕，确定了编解码协议 步骤 2 client_A 创建 Offer（实际 是 setLocalDescription 后） 就已经 收集 ICE 候选者，收到后（回来一个发一个） 立即触发 onIceCandidate 事件，从 ICE 层接受外向候选 通过 信令服务 发给 client_B(开始进行 ICECandidate 交换【ICE 协商】 ) client_B 接收 信令服务 Candidate 事件，先使用 addIceCandidate 保存 client_A 的 ICECandidate 到候选者列表，随即开始尝试 联通性测试（按优先级顺序进行连通性检测） 步骤 5 client_B 创建 Answer （实际 是 setLocalDescription 后）就已经 收集 ICE 候选者，收到后（回来一个发一个）立即触发 onIceCandidate 事件，通过 信令服务 发给 client_A 【此步骤 与 7、8 并无前后关系，异步的】 client_A 通过 信令服务 接到 client_B 候选者信息，先使用 addIceCandidate 保存 client_B 的 ICECandidate 到候选者列表，随即开始尝试 联通性测试（按优先级顺序进行连通性检测 client_B） 联通性测试 按照 候选地址 Type 顺序 host &gt; srvflx &gt; prflx &gt; relay host 类型 本地局域网直接进行联通，srvflx 类型 发 Stun Binding 请求，进行 Stun 检查。经过一些了测试连接后 选定最优候选地址，并启动媒体 长连接：为确保 NAT 映射和过滤规则不在媒体会话期间超时，ICE 会不断通过使用中的候选项对发送 Stun 连接检查。 除了主叫必须创建 Offer 才开始收集候选地址、被叫必须创建 Answer 才开始收集候选地址外，ICE 代理 是相互独立地处理媒体 和 候选地址 prflx 候选项 假如 client_A 和 Stun 服务器之间连接状态不好，在它收到 client_B 发来的 srflx 候选者 之后还没得出自个的 srflx 候选者，随即开始进行联通测试（得到对方的 srflx 候选者，就可以 Stun 检查，进行打洞联通）。client_B 收到这个请求，从请求解析出 client_A 的地址信息。虽然这个地址在值上等于 client_A 的 srflx，但不是从信令服务器得到，而是来自对端的 Stun 请求。此时 client_B 就会以这个 prflx 向状态表新建 Connection。 client_A 在之后终于向 Stun 服务器拿到了自个的 srflx，并通过信令服务器发向 client_B。client_B 发现这个 srflx 值对应的 Connection 已存在，就不会再创建了。 一般在调用 setLocalDescription 方法后才开始进行 ICE 过程，开启候选者收集 因为 setLocalDescription 得到得本地 SDP 信息中指示了需要的 ICE 组件个数（跟需要建立的传输通道数相同，而传输通道数与媒体轨道个数、媒体轨道的绑定策略 BundlePolicy、RTP/RTCP 的通道复用策略 RtcpMuxPolicy 都有关系）以及哪些候选项（与 IceTransportsType 参数有关）需要被收集。然而，为了加速媒体通道建立，一些应用如果提前知道需要的 ICE 组件个数，那么它可以提前（在调用 setLocalDescription 之前就开始）收集一个池子的 ICE 候选项来帮助快速的建立媒体通道。 场景 1: client_A、client_B 属于同一办公区域同一网段。一般存在两种联通路径： 一种是双方通过内网直接进行连接； 另一种是通过公网，也就是通过公司的网关，从公网绕一圈后再进入公司实现双方的通信","categories":[{"name":"技术帖","slug":"技术帖","permalink":"http://mcdowell8023.github.io/categories/%E6%8A%80%E6%9C%AF%E5%B8%96/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://mcdowell8023.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"直播","slug":"直播","permalink":"http://mcdowell8023.github.io/tags/%E7%9B%B4%E6%92%AD/"},{"name":"webrtc","slug":"webrtc","permalink":"http://mcdowell8023.github.io/tags/webrtc/"}]},{"title":"webrtc-媒体协商","slug":"rtc/webrtc/note8","date":"2021-08-01T07:24:44.000Z","updated":"2025-03-08T10:04:51.530Z","comments":true,"path":"2021/08/01/rtc/webrtc/note8/","permalink":"http://mcdowell8023.github.io/2021/08/01/rtc/webrtc/note8/","excerpt":"","text":"媒体协商 媒体协商 就是 双方客户端 设备都支持那些编解码器，双方都支持的设备，作为协议编解码的参数 媒体协商包括两部分： 创建连接，指的是创建 RTCPeerConnection，它负责端与端之间彼此建立 P2P 连接。 信令signal，指的是客户端通过信令服务器交换 SDP 信息。 媒体协商作用 媒体协商的作用就是让双方找到共同支持的媒体能力(如双方都支持的编解码器)，从而最终实现彼此之间的音视频通信。 媒体协商过程 通信双方将它们各自的媒体信息，如编解码器、媒体流的 SSRC(RTCP 的控制报文)、传输协议、IP 地址和端口等，按 SDP 格式整理好。 通信双方通过信令服务器交换 SDP 信息，并待彼此拿到对方的 SDP 信息后，找出它们共同支持的媒体能力。 双方按照协商好的媒体能力开始音视频通信 RTCPeerConnection 端与端之间建立连接,WebRTC 库中最关键的一个类，通过它创建出来的对象可以做很多事情，如 NAT 穿越、音视频数据的接收与发送，甚至它还可以用于非音视频数据的传输等等 RTCPeerConnection 除了会在端与端之间建立连接、传输音视频数据外，还要进行两次绑定：一次是与媒体源进行绑定，以解决数据从哪里来的问题；另外一次是与输出进行绑定，以解决接收到的音视频数据显示 / 播放的问题。 1234var pcConfig = nullvar RTCPeerConnection = window.RTCPeerConnection || window.webkitRTCPeerConnectionvar pc = new RTCPeerConnection(pcConfig) 媒体协商的过程 Offer 与 Answer Offer，在双方通讯时，呼叫方（clientA）发送的 SDP 消息称为 Offer。 Answer，在双方通讯时，被呼叫方（clientB）发送的 SDP 消息称为 Answer。 协商的过程 呼叫方 创建 Offer 类型的 SDP 消息。 创建完成后，调用 setLocalDescriptoin 方法将该 Offer 保存到本地 Local 域，然后通过==信令==将 Offer 发送给被呼叫方。 被呼叫方收到 Offer 类型的 SDP 消息后，调用 setRemoteDescription 方法将 Offer 保存到它的 Remote 域。 作为应答，被呼叫方要创建 Answer 类型的 SDP 消息，Answer 消息创建成功后，再调用 setLocalDescription 方法将 Answer 类型的 SDP 消息保存到本地的 Local 域。 最后，被呼叫方将 Answer 消息通过信令发送给呼叫方。至此，被呼叫方的工作就完部完成了。 接下来是呼叫方的收尾工作，呼叫方收到 Answer 类型的消息后，调用 RTCPeerConnecton 对象的 setRemoteDescription 方法，将 Answer 保存到它的 Remote 域。 当通讯双方拿到彼此的 SDP 信息后，就可以进行媒体协商了。媒体协商的具体过程是在 WebRTC 内部实现的，我们作为 webrtc 使用者，需要 本地的 SDP 和远端的 SDP 都设置好后，协商就算成功了。 createOffer ，创建 Offer； createAnswer，创建 Answer； setLocalDescription，设置本地 SDP 信息； setRemoteDescription，设置远端的 SDP 信息。 通信双方链路的建立是在设置本地媒体能力，即调用 setLocalDescription 函数之后才进行的。 详细代码过程： 呼叫方创建 Offer 创建 Offer 类型的 SDP 信息，即调用 RTCPeerConnection 的 createOffer() 方法 成功后，调用 RTCPeerConnection 的 setLocalDescription() 把本地 SDP（会话描述）信息，提交到本地域 通过信令通道将此会话描述发送给被呼叫方 createOffer、setLocalDescription 返回 一个 Promise 12345678910111213141516function doCall() &#123; console.log(&#x27;Sending offer to peer&#x27;) // pc.createOffer(setLocalAndSendMessage, handleCreateOfferError) pc.createOffer( function (sessionDescription) &#123; // sessionDescription -- RTCSessionDescription 类型的 SDP 信息 console.log(sessionDescription, &#x27;sessionDescription--成功&#x27;) // 将本地 SDP 描述信息设置到 WebRTC 的 Local 域 pc.setLocalDescription(sessionDescription) sendMessage(sessionDescription) &#125;, function (error) &#123; console.log(error, &#x27;---报错&#x27;) &#125; )&#125; 12345678910111213141516// 推荐使用方式function doCall() &#123; pc.createOffer() .then(function (offer) &#123; console.log(offer, &#x27;offer&#x27;) pc_offer = pc.setLocalDescription(offer) return pc_offer &#125;) .then(function () &#123; console.log(&#x27;通过信令服务来发送&#x27;, pc_offer) // Send the offer to the remote peer using the signaling server &#125;) .catch((reportError) =&gt; &#123; console.log(reportError, &#x27;reportError--报错&#x27;) &#125;)&#125; 被呼叫方收到 Offer 调用 setRemoteDescription 方法设置呼叫方发送给它的 Offer 作为远端描述。 12345678910111213socket.on(&#x27;message&#x27;, function(message) &#123; ... &#125; else if (message.type === &#x27;offer&#x27;) &#123; // 设置 呼叫方的 offer 到远端域 // 借助 RTCSessionDescription 进行解析 pc.setRemoteDescription(new RTCSessionDescription(message)); // 一般在此处 进行 第三步，createAnswer 创建被呼叫放的应答 doAnswer(); &#125; else if (...) &#123; ... &#125; ....&#125;); 被呼叫方创建 Answer 被呼叫方调用 RTCPeerConnection 对象的 createAnswer 方法，它会生成一个与远程会话兼容的本地会话，并最终将该会话描述发送给呼叫方。 createAnswer、setLocalDescription 返回 一个 Promise 12345678pc.createAnswer() .then(function (answer) &#123; return pc.setLocalDescription(answer) &#125;) .then(function () &#123; // Send the answer to the remote peer through the signaling server. &#125;) .catch(handleGetUserMediaError) 呼叫方收到 Answer 当呼叫方得到 被呼叫方的 会话描述(SDP) 时，调用 setRemoteDescription 方法，将收到的会话描述设置为一个远程会话。代码如下： 12345678910 socket.on(&#x27;message&#x27;, function(message) &#123; ... &#125; else if (message.type === &#x27;answer&#x27;) &#123; pc.setRemoteDescription(new RTCSessionDescription(message)); &#125; else if (...) &#123; ... &#125; ....&#125;); 媒体协商过程完成。 紧接着在 WebRTC 底层会收集 ==Candidate==，并进行连通性检测，最终在通话双方之间建立起一条链路来。 webrtc-offer.txt 示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136## 示例是实际 抓包后的数据-----会话层v=0 版本号o=- 5571710891932704000 2 IN IP4 127.0.0.1 session名 sessionId 版本(每次sdp生成版本号+1) IN(互联网)s=- session名t=0 0 起始时间 结束时间a=group:BUNDLE 0 媒体流绑定一起 传输为1条链路a=msid-semantic: WMS lyasyMn4vDMTNLbTCNwVFjqnrIa5pfzLtA5s 媒体流ID--媒体描述m=video 9 UDP/TLS/RTP/SAVPF 96 97 98 99 100 101 102 122 127 121 125 107 108 109 124 120 123 119 114 115 116 视频流 9表示该传输端口不使用c=IN IP4 0.0.0.0 webrtp并不适用的网络连接描述a=rtcp:9 IN IP4 0.0.0.0//======= 安全描述 ============a=ice-ufrag:TfmK // 进入连通性检测的用户名 -- 链路有效性校验a=ice-pwd:d+m1xsN8cqRVOQpNLknLX9kG // 密码，这两个是用于连通性检测的凭证-- 链路有效性校验a=ice-options:trickle ice通路手机策略 异步a=fingerprint:sha-256 4F:1D:54:C2:84:4C:C4:CD:75:DC:CB:1C:3A:CA:88:B9:1A:67:1F:85:BC:D9:A9:E5:35:F3:0C:41:BA:03:13:55 //DTLS 指纹认证，以识别是否是合法用户 -- 链路有效性校验a=setup:actpass 可选择作为服务端和客户端 actpass 服务器端 active客户端a=mid:0 对应媒体流组ID的描述a=extmap:14 urn:ietf:params:rtp-hdrext:toffseta=extmap:13 http://www.webrtc.org/experiments/rtp-hdrext/abs-send-timea=extmap:12 urn:3gpp:video-orientationa=extmap:2 http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01a=extmap:11 http://www.webrtc.org/experiments/rtp-hdrext/playout-delaya=extmap:6 http://www.webrtc.org/experiments/rtp-hdrext/video-content-typea=extmap:7 http://www.webrtc.org/experiments/rtp-hdrext/video-timinga=extmap:8 http://tools.ietf.org/html/draft-ietf-avtext-framemarking-07a=extmap:9 http://www.webrtc.org/experiments/rtp-hdrext/color-spacea=extmap:3 urn:ietf:params:rtp-hdrext:sdes:mida=extmap:4 urn:ietf:params:rtp-hdrext:sdes:rtp-stream-ida=extmap:5 urn:ietf:params:rtp-hdrext:sdes:repaired-rtp-stream-ida=sendrecv 可发送而可接受 还有 只发送 只接受 等值a=msid:lyasyMn4vDMTNLbTCNwVFjqnrIa5pfzLtA5s 3ccc5e67-09ad-434b-83e0-1c29f316b4b7//======== 服务质量描述 =========a=rtcp-mux 多路复用a=rtcp-rsize 如果该路数据过多影响了网路 可不发送该路数据a=rtpmap:96 VP8/90000a=rtcp-fb:96 goog-remba=rtcp-fb:96 transport-cca=rtcp-fb:96 ccm fir 关键帧a=rtcp-fb:96 nacka=rtcp-fb:96 nack pli 丢包响应a=rtpmap:97 rtx/90000a=fmtp:97 apt=96a=rtpmap:98 VP9/90000a=rtcp-fb:98 goog-remba=rtcp-fb:98 transport-cca=rtcp-fb:98 ccm fira=rtcp-fb:98 nacka=rtcp-fb:98 nack plia=fmtp:98 profile-id=0a=rtpmap:99 rtx/90000a=fmtp:99 apt=98a=rtpmap:100 VP9/90000a=rtcp-fb:100 goog-remb // 使用 google 的带宽评估算法a=rtcp-fb:100 transport-cc // 启动防拥塞a=rtcp-fb:100 ccm fir // 解码出错，请求关键帧a=rtcp-fb:100 nack // 启用丢包重传功能a=rtcp-fb:100 nack pli // 与 fir 类似a=fmtp:100 profile-id=2a=rtpmap:101 rtx/90000a=fmtp:101 apt=100a=rtpmap:102 H264/90000a=rtcp-fb:102 goog-remba=rtcp-fb:102 transport-cca=rtcp-fb:102 ccm fira=rtcp-fb:102 nacka=rtcp-fb:102 nack plia=fmtp:102 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42001fa=rtpmap:122 rtx/90000a=fmtp:122 apt=102a=rtpmap:127 H264/90000a=rtcp-fb:127 goog-remba=rtcp-fb:127 transport-cca=rtcp-fb:127 ccm fira=rtcp-fb:127 nacka=rtcp-fb:127 nack plia=fmtp:127 level-asymmetry-allowed=1;packetization-mode=0;profile-level-id=42001fa=rtpmap:121 rtx/90000a=fmtp:121 apt=127a=rtpmap:125 H264/90000a=rtcp-fb:125 goog-remba=rtcp-fb:125 transport-cca=rtcp-fb:125 ccm fira=rtcp-fb:125 nacka=rtcp-fb:125 nack plia=fmtp:125 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42e01fa=rtpmap:107 rtx/90000a=fmtp:107 apt=125a=rtpmap:108 H264/90000a=rtcp-fb:108 goog-remba=rtcp-fb:108 transport-cca=rtcp-fb:108 ccm fira=rtcp-fb:108 nacka=rtcp-fb:108 nack plia=fmtp:108 level-asymmetry-allowed=1;packetization-mode=0;profile-level-id=42e01fa=rtpmap:109 rtx/90000a=fmtp:109 apt=108a=rtpmap:124 H264/90000a=rtcp-fb:124 goog-remba=rtcp-fb:124 transport-cca=rtcp-fb:124 ccm fira=rtcp-fb:124 nacka=rtcp-fb:124 nack plia=fmtp:124 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=4d0032a=rtpmap:120 rtx/90000a=fmtp:120 apt=124a=rtpmap:123 H264/90000a=rtcp-fb:123 goog-remba=rtcp-fb:123 transport-cca=rtcp-fb:123 ccm fira=rtcp-fb:123 nacka=rtcp-fb:123 nack plia=fmtp:123 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=640032a=rtpmap:119 rtx/90000a=fmtp:119 apt=123a=rtpmap:114 red/90000a=rtpmap:115 rtx/90000a=fmtp:115 apt=114a=rtpmap:116 ulpfec/90000 fec冗余包 传输a=ssrc-group:FID 488892873 4271901047a=ssrc:488892873 cname:bpXJsotPCw9hoiWFa=ssrc:488892873 msid:lyasyMn4vDMTNLbTCNwVFjqnrIa5pfzLtA5s 3ccc5e67-09ad-434b-83e0-1c29f316b4b7a=ssrc:488892873 mslabel:lyasyMn4vDMTNLbTCNwVFjqnrIa5pfzLtA5sa=ssrc:488892873 label:3ccc5e67-09ad-434b-83e0-1c29f316b4b7a=ssrc:4271901047 cname:bpXJsotPCw9hoiWFa=ssrc:4271901047 msid:lyasyMn4vDMTNLbTCNwVFjqnrIa5pfzLtA5s 3ccc5e67-09ad-434b-83e0-1c29f316b4b7a=ssrc:4271901047 mslabel:lyasyMn4vDMTNLbTCNwVFjqnrIa5pfzLtA5sa=ssrc:4271901047 label:3ccc5e67-09ad-434b-83e0-1c29f316b4b7","categories":[{"name":"技术帖","slug":"技术帖","permalink":"http://mcdowell8023.github.io/categories/%E6%8A%80%E6%9C%AF%E5%B8%96/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://mcdowell8023.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"直播","slug":"直播","permalink":"http://mcdowell8023.github.io/tags/%E7%9B%B4%E6%92%AD/"},{"name":"webrtc","slug":"webrtc","permalink":"http://mcdowell8023.github.io/tags/webrtc/"}]},{"title":"webrtc-SDP","slug":"rtc/webrtc/note7","date":"2021-07-28T10:43:41.000Z","updated":"2025-03-08T10:46:27.065Z","comments":true,"path":"2021/07/28/rtc/webrtc/note7/","permalink":"http://mcdowell8023.github.io/2021/07/28/rtc/webrtc/note7/","excerpt":"","text":"WebRTC 的驱动核心:SDP SDP 是什么 SDP（Session Description Protocal）[会话描述协议] 说直白点就是用文本描述的各端（PC 端、Mac 端、Android 端、iOS 端等）的能力。这里的能力指的是各端所支持的音频编解码器是什么，这些编解码器设定的参数是什么，使用的传输协议是什么，以及包括的音视频媒体是什么等等。 SDP 片段 123456789v=0o=- 3409821183230872764 2 IN IP4 127.0.0.1...m=audio 9 UDP/TLS/RTP/SAVPF 111 103 104 9 0 8 106 105 13 110 112 113 126...a=rtpmap:111 opus/48000/2a=rtpmap:103 ISAC/16000a=rtpmap:104 ISAC/32000... 解析说明： SDP 中描述了一路音频流，即 m=audio，该音频支持的 Payload ( 即数据负载 ) 类型包括 111、103、104 等等 a=rtpmap:111 opus/48000/2 表示 Payload 类型为 111 的数据是 OPUS 编码的音频数据，并且它的采样率是 48000，使用双声道。 a=rtpmap:104 ISAC/32000 的含义是音频数据使用 ISAC 编码，采样频率是 32000，使用单声道 … 交换 SDP 信息 两个客户端 / 浏览器进行 1 对 1 通话时，首先要进行信令交互，而交互的一个重要信息就是 SDP 的交换 交换 SDP 的目的是 彼此清楚知道双方能力，然后根据双方各自的能力进行协商，协商出大家认可的音视频编解码器、编解码器相关的参数（如音频通道数，采样率等）、传输协议等信息。 例如：A 与 B 进行通讯 先各自在 SDP 中记录自己支持的音频参数、视频参数、传输协议等信息， 然后再将自己的 SDP 信息通过信令服务器发送给对方。 当一方收到对端传来的 SDP 信息后，它会将接收到的 SDP 与自己的 SDP 进行比较，并取出它们之间的交集，这个交集就是它们协商的结果，也就是它们最终使用的音视频参数及传输协议了 标准 SDP 规范 标准文档说明 标准 SDP 规范 主要包括SDP 描述格式和SDP 结构 SDP 描述格式 SDP 结构 （从每段信息描述） 会话描述 （一个） 媒体信息描述 （多个） 媒体类型 媒体格式 传输协议 传输的 IP 和端口 媒体信息描述是整个 SDP 规范中最重要的知识 SDP 的格式 【每个区间段代表的意思】 SDP 是由多个 = 这样的表达式组成的。其中，是一个字符，是一个字符串。需要特别注意的是，“=” 两边是不能有空格的。 SDP 由一个会话级描述（session level description）和多个媒体级描述（media level description）组成 会话级（session level）: 对整个会话作用，其位置是从 v= 行开始到第一个媒体描述为止。 媒体级（media level）: 对单个的媒体流进行描述，其位置是从 m= 行开始到下一个媒体描述（即下一个 m=）为止 SDP 示例： 1234567891011# 会话描述v=0o=- 7017624586836067756 2 IN IP4 127.0.0.1s=-t=0 0# 下面 m= 开头的两行，是两个媒体流：一个音频，一个视频。m=audio 9 UDP/TLS/RTP/SAVPF 111 103 104 9 0 8 106 105 13 126...m=video 9 UDP/TLS/RTP/SAVPF 96 97 98 99 100 101 102 122 127 121 125 107 108 109 124 120 123 119 114 115 116... SDP 的结构 【各个区间的 字段代表的含义】 会话描述 介绍 比较重要的 四个字段 v=（protocol version，必选）；【v version 必选】 例子：v=0 ，表示 SDP 的版本号，但不包括次版本号 o=（owner/creator and session identifier，必选)【o origin/owner 必选 】 例子：o=&lt;username&gt; &lt;session id&gt; &lt;version&gt; &lt;network type&gt; &lt;address type&gt; &lt;address&gt;，该例子是对一个会话发起者的描述 其中，o= 表示的是对会话发起者的描述； &lt;username&gt;：用户名，当不关心用户名时，可以用 “－” 代替 ； &lt;session id&gt; ：数字串，在整个会话中，必须是唯一的，建议使用 NTP 时间戳； &lt;version&gt;：版本号，每次会话数据修改后，该版本值会递增； &lt;network type&gt; ：网络类型，一般为“IN”，表示“internet”； &lt;address type&gt;：地址类型，一般为 IP4； &lt;address&gt;：IP 地址。 s= sessionName 必选 -为忽略 例子：s=&lt;session name&gt;，该例子表示一个会话，在整个 SDP 中有且只有一个会话，也就是只有一个 s=。 t=（time the session is active，必选)。 例子：t=&lt;start time&gt; &lt;stop time&gt;，该例子描述了会话的开始时间和结束时间。 &lt;start time&gt; 和 &lt;stop time&gt; 为 NTP 时间，单位是秒； 当&lt;start time&gt;和&lt;stop time&gt;均为零时，表示持久会话。 媒体描述 介绍 比较重要的 四个字段 c connectionData 必选 数据连接 c=&lt;network type&gt; &lt;address type&gt; &lt;connection address&gt; eg: c=IN IP4 0.0.0.0 : internet ipv4 ip 地址 m=（media name and transport address，可选）。 例子：m=&lt;media&gt; &lt;port&gt; &lt;transport&gt; &lt;fmt list&gt;， 表示一个会话。在一个 SDP 中一般会有多个媒体描述。 每个媒体描述以“m=”开始到下一个“m=”结束。其中， &lt;media&gt;：媒体类型，比如 audio/video 等； &lt;port&gt;：端口； &lt;transport&gt;：传输协议，有两种——RTP/AVP 和 UDP； &lt;fmt list&gt;：媒体格式，即数据负载类型 (Payload Type) 列表。 a=\\*（zero or more media attribute lines，可选）。 例子：a=&lt;TYPE&gt;或 a=&lt;TYPE&gt;:&lt;VALUES&gt;， 表示属性，用于进一步描述媒体信息； 在例子中， 指属性的类型。eg: a=framerate:&lt;帧速率&gt; a= 有两个特别的属性类型，即下面要介绍的 rtpmap 和 fmtp。 rtpmap（可选）。 例子：a=rtpmap:&lt;payload type&gt; &lt;encoding name&gt;/&lt;clock rate&gt;[/&lt;encodingparameters&gt;]。 rtpmap 是 rtp 与 map 的结合，即 RTP 参数映射表。 &lt;payload type&gt; ：负载类型，对应 RTP 包中的音视频数据负载类型。 &lt;encoding name&gt;：编码器名称，如 VP8、VP9、OPUS 等。 &lt;sample rate&gt;：采样率，如音频的采样率频率 32000、48000 等。 &lt;encodingparameters&gt;：编码参数，如音频是否是双声道，默认为单声道 eg: a=rtpmap:103 ISAC/160000 103 对应 ISAC 始终频率 16000 次每秒 fmtp。 例子：a=fmtp:&lt;payload type&gt; &lt;format specific parameters&gt;。 fmtp，格式参数，即 format parameters； &lt;payload type&gt; ，负载类型，同样对应 RTP 包中的音视频数据负载类型； &lt; format specific parameters&gt;指具体参数 eg: a=fmtp:103 apt=106 103关联106属性 一个示例对照表 12345678910111213141516171819v=0o=- 4007659306182774937 2 IN IP4 127.0.0.1 #s=-t=0 0// 以上表示会话描述...// 下面的媒体描述，在媒体描述部分包括音频和视频两路媒体m=audio 9 UDP/TLS/RTP/SAVPF 111 103 104 9 0 8 106 105 13 110 112 113 126...a=rtpmap:111 opus/48000/2 // 对 RTP 数据的描述a=fmtp:111 minptime=10;useinbandfec=1 // 对格式参数的描述...a=rtpmap:103 ISAC/16000a=rtpmap:104 ISAC/32000...// 上面是音频媒体描述，下面是视频媒体描述m=video 9 UDP/TLS/RTP/SAVPF 96 97 98 99 100 101 102 122 127 121 125 107 108 109 124 120 123 119 114 115 116...a=rtpmap:96 VP8/90000 WebRTC 中的 SDP 文档 - draft-nandakumar-rtcweb-sdp WebRTC 对标准 SDP 规范做了一些调整： WebRTC 中的 SDP 结构分层 SDP 会话层 Session Metadata，会话元数据 – 就是 SDP 标准规范中的会话层描述 媒体层 媒体流描述 Stream Description – 与 SDP 标准规范中的媒体层描述是一致的 网络描述 Network Description – 与 SDP 标准规范中的媒体层描述是一致的 安全描述 Security Descriptions – WebRTC 新增的属性描述 服务质量描述 Qos Grouping Descriptions – WebRTC 新增的属性描述 摘自 文档 结构示意图： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364 +---------------------+ | v= | +---------------------+ +---------------------+ +---------------------+ ==== | Session Metadata | ===== | o= | | +---------------------+ +---------------------- | +---------------------+ | | t= | | +---------------------+ | | | +---------------------+ | | c= | | +---------------------+ | +---------------------+ ==== | Network Description | ===== | +---------------------+ | +---------------------+ | | a=candidate | | +---------------------+ | | | +---------------------+ | | m= | | +---------------------+ | +---------------------+ +---------------------+ ==== | Stream Description | ===== | a=rtpmap | | +---------------------+ +---------------------- | +---------------------+ | | a=fmtp | | +---------------------+ | +---------------------+ | | a=sendrecv.. | | +---------------------++---------------+| SEMANTIC || COMPONENTS OF || SDP |+---------------+ | +---------------------+ | | a=crypto | | +---------------------+ | +---------------------+ +---------------------+ ==== |Security Descriptions| =====| a=ice-frag | | +---------------------+ +---------------------+ | +---------------------+ | | a=ice-pwd | | +---------------------+ | +---------------------+ | | a=fingerprint | | +---------------------+ | | | | +---------------------+ | | a=rtcp-fb | | +---------------------+ | +---------------------+ +---------------------+ ==== | Qos,Grouping | | | | Descriptions | =====| a=group | +---------------------+ +---------------------- +---------------------+ | a=rtcpmux | +---------------------+ 12345678910111213141516...//======= 安全描述 ============a=ice-ufrag:1uEe // 进入连通性检测的用户名a=ice-pwd:RQe+y7SOLQJET+duNJ+Qbk7z// 密码，这两个是用于连通性检测的凭证a=fingerprint:sha-256 35:6F:40:3D:F6:9B:BA:5B:F6:2A:7F:65:59:60:6D:6B:F9:C7:AE:46:44:B4:E4:73:F8:60:67:4D:58:E2:EB:9C //DTLS 指纹认证，以识别是否是合法用户...//======== 服务质量描述 =========a=rtcp-muxa=rtcp-rsizea=rtpmap:96 VP8/90000a=rtcp-fb:96 goog-remb // 使用 google 的带宽评估算法a=rtcp-fb:96 transport-cc // 启动防拥塞a=rtcp-fb:96 ccm fir // 解码出错，请求关键帧a=rtcp-fb:96 nack // 启用丢包重传功能a=rtcp-fb:96 nack pli // 与 fir 类似... 上面的 SDP 片段是摘取的 WebRTC SDP 中的安全描述与服务质量描述，这两块描述在标准 SDP 规范中没有明确定义，它更多属于 WebRTC 业务的范畴。 安全描述起的作用 一方面是进行网络连通性检测时，对用户身份进行认证； 另一方面是收发数据时，对用户身份的认证，以免受到对方的攻击。 服务质量描述 指明启动功能以保证音视频的质量 如启动带宽评估，当用户发送数据量太大超过评估的带宽时，要及时减少数据包的发送； 启动防拥塞功能，当预测到要发生拥塞时，通过降低流量的方式防止拥塞的发生等等，这些都属于服务质量描述的范畴。 完整的示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//============= 会话描述 ====================v=0o=- 7017624586836067756 2 IN IP4 127.0.0.1s=-t=0 0...//================ 媒体描述 =================//================ 音频媒体 =================/* * 音频使用端口 1024 收发数据 * UDP/TLS/RTP/SAVPF 表示使用 dtls/srtp 协议对数据加密传输 * 111、103 ... 表示本会话音频数据的 Payload Type */ m=audio 1024 UDP/TLS/RTP/SAVPF 111 103 104 9 0 8 106 105 13 126//============== 网络描述 ==================// 指明接收或者发送音频使用的 IP 地址，由于 WebRTC 使用 ICE 传输，这个被忽略。c=IN IP4 0.0.0.0// 用来设置 rtcp 地址和端口，WebRTC 不使用a=rtcp:9 IN IP4 0.0.0.0...//============== 音频安全描述 ================//ICE 协商过程中的安全验证信息a=ice-ufrag:khLSa=ice-pwd:cxLzteJaJBou3DspNaPsJhlQa=fingerprint:sha-256 FA:14:42:3B:C7:97:1B:E8:AE:0C2:71:03:05:05:16:8F:B9:C7:98:E9:60:43:4B:5B:2C:28:EE:5C:8F3:17...//============== 音频流媒体描述 ================a=rtpmap:111 opus/48000/2//minptime 代表最小打包时长是 10ms，useinbandfec=1 代表使用 opus 编码内置 fec 特性a=fmtp:111 minptime=10;useinbandfec=1...a=rtpmap:103 ISAC/16000a=rtpmap:104 ISAC/32000a=rtpmap:9 G722/8000...//================= 视频媒体 =================m=video 9 UDP/TLS/RTP/SAVPF 100 101 107 116 117 96 97 99 98...//================= 网络描述 =================c=IN IP4 0.0.0.0a=rtcp:9 IN IP4 0.0.0.0...//================= 视频安全描述 =================a=ice-ufrag:khLSa=ice-pwd:cxLzteJaJBou3DspNaPsJhlQa=fingerprint:sha-256 FA:14:42:3B:C7:97:1B:E8:AE:0C2:71:03:05:05:16:8F:B9:C7:98:E9:60:43:4B:5B:2C:28:EE:5C:8F3:17...//================ 视频流描述 ===============a=mid:video...a=rtpmap:100 VP8/90000//================ 服务质量描述 ===============a=rtcp-fb:100 ccm fira=rtcp-fb:100 nack // 支持丢包重传，参考 rfc4585a=rtcp-fb:100 nack plia=rtcp-fb:100 goog-remb // 支持使用 rtcp 包来控制发送方的码流a=rtcp-fb:100 transport-cc...","categories":[{"name":"技术帖","slug":"技术帖","permalink":"http://mcdowell8023.github.io/categories/%E6%8A%80%E6%9C%AF%E5%B8%96/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://mcdowell8023.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"直播","slug":"直播","permalink":"http://mcdowell8023.github.io/tags/%E7%9B%B4%E6%92%AD/"},{"name":"webrtc","slug":"webrtc","permalink":"http://mcdowell8023.github.io/tags/webrtc/"}]},{"title":"webrtc-RTP 及 RTCP 详解","slug":"rtc/webrtc/note6","date":"2021-07-25T06:39:33.000Z","updated":"2025-03-08T09:56:22.334Z","comments":true,"path":"2021/07/25/rtc/webrtc/note6/","permalink":"http://mcdowell8023.github.io/2021/07/25/rtc/webrtc/note6/","excerpt":"","text":"RTP 及 RTCP 详解 实时互动直播系统，是 TCP 还是 UDP 实时互动直播系统的时候你必须使用 UDP 协议。 UDP 传输快，但不可靠，尤其是在用户的网络质量很差的情况下，基本无法保障音视频的服务质量 TCP 比较可靠，为了可靠基本就是，“发送 -&gt; 确认；超时 -&gt; 重发”的反复过程，在这断线重发的过程，最长可达到（失败 7 次）2 分 07 秒， 对于实时直播来说，相当致命。 在 TCP 协议中，为了避免重传次数过多，定时器的超时时间会按 2 的指数增长。也就是说，假设第一次设置的超时时间是 1 秒，那么第二次就是 2 秒，第三次是 4 秒……第七次是 64 秒。如果第七次之后仍然超时，则断开 TCP 连接。你可以计算一下，从第一次超时，到最后断开连接，这之间一共经历了 2 分 07 秒 RTP/RTCP 一般情况下，在实时互动直播系统传输音视频数据流时，我们并不直接将音视频数据流交给 UDP 传输，而是先给音视频数据加个 RTP 头，然后再交给 UDP 进行传输 以视频帧为例，一个 I 帧的数据量是非常大的，最少也要几十 K.而以太网的最大传输单元是 1.5K，所以要传输一个 I 帧需要几十个包。并且这几十个包传到对端后，还要重新组装成 I 帧，这样才能进行解码还原出一幅幅的图像。 所以要想传输，至少需要以下几个标识。 序号：用于标识传输包的序号，这样就可以知道这个包是第几个分片了。 起始标记：记录分帧的第一个 UDP 包。 结束标记：记录分帧的最后一个 UDP 包。 有了上面这几个标识字段，我们就可以在发送端进行拆包，在接收端将视频帧重新再组装起来了。 RTP 协议 (Real-time Transport Protocol 实时传输协议) 针对上面的设计，人们专门定义了一套规范，它就是 RTP 协议。 用于传输流媒体数据 sequence number：序号，用于记录包的顺序。与上面的序号标记作用相同。 timestamp：时间戳，同一个帧的不同分片的时间戳是相同的。这样就省去了前面所讲的起始标记和结束标记。不同帧的时间戳肯定是不一样的。 PT：Payload Type，数据的负载类型。音频流的 PT 值与视频的 PT 值是不同的，简单来说就是标记音频视频的。 … 如果需要自己去解码解，需要对每个字段含义了如指掌。 RTCP (对 RTP 进行控制，同步) 在使用 RTP 包传输数据时，难免会发生丢包、乱序、抖动等问题： 网络线路质量问题引起丢包率高； 传输的数据超过了带宽的负载引起的丢包问题； 信号干扰（信号弱）引起的丢包问题； 跨运营商引入的丢包问题 ; … WebRTC 对这些问题在底层都有相应的处理策略（网络不好如降低码率等操作），但在处理这些问题之前，它首先要让各端都知道它们自己的网络质量到底是怎样的，这就是 RTCP 的作用,用于对 RTP 进行控制，同步 RTCP 通过：SR(Sender Report)【发送方】和 RR（Reciever Report）【回执方】 报文的交换，各端 了解 当前 网络质量。 SR(Sender Report) 以 RTCP SR 报文为例： header 分析： V=2，指报文的版本。 P，表示填充位，如果该位置 1，则在 RTCP 报文的最后会有填充字节（内容是按字节对齐的）。 RC，全称 Report Count，指 RTCP 报文中接收报告的报文块个数。 PT=200，Payload Type，也就是说 SR 的值为 200。 … 具体如下 从上图中我们可以了解到，SR 报文分成三部分 Header 部分用于标识该报文的类型，比如是 SR 还是 RR。 Sender info 部分用于指明作为发送方，到底发了多少包。 Report block 部分指明发送方作为接收方时，它从各个 SSRC 接收包的情况。 SR 报文并不仅是指发送方发了多少数据，它还报告了作为接收方，它接收到的数据的情况。当发送端收到对端的接收报告时，它就可以根据接收报告来评估它与对端之间的网络质量了，随后再根据网络质量做传输策略的调整 FIR (Full Intra Request) 【完整帧请求】 在一个房间里有 3 个人进行音视频聊天，当第四个人加入到房间后，它首先发送 FIR 报文，当其他端收到该报文后，便立即产生各自的 IDR 帧发送给新加入的人，这样当新加入的人拿到房间中其他的 IDR 帧(俗称 I 帧)后，它的解码器就会解码成功，于是其他人的画面也就一下子全部展示出来了。 RTCP 控制协议需要与 RTP 数据协议一起配合使用，当应用程序启动一个 RTP 会话时将同时占用两个端口，分别供 RTP 和 RTCP 使用。 RTP 本身并不能为按序传输数据包提供可靠的保证，也不提供流量控制和拥塞控制，这些都由 RTCP 来负责完成。 通常 RTCP 会采用与 RTP 相同的分发机制，向会话中的所有成员周期性地发送控制信息，应用程序通过接收这些数据，从中获取会话参与者的相关资料，以及网络状况、分组丢失概率等反馈信息，从而能够对服务质量进行控制或者对网络状况进行诊断。 RTP/RTSP/RTCP 有什么区别？","categories":[{"name":"技术帖","slug":"技术帖","permalink":"http://mcdowell8023.github.io/categories/%E6%8A%80%E6%9C%AF%E5%B8%96/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://mcdowell8023.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"直播","slug":"直播","permalink":"http://mcdowell8023.github.io/tags/%E7%9B%B4%E6%92%AD/"},{"name":"webrtc","slug":"webrtc","permalink":"http://mcdowell8023.github.io/tags/webrtc/"}]},{"title":"webrtc-媒体-屏幕抓取","slug":"rtc/webrtc/note5","date":"2021-07-21T01:20:20.000Z","updated":"2025-03-08T09:53:11.054Z","comments":true,"path":"2021/07/21/rtc/webrtc/note5/","permalink":"http://mcdowell8023.github.io/2021/07/21/rtc/webrtc/note5/","excerpt":"","text":"屏幕抓取 共享桌面的基本原理 共享桌面的基本原理其实非常简单，我们可以分“两头”来说明： 共享者，每秒钟抓取多次屏幕（可以是 3 次、5 次等），每次抓取的屏幕都与上一次抓取的屏幕做比较，取它们的差值，然后对差值进行压缩；如果是第一次抓屏或切幕的情况，即本次抓取的屏幕与上一次抓取屏幕的变化率超过 80% 时，就做全屏的帧内压缩，其过程与 JPEG 图像压缩类似（有兴趣的可以自行学习）。最后再将压缩后的数据通过传输模块传送到观看端；数据到达观看端后，再进行解码，这样即可还原出整幅图片并显示出来。 远程控制端，当用户通过鼠标点击共享桌面的某个位置时，会首先计算出鼠标实际点击的位置，然后将其作为参数，通过信令发送给共享端。共享端收到信令后，会模拟本地鼠标，即调用相关的 API，完成最终的操作。一般情况下，当操作完成后，共享端桌面也发生了一些变化，此时就又回到上面共享者的流程了，我就不再赘述了。 通过上面的描述，可以总结出共享桌面的处理过程为：抓屏、压缩编码、传输、解码、显示、控制这几步，你应该可以看出它与音视频的处理过程几乎是一模一样的 RDP（Remote Desktop Protocal）协议， Windows 系统下的共享桌面协议； VNC（Virtual Network Console） 比较通用的远程桌面控制协议，可以实现在不同的操作系统上共享远程桌面，像 TeamViewer、RealVNC 都是使用的该协议 桌面数据：包括了桌面的抓取 (采集)、编码（压缩）、传输、解码和渲染。 信令控制：包括键盘事件、鼠标事件以及接收到这些事件消息后的相关处理等 WebRTC 使用的方式与 RDP/VNC 等真正的远程桌面协议的异同点 共享端桌面数据的采集 WebRTC 对于桌面的采集与 RDP/VNC 使用的技术是相同的，都是利用各平台所提供的相关 API 进行桌面的抓取。以 Windows 为例，可以使用下列 API 进行桌面的抓取。 BitBlt：XP 系统下经常使用，在 vista 之后，开启 DWM 模式后，速度极慢。 Hook：一种黑客技术，实现稍复杂。 DirectX：由于 DirectX 9/10/11 之间差别比较大，容易出现兼容问题。最新的 WebRTC 都是使用的这种方式 GetWindowDC：可以通过它来抓取窗口。 共享端桌面数据的编码。 WebRTC 对桌面的编码使用的是视频编码技术，即 H264/VP8 等；好处是压缩率高，而坏处是在网络不好的情况下会有模糊等问题 RDP/VNC 则不一样，它们使用的是图像压缩技术。 传输。 编码后的桌面数据会通过流媒体传输协议发送到观看端。 WebRTC :当网络有问题时，数据是可以丢失的 RDP/VNC 来说，桌面数据一定不能丢失。 观看端解码。 WebRTC 对收到的桌面数据通过视频解码技术解码 RDP/VNC 使用的是图像解码技术 观看端渲染。WebRTC 与 RDP/VNC 一般都是会通过 OpenGL/D3D 等 GPU 进行渲染。 使用 webrtc 进行屏幕共享 getDisplayMedia MDN var promise = navigator.mediaDevices.getDisplayMedia(constraints); constraints (可选) 一个可选的 MediaStreamConstraints 对象，它指定了返回的 MediaStream 的要求。 因为 getDisplayMedia()需要视频轨道，所以即使 constraints 对象没有明确请求视频轨道，返回的流也会有一个 与 getUserMedia 类似,但是仅仅支持在 pc 上","categories":[{"name":"技术帖","slug":"技术帖","permalink":"http://mcdowell8023.github.io/categories/%E6%8A%80%E6%9C%AF%E5%B8%96/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://mcdowell8023.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"直播","slug":"直播","permalink":"http://mcdowell8023.github.io/tags/%E7%9B%B4%E6%92%AD/"},{"name":"webrtc","slug":"webrtc","permalink":"http://mcdowell8023.github.io/tags/webrtc/"}]},{"title":"webrtc-采集录制","slug":"rtc/webrtc/note4","date":"2021-07-20T03:19:56.000Z","updated":"2025-03-08T09:52:52.592Z","comments":true,"path":"2021/07/20/rtc/webrtc/note4/","permalink":"http://mcdowell8023.github.io/2021/07/20/rtc/webrtc/note4/","excerpt":"","text":"音视频采集 进行 录制 服务端录制： 优点：不用担心客户因自身电脑问题造成录制失败（如磁盘空间不足），也不会因录制时抢占资源（CPU 占用率过高）而导致其他应用出现问题等； 缺点：实现的复杂度很高，画质远不如本地录制 客户端录制： 优点：方便录制方操控，并且所录制的视频清晰度高，实现相对简单。【这里可以和服务端录制做个对比，一般客户端摄像头的分辨率都非常高的（如 1280x720），所以客户端录制可以录制出非常清晰的视频；但服务端录制要做到这点就很困难了，本地高清的视频在上传服务端时由于网络带宽不足，视频的分辨率很有可能会被自动缩小到了 640x360，这就导致用户回看时视频特别模糊，用户体验差。】 -缺点： 客户端在进行录制时会开启第二路编码器，这样会特别耗 CPU。而 CPU 占用过高后，就很容易造成应用程序卡死。除此之外，它对内存、硬盘的要求也特别高，所以录制失败率高。 服务端录制的相关知识，由于与 WebRTC 库无关 基础知识 ArrayBuffer ArrayBuffer 对象表示通用的、固定长度的二进制数据缓冲区。因此，你可以直接使用它存储图片、视频等内容。但并不能直接访问。 ArrayBuffer 只是描述有这样一块空间可以用来存放二进制数据，但在计算机的内存中并没有真正地为其分配空间。只有当具体类型化后，它才真正地存在于内存中。 ArrayBufferView ArrayBufferView 指的是 Int8Array、Uint8Array、DataView 等类型的总称，而这些类型都是使用 ArrayBuffer 类实现的 ArrayBufferView 并不是一个具体的类型，而是代表不同类型的 Array 的描述。这些类型包括：Int8Array、Uint8Array、DataView 等。也就是说 Int8Array、Uint8Array 等才是 JavaScript 在内存中真正可以分配的对象。 以 Int8Array 为例，当你对其实例化时，计算机就会在内存中为其分配一块空间，在该空间中的每一个元素都是 8 位的整数。再以 Uint8Array 为例，它表达的是在内存中分配一块每个元素大小为 8 位的无符号整数的空间。 相同位数的有符号位比无符号位能表示的数减半 【最高位要用 来表示符号】 Blob 由 ArrayBuffer 对象的封装类实现的，即 Int8Array、Uint8Array 等类型 12var aBlob = new Blob(array, options)// array 可以是ArrayBuffer、ArrayBufferView、Blob、DOMString等类型 ；option，用于指定存储成的媒体类型。 WebRTC 录制音视频流之后，最终是通过 Blob 对象将数据保存成多媒体文件的 录制本地音视频 MediaRecorder MDN var mediaRecorder = new MediaRecorder(stream[, options]); stream，通过 getUserMedia 获取的本地视频流或通过 RTCPeerConnection 获取的远程视频流。 options，可选项，指定视频格式、编解码器、码率等相关信息，如 mimeType: ‘video/webm;codecs=vp8’。 MediaRecorder 对象还有一个特别重要的事件，即 ondataavailable 事件。当 MediaRecoder 捕获到数据时就会触发该事件。通过它，我们才能将音视频数据录制下来 步骤 判断兼容性 MediaRecorder.isTypeSupported(&#123;mimeType: 'video/webm;codecs=vp8'&#125;) 使用 new MediaRecorder(stream, options) 添加 MediaRecorder.ondataavailable = function(e)&#123;&#125;事件监听,在事件监听中 存储 录制数据buffer.push(e.data); 开始录制mediaRecorder.start(timeslice);,通过给 timeslice 参数设置一个毫秒值,如果设置这个毫秒值,那么录制的媒体会按照你设置的值进行分割成一个个单独的区块, 而不是以默认的方式录制一个非常大的整块内容.【这是 timeslice 可以有效避免 错误发生几率】 播放和下载 ,都需要 借助new Blob(buffer, &#123;type: 'video/webm'&#125;);和window.URL.createObjectURL(blob)获取地址，进行播放下载 于大多数采用客户端录制方案的公司，在录制时一般不是录制音视频数据，而是录制桌面加音频，这样就大大简化了客户端实现录制的复杂度了。我想你也一定知道这是为什么，没错就是因为在桌面上有其他参与人的视频，所以只要将桌面录制下来，所有的视频就一同被录制下来了","categories":[{"name":"技术帖","slug":"技术帖","permalink":"http://mcdowell8023.github.io/categories/%E6%8A%80%E6%9C%AF%E5%B8%96/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://mcdowell8023.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"直播","slug":"直播","permalink":"http://mcdowell8023.github.io/tags/%E7%9B%B4%E6%92%AD/"},{"name":"webrtc","slug":"webrtc","permalink":"http://mcdowell8023.github.io/tags/webrtc/"}]},{"title":"webrtc-采集基础知识","slug":"rtc/webrtc/note3","date":"2021-07-18T02:22:34.000Z","updated":"2025-03-08T09:52:37.770Z","comments":true,"path":"2021/07/18/rtc/webrtc/note3/","permalink":"http://mcdowell8023.github.io/2021/07/18/rtc/webrtc/note3/","excerpt":"","text":"音视频采集 基础知识 摘自 李超 - 从 0 打造音视频直播系统 非编码帧 好多人小时候应该都学过，在几张空白的纸上画同一个物体，并让物体之间稍有一些变化，然后连续快速地翻动这几张纸，它就形成了一个小动画。音视频播放器就是利用这样的原理来播放音视频文件的。 当你要播放某个视频文件时，播放器会按照一定的时间间隔连续地播放从 音视频文件中解码后的视频帧，这样视频就动起来了。同理，播放从 摄像头获取的视频帧 也是如此，只不过从 ==摄像头获取的是非编码视频帧，不需要解码。== 通过上面的描述，你应该能得到以下两点信息： 播放的视频帧之间的时间间隔是非常小的。如按每秒钟 20 帧的帧率计算，每帧之间的间隔是 50ms（1000ms/20）。 播放器播的是非编码帧（解码后的帧），这些非编码帧就是一幅幅独立的图像。 摄像头里采集的帧 或 通过解码器解码后的帧 都是非编码帧。非编码帧的格式一般是 YUV 格式或是 RGB 格式。 编码帧 通过编码器（如 H264/H265、VP8/VP9）压缩后的帧称为编码帧。 以 H264 为例，经过 H264 编码的帧包括以下三种类型。 I 帧：关键帧。压缩率低，可以单独解码成一幅完整的图像。 P 帧：参考帧。压缩率较高，解码时依赖于前面已解码的数据。 P帧需要参考其前面的一个I帧或者P帧来解码成一张完整的视频画面。 B 帧：前后参考帧。压缩率最高，解码时不光依赖前面已经解码的帧，而且还依赖它后面的 P 帧。换句话说就是，B 帧后面的 P 帧要优先于它进行解码，然后才能将 B 帧解码。 B帧则需要参考其前一个I帧或者P帧及其后面的一个P帧来生成一张完整的视频画面，所以P帧与B帧去掉的是视频帧在时间维度上的冗余信息 从播放器里获取的视频帧一定是非编码帧。也就是说，拍照的过程其实是从连续播放的一幅幅画面中抽取正在显示的那张画面 借助 canvas 进行拍照 借助 cancas drawImage 绘制 video 中的视频流 : picture.getContext('2d').drawImage(video, 0, 0, picture.width, picture.height); image：可以是一幅图片，或 HTMLVideoElement。 dx, dy：图片起点的 x、y 坐标。 dWidth：图片的宽度。 dHeight：图片的高度 通过 Canvas 的 toDataURL 方法获得图片的 URL 地址:picture.toDataURL(&quot;image/jpeg&quot;),在使用 a 标签等 进行下载","categories":[{"name":"技术帖","slug":"技术帖","permalink":"http://mcdowell8023.github.io/categories/%E6%8A%80%E6%9C%AF%E5%B8%96/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://mcdowell8023.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"直播","slug":"直播","permalink":"http://mcdowell8023.github.io/tags/%E7%9B%B4%E6%92%AD/"},{"name":"webrtc","slug":"webrtc","permalink":"http://mcdowell8023.github.io/tags/webrtc/"}]},{"title":"webrtc-获取音视频设备","slug":"rtc/webrtc/note2","date":"2021-07-15T02:42:45.000Z","updated":"2025-03-08T09:51:12.469Z","comments":true,"path":"2021/07/15/rtc/webrtc/note2/","permalink":"http://mcdowell8023.github.io/2021/07/15/rtc/webrtc/note2/","excerpt":"","text":"获取音视频设备 在第一章，说过 webrtc 通信前，要进行设备检测，才可以采集、录制 音视频设备的基本原理 摘自 李超 - 从 0 打造音视频直播系统 音频设备 音频有采样率和采样大小的概念，实际上这两个概念就与音频设备密不可分。 音频输入设备的主要工作是采集音频数据，而采集音频数据的本质就是模数转换（A/D），即将模似信号转换成数字信号。 模数转换使用的采集定理称为奈奎斯特定理，其内容如下： 在进行模拟 / 数字信号的转换过程中，当采样率大于信号中最高频率的 2 倍时，采样之后的数字信号就完整地保留了原始信号中的信息。 人类听觉范围的频率是 20Hz ～ 20kHz 之间。对于日常语音交流（像电话），8kHz 采样率就可以满足人们的需求。但为了追求高品质、高保真，你需要将音频输入设备的采样率设置在 40kHz 以上，这样才能完整地将原始信号保留下来。例如我们平时听的数字音乐，一般其采样率都是 44.1k、48k 等，以确保其音质的无损。 采集到的数据再经过量化、编码，最终形成数字信号，这就是音频设备所要完成的工作。在量化和编码的过程中，采样大小（保存每个采样的二进制位个数）决定了每个采样最大可以表示的范围。如果采样大小是 8 位，则它表示的最大值是就是 2^8 -1，即 255；如果是 16 位，则其表示的最大数值是 65535。 视频设备 至于视频设备，则与音频输入设备很类似。当实物光通过镜头进行到摄像机后，它会通过视频设备的模数转换（A/D）模块，即光学传感器， 将光转换成数字信号，即 RGB（Red、Green、Blue）数据。 获得 RGB 数据后，还要通过 DSP（Digital Signal Processer）进行优化处理，如自动增强、白平衡、色彩饱和等都属于这一阶段要做的事情。 通过 DSP 优化处理后，你就得到了 24 位的真彩色图片。因为每一种颜色由 8 位组成，而一个像素由 RGB 三种颜色构成，所以一个像素就需要用 24 位表示，故称之为 24 位真彩色。 另外，此时获得的 RGB 图像只是临时数据。因最终的图像数据还要进行压缩、传输，而编码器一般使用的输入格式为 YUV I420，所以在摄像头内部还有一个专门的模块用于将 RGB 图像转为 YUV 格式的图像。 那什么是 YUV 呢？YUV 也是一种色彩编码方法，主要用于电视系统以及模拟视频领域。它将亮度信息（Y）与色彩信息（UV）分离，即使没有 UV 信息一样可以显示完整的图像，只不过是黑白的，这样的设计很好地解决了彩色电视机与黑白电视的兼容问题。 通过上面的讲解，现在你应该对音频设备与视频设备都有一个基本的认知了。 获取媒体设备 MediaDevices.enumerateDevices 请求一个可用的媒体输入和输出设备的列表，例如麦克风，摄像机，耳机设备等。 返回的 Promise 完成时，会带有一个描述设备的 MediaDeviceInfo 的数组。 MediaDevices.enumerateDevices MDN 示例 1234567891011121314151617181920// 兼容 判断是否支持if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) &#123; console.log(&#x27;不支持 enumerateDevices() .&#x27;) return&#125;// 列出相机和麦克风。navigator.mediaDevices .enumerateDevices() .then(function (MediaDeviceInfos) &#123; MediaDeviceInfos.forEach(function (device) &#123; console.log( device.kind + &#x27;: &#x27; + device.label + &#x27; id = &#x27; + device.deviceId ) &#125;) &#125;) .catch(function (err) &#123; console.log(err.name + &#x27;: &#x27; + err.message) &#125;) MediaDeviceInfo 它表示的是每个输入 / 输出设备的信息。包含以下三个重要的属性： deviceID，设备的唯一标识； label，设备名称； kind，设备种类，可用于识别出是音频设备还是视频设备，是输入设备还是输出设备。 出于安全原因，除非用户已被授予访问媒体设备的权限（要想授予权限需要使用 HTTPS 请求），否则 label 字段始终为空。 label 可以用作指纹识别机制的一部分，以识别是否是合法用户 InputDeviceInfo MediaDeviceInfo 表是所有设备信息， InputDeviceInfo 表式输入设备信息， MediaDeviceInfo 包含 InputDeviceInfo。 设备检测 通过 MediaDeviceInfo 结构中的 kind 字段，将设备分类为音频设备或视频设备。 通过 kind 字段再将音视设备分为输入设备和输出设备 对于区分出的音频设备和视频设备，每种不同种类的设备还会设置各自的默认设备。 不指定某个具体设备 直接使用 MediaDevices.getUserMedia API 来采集音视频数据时，它就会从设备列表中的默认设备上采集数据。 设备检测思路 如果我们能从指定的设备上采集到音视频数据，那说明这个设备就是有效的设备。 所以，对每个设备都一项一项进行检测，即先排查视频设备，然后再排查音频设备。因此，需要调用两次 MediaDevices.getUserMedia API 进行设备检测。 第一次，调用 getUserMedia API 只采集视频数据并将其展示出来。如果用户能看到自己的视频，说明视频设备是有效的；否则，设备无效，可以再次选择不同的视频设备进行重新检测。 第二次，如果用户视频检测通过了，再次调用 getUserMedia API 时，则只采集音频数据。由于音频数据不能直接展示，所以需要使用 JavaScript 中的 AudioContext 对象，将采集到的音频计算后，再将其绘制到页面上。这样，当用户看到音频数值的变化后，说明音频设备也是有效的。 关于设备检测 我做了个实验，找一个损坏的麦克风，插入电脑，发现仍然可以 通过 mediaDevices.enumerateDevices 枚举得到这个麦克风，","categories":[{"name":"技术帖","slug":"技术帖","permalink":"http://mcdowell8023.github.io/categories/%E6%8A%80%E6%9C%AF%E5%B8%96/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://mcdowell8023.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"直播","slug":"直播","permalink":"http://mcdowell8023.github.io/tags/%E7%9B%B4%E6%92%AD/"},{"name":"webrtc","slug":"webrtc","permalink":"http://mcdowell8023.github.io/tags/webrtc/"}]},{"title":"webrtc-实现过程基本概况","slug":"rtc/webrtc/note1","date":"2021-07-10T08:29:33.000Z","updated":"2025-03-08T15:19:42.665Z","comments":true,"path":"2021/07/10/rtc/webrtc/note1/","permalink":"http://mcdowell8023.github.io/2021/07/10/rtc/webrtc/note1/","excerpt":"","text":"webretc 实现过程基本概况 webretc1 对 1 音视频实时通话 这幅图从大的方面可以分为 4 部分: 两个 WebRTC 终端（上图中的两个大方框） WebRTC 终端，负责音视频采集、编解码、NAT 穿越、音视频数据传输 一个 Signal（信令）服务器 Signal 服务器，负责信令处理，如加入房间、离开房间、媒体协商消息的传递等 一个 STUN/TURN 服务器 STUN/TURN 服务器，负责获取 WebRTC 终端在公网的 IP 地址，以及 NAT 穿越失败后的数据中转 WebRTC 介绍及简单应用 WebRTC 进行音视频通话的大体过程 WebRTC 终端 A 进入房间之前，它首先会检测自己的设备是否可用。如果此时设备可用，则进行音视频数据采集 采集到的数据一方面可以做预览，也就是让自己可以看到自己的视频；另一方面，可以将其录制下来保存成文件，等到视频通话结束后，上传到服务器让用户回看之前的内容 在获取音视频数据就绪后，WebRTC 终端 A 要发送 “加入” 信令到 Signal 服务器。 Signal 服务器收到该消息后会创建房间。在另外一端 WebRTC 终端 B，也要做同样的事情，只不过它不是创建房间，而是加入房间了。待 WebRTC 终端 B 成功加入房间后，第一个用户会收到 “另一个用户已经加入成功” 的消息。 此时，WebRTC 终端 A 将创建 “媒体连接” 对象（RTCPeerConnection），并将采集到的音视频数据通过 RTCPeerConnection 对象进行编码，最终通过 P2P 传送给对端 WebRTC 终端 B 当然，在进行 P2P 穿越时很有可能失败。所以，当 P2P 穿越失败时，为了保障音视频数据仍然可以互通，则需要通过 TURN 服务器 进行音视频数据中转 当 音视频数据 “历尽千辛万苦” 来到对端后，对端首先 将收到的音视频数据进行解码，最后再将其展示出来，这样就完成了一端到另一端的单通。 如果双方要互通，那么，两方都要通过 RTCPeerConnection 对象传输自己一端的数据，并从另一端接收数据。 以上，就是这幅图大体所描述的含义。 音视频采集 基本概念 摄像头 ~~ 帧率： 摄像头一秒钟采集图像的次数称为帧率【帧率越高，视频就越平滑流畅。然而，在直播系统中一般不会设置太高的帧率，因为帧率越高，占的网络带宽就越多。】 分辨率： 摄像头除了可以设置帧率之外，还可以调整分辨率。如 2K、1080pp、720p 等等。分辨率越高图像就越清晰，但同时也带来一个问题，即占用的带宽也就越多 【通常 分辨率会跟据你的网络带宽进行动态调整 】 宽高比 分辨率一般分为两种宽高比，即 16:9 或 4:3【4:3 是从黑白电视来的，现在通常是 16:9】 麦克风： 用于采集音频数据。可以指定一秒内采样的次数，称为采样率。每个采样用几个 bit 表示，称为采样位深或采样大小。 轨（Track）： 借鉴了多媒体的概念，在多媒体中表达的就是每条轨数据都是独立的，不会与其他轨相交。【像火车轨一样，用不相交】如 MP4 中的音频轨、视频轨，它们在 MP4 文件中是被分别存储的。 流（Stream）： 可以理解为容器。在 WebRTC 中，“流”可以分为媒体流（MediaStream）和数据流（DataStream）。 媒体流可以存放 0 个或多个音频轨或视频轨； 数据流可以存 0 个或多个数据轨。 音视频采集 navigator.mediaDevices.getUserMedia 在用户通过提示允许的情况下，打开系统上的相机或屏幕共享和/或麦克风，并提供 MediaStream 包含视频轨道和/或音频轨道的输入。 MediaDevices MDN 返回一个 promise 对象【对没错使用 .then().catch()】 1234567891011121314const mediaStreamContrains = &#123; video: true, audio: true,&#125;navigator.mediaDevices .getUserMedia(mediaStreamContrains) .then((mediaStream) =&gt; &#123; // mediaStream 即时返回的 媒体流 通常喂给 video.srcObject // do something &#125;) .catch((error) =&gt; &#123; console.log(&#x27;navigator.getUserMedia error: &#x27;, error) &#125;)// mediaStreamContraints 用于 约束 navigator.mediaDevices.getUserMedia() 返回的 MediaStream 的参数 主要接收两个参数 {video: true, audio: true} # video、audio 不写默认 都是 false 你就拿不到音频轨、视频轨 mediastreamconstraints w3c 当然 video、audio 属性可以接收具体 参数,例如： 12345678910111213const mediaStreamContrains = &#123; video: &#123; frameRate: &#123; min: 20 &#125;, // 帧率最小 20 帧每秒 根据不同硬件， 参数过大可能导致 错误 width: &#123; min: 640, ideal: 1280 &#125;, // 宽度最小是 640，理想的宽度是 1280 height: &#123; min: 360, ideal: 720 &#125;, // 高度最小是 360，最理想高度是 720 aspectRatio: 16 / 9, // 宽高比是 16:9 &#125;, audio: &#123; echoCancellation: true, //回声消除 noiseSuppression: true, // 噪音抑制 autoGainControl: true, //自动控制 &#125;,&#125; 详细参数： 参数 含义 备注 width 视频宽度 height 视频高度 aspectRatio 视频宽高比 frameRate 帧率 facingMode user:前置摄像头；enviroment:后置摄像头 ；left:前置左侧摄像头；right:前置右侧摄像头 enum VideoFaciongModeEnum{user,enviroment,left,right} resizeMode 是否允许调整图像大小 volume 音量大小 sampleRate 音频采样率 sampleSize 音频采样率大小 echoCancellation 是否开启回音消除 autoGainControl 是否开启自动增益 noiseSuppression 是否开启降噪 latency 延迟大小 channalCount 声道数 deviceID 设备 ID 指定哪个输入/输出设备 groupID 设置组 ID 如果两个设备属于同一物理设备，则他们具有相同的 groupID。比如有麦克风功能的手机 MediaStream 关于返回值 MediaStream 是一个媒体内容的流。一个流包含几个轨道，比如视频和音频轨道。 MediaStream MDN srcObject: 是 HTMLMediaElement 元素（这里主要是 video） 用于接收 file blob MediaStream 的属性 或者给出一个 mediaStream 返回值 关于一些说明： rtmp 的直播解决方案和 webRTC 之间优劣势在什么地方？ Rtmp 底层用的 tcp,webrtc 底层主要使用 udp,使用 tcp 就注定他在极端网络情况下没法实时通信 NAT 穿越是啥？ P2P，端与端直接进行连接，不需要服务器中转数据，这样可以节省服务器带宽，但并不意味着不需要服务器，服务器作为辅助功能 navigator.mediaDevices 报错不存在【错误信息：navigator.getUserMedia is not a function】 出于安全的原因，你只能用 localhost 访问或 https 访问时才能检测到 mediaDevice","categories":[{"name":"技术帖","slug":"技术帖","permalink":"http://mcdowell8023.github.io/categories/%E6%8A%80%E6%9C%AF%E5%B8%96/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://mcdowell8023.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"直播","slug":"直播","permalink":"http://mcdowell8023.github.io/tags/%E7%9B%B4%E6%92%AD/"},{"name":"webrtc","slug":"webrtc","permalink":"http://mcdowell8023.github.io/tags/webrtc/"}]},{"title":"webrtc-前置知识","slug":"rtc/webrtc/note0","date":"2021-07-03T11:49:17.000Z","updated":"2025-03-08T09:56:22.312Z","comments":true,"path":"2021/07/03/rtc/webrtc/note0/","permalink":"http://mcdowell8023.github.io/2021/07/03/rtc/webrtc/note0/","excerpt":"","text":"音视频 基础知识 首先 做 webrtc 网页即时通信 开发，其实就是开始了音视频开发。必须知道和理解视频相关术语和参数，及其相关的原理和作用。 所以，我们从头说。 音频 声音的物理特征 声音是由物体振动而产生的 声波的三要素 声波的三要素是频率(代表音阶的高低)、振幅(代表响度)和波形(代表音色)。 人类耳朵的听力有一个频率范围，大约是 20Hz~20kHz，不过，即 使是在这个频率范围内，不同的频率，听力的感觉也会不一样。 人耳对 3~4kHz 频率范围内的声音比较敏感， 而对于较低或较高频率的声音，敏感度就会有所减弱; 在声压级较低 时，听觉的频率特性会很不均匀; 而在声压级较高时，听觉的频率特性 会变得较为均匀。 频率范围较宽的音乐，其声压以 80~90dB 为最佳，超 过 90dB 将会损害人耳(105dB 为人耳极限) 声音的传播介质 声音的传播介质 需要介质，它可以通过空气、液体和固体进行传播;而且介质不同，传播的 速度也不同，比如，声音在空气中的传播速度为 340m/s，在蒸馏水中的 传播速度为 1497m/s，而在铁棒中的传播速度则可以高达 5200m/s;不 过，声音在真空中是无法传播的。 回声 当我们在高山或空旷地带高声大喊的时候，经常会听到回声 (echo)。之所以会有回声是因为声音在传播过程中遇到障碍物会反弹 回来。 但是，若两种声音传到我们的耳朵里的时差小于 80 毫秒，我们就无 法区分开这两种声音了，其实在日常生活中，人耳也在收集回声，只不 过由于嘈杂的外界环境以及回声的分贝(衡量声音能量值大小的单位) 比较低，所以我们的耳朵分辨不出这样的声音，或者说是大脑能接收到 但分辨不出。 共鸣 两个频率相同的物体，敲击其中一个物体时另一个物体 也会振动发声，这种现象称为共鸣，共鸣证明了声音传播可以带动另一个物体振 动，也就是说，声音的传播过程也是一种能量的传播过程 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 数字音频 麦克风是如何采集声音的 麦克风里面有一层碳膜，非常薄而且十分敏感。 声音其实是一种纵波，会压缩空气也会压缩这层碳膜，碳膜在受到挤压 时也会发出振动，在碳膜的下方就是一个电极，碳膜在振动的时候会接 触电极，接触时间的长短和频率与声波的振动幅度和频率有关，这样就 完成了声音信号到电信号的转换。之后再经过放大电路处理，就可以实施后面的采样量化处理了。 为了将模拟信号数字化 分别要对模拟信号进行 采样、量化和编码。 采样 采样就是 在时间轴上对信号进行数字化。 根据奈奎斯特定理(也称为采样定 理)，按比声音最高频率高 2 倍以上的频率对声音进行采样(也称为 AD 转换)， 对于高质量的音频信号，其频率范围(人耳 能够听到的频率范围)是 20Hz~20kHz，所以采样频率一般为 44.1kHz，这样就可以保证采样声音达到 20kHz 也能被数字化，从而使得 经过数字化处理之后，人耳听到的声音质量不会被降低。 而所谓的 44.1kHz 就是代表 1 秒会采样 44100 次。 量化 量化是指在幅度轴上对信号进行数字化，比如用 16 比特（16 个二进制位） 的二进制信号来表示声音的一个采样，而 16 比特(一个 short)所表示的 范围是[-32768，32767]，共有 65536 个可能取值，因此最终模拟的音频 信号在幅度上也分为了 65536 层 编码 所谓编码，就是按照一定的格式记录采样和量化后的数字数据，比如顺序存储或压缩存储，等等。 PCM PCM(Pulse Code Modulation，脉冲编码调制) 音频数据是未经压缩的音频采样数据裸流，它是由模拟信号经过采样、量化、编码转换成的标准数字音频数据。 通常所说的音频的裸数据格式就是脉冲 编码调制(Pulse Code Modulation，PCM)数据。描述一段 PCM 数据一 般需要以下几个概念:量化格式(sampleFormat)、采样率 (sampleRate)、声道数(channel)。 以 CD 的音质为例: 量化格式为 16-bit(2 字节)，采样率(Sample Rate)为 44100，声道数为 2，这些信息就描述了 CD 的音质。 而对于声音格式，还有一个概念用来 描述它的大小，称为数据比特率(即 1 秒时间内的比特数目，用于衡 量音频数据单位时间内的容量大小) 对于 CD 音质的数据，比特率为：44100 * 16 * 2 = 1378.125kbps 1 分钟里，这类 CD 音质的数据需要占据多大的存储需要 1378.125 * 60 / 8（8位是1字节得到KB） / 1024(KB换算MB) = 10.09MB 如果 量化格式(sampleFormat) 更加精确【比如用 4 字节(32-bit)来描述一个采样】，或者 采样率（sampleRate） 更加密集(比如 48kHz 的采样率)，那么所占的 存储空间就会更大，同时能够描述的声音细节就会越精确。 存储的这段二进制数据即表示将模拟信号转换为数字信号了，以后就可以对这段二进制数据进行存储、播放、复制，或者进行其他任何操作。 PCM 是软件层接收到最原始的音频格式数据。浏览器支持 audio api 直接播放 PCM 分贝 分贝是用来表示声音强度的单位。日常生活中听到的声音，若以声压值来表示，由于其变化范围非 常大，可以达到六个数量级以上，同时由于我们的耳朵对声音信号强弱 刺激的反应不是线性的，而是呈对数比例 关系，所以引入分贝的概念来表达声学量值。所谓分贝是指两个相同的 物理量(例如，A1 和 A0)之比取以 10 为底的对数并乘以 10(或 20)， 即: 音频编码 上文中，提到了 CD 音质的数据采样格式，曾计算出每分钟需要的存 储空间约为 10.1MB，如果仅仅是将其存放在存储设备(光盘、硬盘) 中，可能是可以接受的，但是若要在网络中实时在线传播的话，那么这 个数据量可能就太大了，所以必须对其进行压缩编码。 压缩编码 压缩编码的基本指标之一就是压缩比，压缩比通常小于 1(否则就没有必要去做压缩， 因为压缩就是要减小数据容量) 压缩算法: 无损压缩：无损压缩是指解压后的数据可以完全复原。 有损压缩：指解压后的数据不能完全复原，会丢失一部分信息； 用得较多； 压缩比越小，丢失的信息就越多，信号还原后的失真就会 越大； 根据不同的应用场景(包括存储设备、传输网络环境、播放设备 等)，可以选用不同的压缩编码算法，如 PCM、WAV、AAC、MP3、 Ogg 等 压缩编码的原理实际上是压缩掉冗余信号，冗余信号是指不能被人 耳感知到的信号，包含人耳听觉范围之外的音频信号以及被掩蔽掉的音频信号等。而被掩蔽掉的音频信号则主要是因为人耳的掩蔽效应， 主要表现为频域掩蔽效应与时域掩蔽效应，无论是在时域还是频域上， 被掩蔽掉的声音信号都被认为是冗余信息，不进行编码处理。 几种常用的压缩编码格式 WAV 编码 WAV 编码的一种实现(有多种实现方式，但是都不会进行压缩操作)就是在 PCM 数据格式的前面加上 44 字 节 用来描述 PCM 的采样率、声道数、数据格式等信息 特点: 音质非常好，大量软件都支持 适用场合: 多媒体开发的中间文件、保存音乐和音效素材 MP3 编码 MP3 具有不错的压缩比 使用 LAME 编码(MP3 编码格式的一种实 现)的中高码率的 MP3 文件，听感上非常接近源 WAV 文件(在不同的应用场景下，应该调整合适的参数以达到最好的效果) 特点: 音质在 128Kbit/s 以上表现还不错，压缩比比较高，大量软件和硬件都支持，兼容性好。 适用场合: 高比特率下对兼容性有要求的音乐欣赏。 AAC 编码 AAC 是新一代的音频有损压缩技术， LC-AAC、HE-AAC、HE-AAC v2 三种 主要的编码格式。 LC-AAC 是比较传统的 AAC，相对而言，其主要应用 于中高码率场景的编码(≥80Kbit/s); HE-AAC (相当于 AAC+SBR) 主要应用于中低码率场景的编码(≤80Kbit/s); HE-AAC v2 (相当于 AAC+SBR+PS)主要应用于低码率场景的编码 (≤48Kbit/s)。 事实上大部分编码器都设置为 ≤48Kbit/s 自动启用 PS 技 术，而&gt;48Kbit/s 则不加 PS，相当于普通的 HE-AAC。 特点: 在小于 128Kbit/s 的码率下表现优异，并且多用于视频中的音频编码。 适用场合: 128Kbit/s 以下的音频编码，多用于视频中音频轨的编码。 Ogg 编码 Ogg 是一种非常有潜力的编码， 在各种码率下都有比较优秀的表现，尤其是在中低码率场景下。 音质好、完全免费、出色的算法（更小的码率达到更好的音质） 128Kbit/s 的 Ogg 比 192Kbit/s 甚至更 高码率的 MP3 还要出色 兼容性差：受支持的情况还不够好，无 论是软件上的还是硬件上的支持，都无法和 MP3 相提并论。 特点: 可以用比 MP3 小的码率实现比 MP3 更好的音质，高中低码率下均有良好的表现，流媒体特性不支持。 适用场合:语音聊天的音频消息场景。 图像 图像的物理现象 视频是由一幅幅图像组成的，所以要学习视频还得从图像说起 光的本质：红绿蓝三种色光无法被分解，故称为三原色光，等量的三原色光相加会变为白光，即白光中含有等量的红光（R）、绿光（G）、蓝光（B），不同等量的三色光，组成不同的颜色。 在日常生活中，由于光的反射，我们才能看到各类物体的轮廓及颜色。你看到红色物体是因为 反射的红光，吸收了其他颜色的光，所以你看到的是红色；你看到蓝色物体是因为 反射的蓝光，吸收了其他颜色的光，所以你看到的是蓝色。 当然，并不都是反射光的。还有自发光的，如太阳、电灯还有我们要说的 显示屏。 显示屏的显示 假设一部手机屏幕的分辨率是 1280×720，说明水平方向有 720 个像素点，垂直方向有 1280 个像素点，所以整个手机屏幕就有 1280×720 个像素点（这也是分辨率的含义）。 每个像素点都由**三个子像素（红 R 绿 G 蓝 B）**点组成。【通俗点说它的颜色混合方式就好像有红、绿、蓝三盏灯，当它们的光相互叠合的时候，色彩相混，而亮度却等于三者亮度之总和，越混合亮度越高，即加法混合】 液晶屏幕的显示原理 图像的数值表示 RGB 表示方式 浮点表示：取值范围为 0.0 ～ 1.0，比如，在 OpenGL ES 中对每一个子像素点的表示使用的就是这种表达方式。 整数表示：取值范围为0 ～ 255或者00 ～ FF，8 个比特表示一个子像素，32 个比特（除了 RGB 三色外，还有 alpha 透明度;也就是 4*8）表示一个像素，这就是类似于某些平台上表示图像格式的 RGBA_8888 数据格式。 对于一幅图像，一般使用整数表示方法来进行描述， 比如计算一张 1280×720 的 RGBA_8888 图像的大小，可采用如下方式：1280 * 720 * 4 = 3.516MB 这也是位图（bitmap）在内存中所占用的大小，所以每一张图像的裸数据都是很大的。 对于图像的裸数据来讲，直接在网络上进行传输也是不太可能的，所以就有了图像的压缩格式， 比如 JPEG 压缩：JPEG 是静态图像压缩标准，由 ISO 制定。 JPEG 图像压缩算法在提供良好的压缩性能的同时，具有较好的重建质量。 这种算法被广泛应用于图像处理领域，当然其也是一种有损压缩。 在很多网站如淘宝上使用的都是这种压缩之后的图片，但是，这种压缩不能直接应用于视频压缩，因为对于视频来讲，还有一个时域上的因素需要考虑，也就是说，不仅仅要考虑帧内编码，还要考虑帧间编码。视频采用的是更成熟的算法。 YUV 表示方式 推荐-Digital video concepts YUV 也是一种色彩编码方法，主要用于电视系统以及模拟视频领域。它将亮度信息（Y）与色彩信息（UV）分离，即使没有 UV 信息一样可以显示完整的图像，只不过是黑白的，这样的设计很好地解决了彩色电视机与黑白电视的兼容问题。 与 RGB 视频信号传输相比，它最大的优点在于只需要占用极少的频宽（RGB 要求三个独立的视频信号同时传输）。其中“Y”表示明亮度（Luminance 或 Luma），也称灰阶值；而“U”和“V”表示的则是色度（Chrominance 或 Chroma），它们的作用是描述影像的色彩及饱和度，用于指定像素的颜色。 “亮度”是透过 RGB 输入信号来建立的，方法是将 RGB 信号的特定部分叠加到一起。“色度”则定义了颜色的两个方面——色调与饱和度，分别用 Cr 和 Cb 来表示。其中，Cr 反映了 RGB 输入信号红色部分与 RGB 信号亮度值之间的差异，而 Cb 反映的则是 RGB 输入信号蓝色部分与 RGB 信号亮度值之间的差异。 视频编码 音频压缩主要是去除冗余信息，从而实现数据量的压缩。其实视频压缩也是通过去除冗余信息来进行压缩的。 相较于音频数据，视频数据有极强的相关性，也就是说有大量的冗余信息，包括空间上的冗余信息和时间上的冗余信息。使用帧间编码技术可以去除时间上的冗余信息，具体包括以下几个部分。 运动补偿：运动补偿是通过先前的局部图像来预测、补偿当前的局部图像，它是减少帧序列冗余信息的有效方法。 运动表示：不同区域的图像需要使用不同的运动矢量来描述运动信息。 运动估计：运动估计是从视频序列中抽取运动信息的一整套技术。使用帧内编码技术可以去除空间上的冗余信息。 ISO 视频压缩标准（Motion JPEG 即 MPEG）： Mpeg1（用于 VCD） Mpeg2（用于 DVD） Mpeg4 AVC（现在流媒体使用最多的就是它了） ITU-视频压缩标准 H.261 H.262 H.263 H.264 （集中了以往标准的所有优点，并吸取了以往标准的经验） 现在使用最多的就是 H.264 标准，H.264 创造了多参考帧、多块类型、整数变换、帧内预测等新的压缩技术，使用了更精细的分像素运动矢量（1/4、1/8）和新一代的环路滤波器，这使得压缩性能得到大大提高，系统也变得更加完善 编码概念 IPB 帧 视频压缩中，每帧都代表着一幅静止的图像。而在进行实际压缩时，会采取各种算法以减少数据的容量，其中 IPB 帧就是最常见的一种。 I 帧：关键帧。压缩率低，可以单独解码成一幅完整的图像。 P 帧：参考帧。压缩率较高，解码时依赖于前面已解码的数据。 P 帧需要参考其前面的一个 I 帧或者 P 帧来解码成一张完整的视频画面。 B 帧：前后参考帧。压缩率最高，解码时不光依赖前面已经解码的帧，而且还依赖它后面的 P 帧。换句话说就是，B 帧后面的 P 帧要优先于它进行解码，然后才能将 B 帧解码。 B 帧则需要参考其前一个I 帧或者 P 帧及其后面的一个P 帧来生成一张完整的视频画面，所以P 帧与 B 帧去掉的是视频帧在时间维度上的冗余信息 H.264 的 IDR 帧与 I 帧的理解 IDR 帧（instantaneous decoding refreshpicture） IDR 帧与 I 帧的区别 IDR 帧就是一种特殊的 I 帧，即这一帧之后的所有参考帧只会参考到这个 IDR 帧，而不会再参考前面的帧。在解码器中，一旦收到一个 IDR 帧，就会立即清理参考帧缓冲区，并将 IDR 帧作为被参考的帧。 因为 H.264 采用了多帧预测，所以 I 帧 之后的 P 帧有可能会参考 I 帧之前的帧，这就使得在随机访问的时候不能以找到 I 帧作为参考条件，因为即使找到 I 帧，I 帧之后的帧还是有可能解析不出来 I 帧、P 帧、B 帧 的说明(编码器工作)： 帧率 25fps( 指每秒 25 个 P 帧或 B 帧) 视频画面变化不大情况下， 每间隔 25 个参考帧 出 一个 I 帧 视频画面变化较大（如：电影场景切换）时，会立马 出一个 I 帧,用于更换视频场景及后面的参考帧处理解码 GOP 的概念 两个 I 帧之间形成的一组图片，就是 GOP（Group Of Picture）的概念。通常在为编码器设置参数的时候，必须要设置 gop_size 的值，其代表的是两个 I 帧之间的帧数目。 前面已经讲解过，一个 GOP 中容量最大的帧就是 I 帧，所以相对来讲，（这也是前面提到的 I 帧可以作为随机访问的帧）。 在提高视频质量的技巧中 gop_size 设置得越大，整个画面的质量就会越好 (解码端必须从接收到的第一个 I 帧开始才可以正确解码出原始图像，否则会无法正确解码) 多使用 B 帧，使用 B 帧能节省大量空间，节省出来的空间可以用来更多地保存 I 帧，( I 的压缩率是 7（与 JPG 差不多），P 是 20，B 可以达到 50)， 在相同的码率下提供更好的画质。 根据不同的业务场景，适当地设置 gop_size 的大小，以得到更高质量的视频 编解码顺序： DTS（Decoding Time Stamp 解码时间戳） PTS（Presentation TimeStamp 视频显示时间戳） 在没有 B 帧的情况下，DTS 和 PTS 的输出顺序是一样的 在大多数编解码标准（如 H.264 或 HEVC）中，编码顺序和输入顺序并不一致，于是才会需要 PTS 和 DTS 这两种不同的时间戳 视频播放器 视音频编解码技术零基础学习方法 播放一个互联网上的视频文件 解协议 解封装 解码视音频 视音频同步 播放本地文件则不需要解协议 解封装 解码视音频 视音频同步","categories":[{"name":"技术帖","slug":"技术帖","permalink":"http://mcdowell8023.github.io/categories/%E6%8A%80%E6%9C%AF%E5%B8%96/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://mcdowell8023.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"直播","slug":"直播","permalink":"http://mcdowell8023.github.io/tags/%E7%9B%B4%E6%92%AD/"},{"name":"webrtc","slug":"webrtc","permalink":"http://mcdowell8023.github.io/tags/webrtc/"}]},{"title":"蓝将云手机实现探究-野生前端程序员的音视频入门","slug":"rtc/前端程序员的音视频入门","date":"2021-06-06T12:59:24.000Z","updated":"2025-03-08T17:11:22.161Z","comments":true,"path":"2021/06/06/rtc/前端程序员的音视频入门/","permalink":"http://mcdowell8023.github.io/2021/06/06/rtc/%E5%89%8D%E7%AB%AF%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E9%9F%B3%E8%A7%86%E9%A2%91%E5%85%A5%E9%97%A8/","excerpt":"","text":"最早，在一家做安防类的公司，使用海康威视等摄像头 提供的 视频流【 rtsp, rtmp 协议的 h264 视频流 】 在 浏览器客户端播放。 在当时，只能使用的几种方式： 直接在借助 第三方浏览器插件 在浏览器播放。VLC 等第三方浏览器插件 提供的api 【 缺点： 需要 客户提前安装 插件，只有vlc 插件可以播放 rtsp的视频流 ，而已只在ie 已经过时 】 服务端转码 成为 web 直接可以播放的 hls（m3u8） [ 缺点 ：需要服务器和更多带宽 成本较高，而且 实时性较差 ] 参与云手机的研发【 web网页上 控制远端安卓手机 (触控层 + 视频层)，安卓端 发送视频流，web 端进行解码播放 】 早期 解码方案 使用 第三方库 ws-avc-playerjs【 基于Broadway/Player解码 （ Webassembly + FFmpeg 视频解码 + canvas ） 】ws-avc-playerjs 虽然 不支持音频，没有使用流协议进行压缩传输，播放及其容易卡顿，但是其提供的 解决思路，确实值得深入学习。 借助 webrtc 解决方案，绕开 自己直接进行解码，音视频同步等一些列繁杂工作 蓝将云手机是什么 通过 web网页 控制远端安卓手机，实现广告中 软件、游戏的体验功能；游戏工作室 挂机代练等等使用场景。 蓝将网址 如何实现的 前端分为 视频层 和 触控层 视频层 接收 远端安卓手机 视频流进行播放 触控层 点击后通过 websocket 给安卓端 发送 事件消息 本文 仅以 介绍视频播放 方向内容 实现都经历了哪些过程 最早方案：使用 第三方库 ws-avc-playerjs【 基于Broadway/Player解码 （ Webassembly + FFmpeg 视频解码 + canvas ） 】 面临的问题： 没有 音频 【 需求硬性要求 】 播放时常 存在 延迟卡顿、累计延迟【 手机等内存设备更为明显 】 要解决上面问题，还得从头捋，了解 音视频基本知识 ，如何和完成视频播放。 音频 声音本质就是能量波，为了将模拟信号数字化 分别要对模拟信号进行 采样、量化和编码。 采样 采样就是 在时间轴上对信号进行数字化。 根据奈奎斯特定理(也称为采样定理)，按比声音最高频率高 2 倍以上的频率对声音进行采样(也称为 AD 转换)， 对于高质量的音频信号，其频率范围(人耳 能够听到的频率范围)是 20Hz~20kHz，所以采样频率一般为 44.1kHz，这样就可以保证采样声音达到 20kHz 也能被数字化，从而使得 经过数字化处理之后，人耳听到的声音质量不会被降低。 而所谓的 44.1kHz 就是代表 1 秒会采样 44100 次。 量化 量化是指在幅度轴上对信号进行数字化，比如用 16 比特（16 个二进制位） 的二进制信号来表示声音的一个采样，而 16 比特(一个 short)所表示的 范围是[-32768，32767]，共有 65536 个可能取值，因此最终模拟的音频 信号在幅度上也分为了 65536 层 编码 所谓编码，就是按照一定的格式记录采样和量化后的数字数据，比如顺序存储或压缩存储，等等。 音频编码 上文中，提到了 CD 音质的数据采样格式，曾计算出每分钟需要的存 储空间约为 10.1MB，如果仅仅是将其存放在存储设备(光盘、硬盘) 中，可能是可以接受的，但是若要在网络中实时在线传播的话，那么这 个数据量可能就太大了，所以必须对其进行压缩编码。 压缩编码 压缩编码的基本指标之一就是压缩比，压缩比通常小于 1(否则就没有必要去做压缩， 因为压缩就是要减小数据容量) 压缩编码的原理实际上是压缩掉冗余信号，冗余信号是指不能被人 耳感知到的信号，包含人耳听觉范围之外的音频信号以及被掩蔽掉的音频信号等。 压缩算法: 无损压缩：无损压缩是指解压后的数据可以完全复原。 有损压缩：指解压后的数据不能完全复原，会丢失一部分信息； 用得较多； 压缩比越小，丢失的信息就越多，信号还原后的失真就会 越大； 根据不同的应用场景(包括存储设备、传输网络环境、播放设备 等)，可以选用不同的压缩编码算法，如 PCM、WAV、AAC、MP3、 Ogg 等 PCM PCM 是软件层接收到最原始的音频格式数据。浏览器支持 audio api 直接播放 PCM PCM(Pulse Code Modulation，脉冲编码调制) 音频数据是未经压缩的音频采样数据裸流，它是由模拟信号经过采样、量化、编码转换成的标准数字音频数据。 通常所说的音频的裸数据格式就是 PCM数据。描述一段 PCM 数据一 般需要以下几个概念: 量化格式(sampleFormat)、采样率 (sampleRate)、声道数(channel)。 以 CD 的音质为例: 量化格式为 16-bit(2 字节)，采样率(Sample Rate)为 44100，声道数为 2，这些信息就描述了 CD 的音质。 而对于声音格式，还有一个概念用来 描述它的大小，称为数据比特率(即 1 秒时间内的比特数目，用于衡量 音频数据 单位时间内的容量大小) 对于 CD 音质的数据，比特率为：44100 * 16 * 2 = 1378.125kbps 1 分钟里，这类 CD 音质的数据需要占据多大的存储需要 1378.125 * 60 / 8（8位是1字节得到KB） / 1024(KB换算MB) = 10.09MB 如果 量化格式(sampleFormat) 更加精确【 比如用 4 字节(32-bit)来描述一个采样】，或者 采样率（sampleRate） 更加密集(比如 48kHz 的采样率)，那么所占的 存储空间就会更大，同时能够描述的声音细节就会越精确。 存储的这段二进制数据即表示将模拟信号转换为数字信号了，以后就可以对这段二进制数据进行存储、播放、复制，或者进行其他任何操作。 图像 视频是由一幅幅图像组成的，所以要学习视频还得从图像说起 RGB 表示方式: 浮点表示：取值范围为 0.0 ～ 1.0，比如，在 OpenGL ES 中对每一个子像素点的表示使用的就是这种表达方式。 整数表示：取值范围为0 ～ 255或者00 ～ FF，8 个比特表示一个子像素，32 个比特（除了 RGB 三色外，还有 alpha 透明度;也就是 4*8）表示一个像素，这就是类似于某些平台上表示图像格式的 RGBA_8888 数据格式。 对于一幅图像，一般使用整数表示方法来进行描述， 比如计算一张 1280×720 的 RGBA_8888 图像的大小，可采用如下方式：1280 * 720 * 4 = 3.516MB 这也是位图（bitmap）在内存中所占用的大小，所以每一张图像的裸数据都是很大的。 对于图像的裸数据来讲，直接在网络上进行传输也是不太可能的，所以就有了图像的压缩格式， 比如 JPEG 压缩：JPEG 是静态图像压缩标准，由 ISO 制定。 JPEG 图像压缩算法在提供良好的压缩性能的同时，具有较好的重建质量。 这种算法被广泛应用于图像处理领域，当然其也是一种有损压缩。 在很多网站如淘宝上使用的都是这种压缩之后的图片，但是，这种压缩不能直接应用于视频压缩，因为对于视频来讲，还有一个时域上的因素需要考虑，也就是说，不仅仅要考虑帧内编码，还要考虑帧间编码。视频采用的是更成熟的算法。 YUV 表示方式【 主流 】 YUV 也是一种色彩编码方法，主要用于电视系统以及模拟视频领域。它将亮度信息（Y）与色彩信息（UV）分离，即使没有 UV 信息一样可以显示完整的图像，只不过是黑白的，这样的设计很好地解决了彩色电视机与黑白电视的兼容问题。 与 RGB 视频信号传输相比，它最大的优点在于只需要占用极少的频宽（RGB 要求三个独立的视频信号同时传输）。其中“Y”表示明亮度（Luminance 或 Luma），也称灰阶值；而“U”和“V”表示的则是色度（Chrominance 或 Chroma），它们的作用是描述影像的色彩及饱和度，用于指定像素的颜色。 “亮度”是透过 RGB 输入信号来建立的，方法是将 RGB 信号的特定部分叠加到一起。“色度”则定义了颜色的两个方面——色调与饱和度，分别用 Cr 和 Cb 来表示。其中，Cr 反映了 RGB 输入信号红色部分与 RGB 信号亮度值之间的差异，而 Cb 反映的则是 RGB 输入信号蓝色部分与 RGB 信号亮度值之间的差异。 视频 视频编码 音频压缩主要是去除冗余信息，从而实现数据量的压缩。其实视频压缩也是通过去除冗余信息来进行压缩的。 相较于音频数据，视频数据有极强的相关性，也就是说有大量的冗余信息，包括空间上的冗余信息和时间上的冗余信息。使用帧间编码技术可以去除时间上的冗余信息，具体包括以下几个部分。 运动补偿：运动补偿是通过先前的局部图像来预测、补偿当前的局部图像，它是减少帧序列冗余信息的有效方法。 运动表示：不同区域的图像需要使用不同的运动矢量来描述运动信息。 运动估计：运动估计是从视频序列中抽取运动信息的一整套技术。使用帧内编码技术可以去除空间上的冗余信息。 ISO 视频压缩标准（Motion JPEG 即 MPEG）： Mpeg1（用于 VCD） Mpeg2（用于 DVD） Mpeg4 AVC（现在流媒体使用最多的就是它了） ITU-视频压缩标准 H.261 H.262 H.263 H.264 （集中了以往标准的所有优点，并吸取了以往标准的经验） h.265 现在使用最多的就是 H.264 标准，H.264 创造了多参考帧、多块类型、整数变换、帧内预测等新的压缩技术，使用了更精细的分像素运动矢量（1/4、1/8）和新一代的环路滤波器，这使得压缩性能得到大大提高，系统也变得更加完善 编码概念： IPB 帧 视频压缩中，每帧都代表着一幅静止的图像。而在进行实际压缩时，会采取各种算法以减少数据的容量，其中 IPB 帧就是最常见的一种。 I 帧：关键帧。压缩率低，可以单独解码成一幅完整的图像。 P 帧：参考帧。压缩率较高，解码时依赖于前面已解码的数据。 P 帧需要参考其前面的一个 I 帧或者 P 帧来解码成一张完整的视频画面。 B 帧：前后参考帧。压缩率最高，解码时不光依赖前面已经解码的帧，而且还依赖它后面的 P 帧。换句话说就是，B 帧后面的 P 帧要优先于它进行解码，然后才能将 B 帧解码。 B 帧则需要参考其前一个I 帧或者 P 帧及其后面的一个P 帧来生成一张完整的视频画面，所以P 帧与 B 帧去掉的是视频帧在时间维度上的冗余信息 H.264 的 IDR 帧与 I 帧的理解 IDR 帧（instantaneous decoding refreshpicture） IDR 帧与 I 帧的区别 IDR 帧就是一种特殊的 I 帧，即这一帧之后的所有参考帧只会参考到这个 IDR 帧，而不会再参考前面的帧。在解码器中，一旦收到一个 IDR 帧，就会立即清理参考帧缓冲区，并将 IDR 帧作为被参考的帧。 因为 H.264 采用了多帧预测，所以 I 帧 之后的 P 帧有可能会参考 I 帧之前的帧，这就使得在随机访问的时候不能以找到 I 帧作为参考条件，因为即使找到 I 帧，I 帧之后的帧还是有可能解析不出来 I 帧、P 帧、B 帧 的说明(编码器工作)： 帧率 25fps( 指每秒 25 个 P 帧或 B 帧) 视频画面变化不大情况下， 每间隔 25 个参考帧 出 一个 I 帧 视频画面变化较大（如：电影场景切换）时，会立马 出一个 I 帧, 用于更换视频场景及后面的参考帧处理解码 视频播放器 视频协议 只有在有网络时通过浏览器或者移动端APP才能看到的视频。 常见的直播流协议有：RTMP、RTSP、HTTP 等； 常见的点播协议有：http-MP4、http-FLV、HLS 等。 在连接视频协议时，除了音视频频流和metadata之外，可能还会携带播放的信令 视频容器 通常说的视频的格式，比如 .mp4, .mov, .wmv, .m3u8, .flv 等等被称为 容器 【container】。 含了video数据、audio数据、metadata（用于检索视音频payload格式等信息）。 每个格式的封装格式不一样，比如FLV格式的基本单元是Tag，而MP4格式的基本单元是Box，辅助的 meta信息用于检索找到对应的原始数据。 编解码器 Mpeg2, H.264, H.265等视频编码标准被称为 编解码器 ( codec)。 一个视频格式比如 mp4可以使用任何标准化的压缩算法，这些信息都会被包含在一个视频文件的meta信息中来告诉播放器该用什么编解码算法来播放。 所以通过以上只是，我们基本知道，一个视频播放器的 播放文件的几个步骤 播放本地文件则不需要解协议 解封装 解码视音频 视音频同步 播放一个互联网上的视频文件 解协议 [rtmp\\rtsp\\http-flv\\hls] 解封装（容器） [mp4\\ts\\avi] 解码视音频 视音频同步 回到上面，分析 ws-avc-player 的解题思路是 核心思路： 通过websock 接收 arraybuffer，创建缓冲器 通过缓冲器 借助 浏览器api: requestAnimationFrame 一帧一帧 解码绘制 借助 Broadway/Player库（ WebAssembly + FFmpeg ）进行 视频解码 分析 没有使用 视频协议 导致 流量带宽 消耗大 在远端编码阶段没有 使用容器 包裹音频数据，且 接收端 没有 音频解码操作 增加音频可能需要单独的 websocket 接收 音频数据 进行解码 播放，而且还存在 音视频同步问题 tcp 的 传输方式 延迟 无法避免 团队研发能力不足，无法进行二次开发 综上，选择了放弃该方案。 最终落地 使用 webrtc 全家桶 编码端 解码端 统一解决方案 低延迟（RTP/RTCP 基于udp） 自适应码率 稳定传输 仍然存在延迟，尚且需要优化。","categories":[{"name":"技术帖","slug":"技术帖","permalink":"http://mcdowell8023.github.io/categories/%E6%8A%80%E6%9C%AF%E5%B8%96/"}],"tags":[{"name":"追本溯源","slug":"追本溯源","permalink":"http://mcdowell8023.github.io/tags/%E8%BF%BD%E6%9C%AC%E6%BA%AF%E6%BA%90/"},{"name":"直播","slug":"直播","permalink":"http://mcdowell8023.github.io/tags/%E7%9B%B4%E6%92%AD/"},{"name":"音视频","slug":"音视频","permalink":"http://mcdowell8023.github.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"}]},{"title":"JavaScript从头来5-拨开迷雾，从浏览器说起","slug":"js基础系列/JavaScript从头来5-拨开迷雾，从浏览器说起","date":"2020-08-27T11:58:53.000Z","updated":"2025-03-08T10:12:46.165Z","comments":true,"path":"2020/08/27/js基础系列/JavaScript从头来5-拨开迷雾，从浏览器说起/","permalink":"http://mcdowell8023.github.io/2020/08/27/js%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97/JavaScript%E4%BB%8E%E5%A4%B4%E6%9D%A55-%E6%8B%A8%E5%BC%80%E8%BF%B7%E9%9B%BE%EF%BC%8C%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AF%B4%E8%B5%B7/","excerpt":"","text":"","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://mcdowell8023.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://mcdowell8023.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"追本溯源","slug":"追本溯源","permalink":"http://mcdowell8023.github.io/tags/%E8%BF%BD%E6%9C%AC%E6%BA%AF%E6%BA%90/"},{"name":"js基础","slug":"js基础","permalink":"http://mcdowell8023.github.io/tags/js%E5%9F%BA%E7%A1%80/"}]},{"title":"JavaScript从头来4-基石作用域和闭包","slug":"js基础系列/JavaScript从头来4-基石作用域和闭包","date":"2020-08-27T11:56:26.000Z","updated":"2025-03-08T10:12:43.792Z","comments":true,"path":"2020/08/27/js基础系列/JavaScript从头来4-基石作用域和闭包/","permalink":"http://mcdowell8023.github.io/2020/08/27/js%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97/JavaScript%E4%BB%8E%E5%A4%B4%E6%9D%A54-%E5%9F%BA%E7%9F%B3%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85/","excerpt":"","text":"","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://mcdowell8023.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://mcdowell8023.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"追本溯源","slug":"追本溯源","permalink":"http://mcdowell8023.github.io/tags/%E8%BF%BD%E6%9C%AC%E6%BA%AF%E6%BA%90/"},{"name":"js基础","slug":"js基础","permalink":"http://mcdowell8023.github.io/tags/js%E5%9F%BA%E7%A1%80/"}]},{"title":"JavaScript从头来3-面向对象","slug":"js基础系列/JavaScript从头来3-面向对象","date":"2020-08-27T11:54:41.000Z","updated":"2025-03-08T10:12:41.508Z","comments":true,"path":"2020/08/27/js基础系列/JavaScript从头来3-面向对象/","permalink":"http://mcdowell8023.github.io/2020/08/27/js%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97/JavaScript%E4%BB%8E%E5%A4%B4%E6%9D%A53-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://mcdowell8023.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://mcdowell8023.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"追本溯源","slug":"追本溯源","permalink":"http://mcdowell8023.github.io/tags/%E8%BF%BD%E6%9C%AC%E6%BA%AF%E6%BA%90/"},{"name":"js基础","slug":"js基础","permalink":"http://mcdowell8023.github.io/tags/js%E5%9F%BA%E7%A1%80/"}]},{"title":"JavaScript从头来2.3-其他引用类型","slug":"js基础系列/JavaScript从头来2.3-其他引用类型","date":"2020-08-27T11:53:21.000Z","updated":"2025-03-08T10:12:38.920Z","comments":true,"path":"2020/08/27/js基础系列/JavaScript从头来2.3-其他引用类型/","permalink":"http://mcdowell8023.github.io/2020/08/27/js%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97/JavaScript%E4%BB%8E%E5%A4%B4%E6%9D%A52.3-%E5%85%B6%E4%BB%96%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://mcdowell8023.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://mcdowell8023.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"追本溯源","slug":"追本溯源","permalink":"http://mcdowell8023.github.io/tags/%E8%BF%BD%E6%9C%AC%E6%BA%AF%E6%BA%90/"},{"name":"js基础","slug":"js基础","permalink":"http://mcdowell8023.github.io/tags/js%E5%9F%BA%E7%A1%80/"}]},{"title":"JavaScript从头来2.2-对象","slug":"js基础系列/JavaScript从头来2.2-对象","date":"2020-08-27T11:52:35.000Z","updated":"2020-10-22T11:47:16.393Z","comments":true,"path":"2020/08/27/js基础系列/JavaScript从头来2.2-对象/","permalink":"http://mcdowell8023.github.io/2020/08/27/js%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97/JavaScript%E4%BB%8E%E5%A4%B4%E6%9D%A52.2-%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"javascript 中 万物皆对象。 对象只是带有属性和方法的特殊数据类型 对象只是一种特殊的数据。对象拥有属性和方法 js 中的引用类型都派生自 对象（Object），如 Array Function Math 等等 包括 常见的 基本类型(值类型) string 、 number 的值 均为对应的 String 、 Number 调用 valueOf 或者 toString 得到的 可见，对象在 javascript 中的地位。 在 javascript 的世界里，对象就是属性的集合 对象 从形式上来定义 JavaScript 的对象，是一种属性的集合。【 属性值可以是 函数（function）】 创建对象 使用 对象字面量 创建对象 1234567var person = &#123; name: &#x27;mcdowell&#x27;, age: 29,&#125;person.sayName = function () &#123; alert(this.name)&#125; 使用{}创建对象，等同于 new Object(); 使用 new 借助 Object 函数 创建对象 123456var person = new Object()person.name = &#x27;mcdowell&#x27;person.age = 29person.sayName = function () &#123; alert(this.name)&#125; 问题：1.代码冗余； 2.对象中的方法不能共享，每个对象中的方法都是独立的 使用 工厂模式 创建对象 12345678910111213141516171819function createPerson(name, age) &#123; var person = new Object() person.name = name person.age = age person.sayName = function () &#123; alert(this.name) &#125; return person&#125;var p1 = createPerson(&#x27;mcdowell&#x27;, 29)var p2 = createPerson(&#x27;bart&#x27;, 31)console.log(p1, &#x27;p1,p2&#x27;, p2)console.log(p1.constructor === p2.constructor) //trueconsole.log(p1.constructor === createPerson) //falseconsole.log(p1 instanceof Object) //trueconsole.log(p2 instanceof Object) //trueconsole.log(p1.sayName === p2.sayName) //false 工厂函数每执行一次，都会创建一个对象。 每个创建的 对象都拥有各自独立的方法和属性。 对象的 constructor 构造函数共同指向 Object 方法 优点：避免部分代码重复，减少冗余 缺点：每个对象 调用的还是不同的方法 ( 方法没有实现复用 ) 通过构造函数创建对象 1234567891011121314151617function Person(name, age) &#123; this.name = name this.age = age this.sayName = function () &#123; alert(this.name) &#125;&#125;var p1 = new Person(&#x27;mcdowell&#x27;, 29)var p2 = new Person(&#x27;bart&#x27;, 31)//console.log(p1, &#x27;p1,p2&#x27;, p2)console.log(p1.constructor === p2.constructor) //trueconsole.log(p1.constructor === Person) //trueconsole.log(p1 instanceof Object) //trueconsole.log(p2 instanceof Object) //trueconsole.log(p1.sayName === p2.sayName) //false 每 new 一次 构造函数，都会创建一个对象 每个创建的 对象都拥有各自独立的方法和属性。 对象的 constructor 构造函数共同指向 Person 方法 优点：进一步优化，避免部分代码重复，减少冗余 缺点：每个对象 调用的还是不同的方法 ( 方法没有实现复用 ) 通过 原型模式 创建对象 1234567891011121314151617function Person() &#123;&#125;Person.prototype.name = &#x27;person&#x27;Person.prototype.sayName = function () &#123; console.log(this.name, &#x27;name&#x27;)&#125;var p1 = new Person()var p2 = new Person()p1.sayName()console.log(p1.sayName === p2.sayName) // trueconsole.log(Person.prototype.constructor) // function Person()&#123;&#125;console.log(Person.prototype.constructor == Person) // trueconsole.log(p1.__proto__ === p2.__proto__) // true 每 new 一次 构造函数，都会创建一个对象 每个创建的 对象都 都通过 proto 指向 Person.prototype 对象，从而实现 属性方法共享。 对象的 constructor 构造函数共同指向 Person 方法 优点： 真正意义实现了复用 缺点： 各对象 也需要自己特有属性 方法 通过 原型模式 + 构造函数 创建对象 12345678910111213141516171819function createPerson(name, age) &#123; this.name = name this.age = age&#125;createPerson.protoType.sayName = function () &#123; alert(this.name)&#125;；var p1 = new createPerson(&#x27;mcdowell&#x27;, 29)var p2 = new createPerson(&#x27;bart&#x27;, 31)//console.log(p1, &#x27;p1,p2&#x27;, p2)console.log(p1.constructor === p2.constructor) //trueconsole.log(p1.constructor === createPerson) //trueconsole.log(p1 instanceof Object) //trueconsole.log(p2 instanceof Object) //trueconsole.log(p1.sayName === p2.sayName) //false 优点：每个对象 都会有自己的一份 属性的副本，但又同时共享着对方法的引用，最大限度地节省了内存。 继承：需要复用的放在 protoType 属性指向的对象下 ，通过 原型链 的方式 实现复用 多态：不同对象 的特殊属性（多态） 借助构造函数完成 通过 Object.create 创建对象 语法：Object.create(proto, [propertiesObject]) proto:必须。表示新建对象的原型对象，即该参数会被赋值到目标对象(即新对象，或说是最后返回的对象)的原型上。该参数可以是 null、对象、函数的 prototype 属性 可选。 添加到新创建对象的可枚举属性（即其自身的属性，而不是原型链上的枚举属性）对象的属性描述符以及相应的属性名称。这些属性对应 Object.defineProperties 的第二个参数。 123456789101112131415161718192021var object = Object.create(null) // &#123;&#125; 创建了一个空对象// 创建一个人// 自带 头发，皮肤 属性// 人类 类型无法改变// 用第二个参数创建非空对象的属性描述符默认是为false的，// 不可写,不可枚举,不可配置var p1 = Object.create( &#123; hair: &#x27;black&#x27;, skin: &#x27;yellow&#x27; &#125;, &#123; type: &#123; value: &#x27;person&#x27;, writable: false, enumerable: false, configurable: false, &#125;, &#125;)// 给上名字 和 年龄p1.name = &#x27;mcdowell&#x27;p1.age = &#x27;20&#x27;console.log(p1) 与 new Object 创建方式不同；new Object 创建的对象 原型 指向的原型对象一直都存在 Object.create(null) 创建的对象 为真正意义上的空对象，原型 为 undefined Object.create 直接以 传入对象 作为 原型 进行创建的 Object.create 创建的对象 的 constructor 与 new Object 创建的对象 的 constructor 都指向 Object 构造函数 通过 class 创建对象 类 不会像函数一样 去进行变量提升 123456789101112131415161718192021222324252627282930313233343536// 父类class Person &#123; // 公有属性 type = &#x27;human&#x27; // 私有属性，外部无法访问（会报错） // 读取私有属性的方法 this.#study #study = &#x27;true&#x27; constructor(name, age) &#123; // constructor 上来就执行，相当于 构造函数 本身属性 this.name = name this.age = age &#125; // 定义静态 属性 同 静态方法，无法在实例中 读取，仅在 构造函数 属性说明 static description = &#x27;person&#x27; // static 关键字用来定义一个类的一个静态方法。 // 调用静态方法不需要实例化该类，但不能通过一个类实例调用静态方法。 // 静态方法通常用于为一个应用程序创建工具函数。 static create(name, age) &#123; var person = new Person(name, age) console.log(&#x27;创建了一个人&#x27;, person) return person &#125; // 相当于 构造函数 的 原型对象 中 进行声明 函数方法 sayName() &#123; console.log(&#x27;说出自己的名字：&#x27;, this.name) &#125; speak() &#123; console.log(&#x27;介绍自己：&#x27;, this, &#x27;私有属性 #study&#x27;, this.#study) &#125;&#125;// 直接访问 外侧静态属性console.log(&#x27;输出静态属性description：&#x27;, Person.description)var p1 = Person.create(&#x27;mcdowell&#x27;, 20)p1.sayName()p1.speak() extends 继承 继承 class 12345678910111213141516// 子类class Man extends Person &#123; constructor(...props) &#123; // 调用超类构造函数并传入参数 // 如果子类中定义了构造函数，那么它必须先调用 super() 才能使用 this super(...props) this.sex = &#x27;man&#x27; &#125; sayName() &#123; console.log(&#x27;我叫&#x27;, this.name, &#x27;我是个男的&#x27;) &#125;&#125;var man = new Man(&#x27;bart&#x27;, 22)man.sayName()man.speak() 继承 传统 函数类 1234567891011121314151617function Animal() &#123; this.name = name&#125;Animal.prototype.speak = function () &#123; console.log(this.name + &#x27; 发出声音&#x27;)&#125;class Dog extends Animal &#123; speak() &#123; // 使用 super 关键字 调用 对象的父对象上的函数 super.speak() console.log(this.name + &#x27; 汪汪叫&#x27;) &#125;&#125;var dog = new Dog(&#x27;阿福&#x27;)dog.speak() 类不能继承常规对象（不可构造的） 12345678910111213141516var Animal = &#123; speak: function () &#123; console.log(this.name + &#x27; 发出声音&#x27;) &#125;,&#125;class Dog &#123; constructor(name) &#123; this.name = name &#125;&#125;// 通过 Object.setPrototypeOf 继承常规对象Object.setPrototypeOf(Dog.prototype, Animal)var dog = new Dog(&#x27;阿福&#x27;)dog.speak() 首先，我肯定是需要你告诉我，什么是面向对象，面向对象有哪些特点，以及这些特点的解释。 JavaScript 如何实现这些特点，比如封装、继承、多态。如果关于上述三点，你能够解释到有多少种实现方式、优缺点是什么。以及近几年流行的解决方案是什么。这就是加分 ，比如对于继承吧。类式继承、构造函数继承、组合继承、原型继承、寄生组合继承等等，说出大概的实现思路和优缺点，再介绍下 extends 或者 mixin 的实现甚至你可以衍生到 JavaScript 的模块化发展甚至到为什么现在 TS 如此流行。那么可以说到这一环节解答的就非常棒了。 回答完 JavaScript 的面向对象，是不是可以从此衍生下为什么需要面向对象。以及当先对于软件设计的高内聚、低耦合的思考？来个对此题一个提纲挈领的总结？","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://mcdowell8023.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://mcdowell8023.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"追本溯源","slug":"追本溯源","permalink":"http://mcdowell8023.github.io/tags/%E8%BF%BD%E6%9C%AC%E6%BA%AF%E6%BA%90/"},{"name":"js基础","slug":"js基础","permalink":"http://mcdowell8023.github.io/tags/js%E5%9F%BA%E7%A1%80/"}]},{"title":"透视http协议笔记2-基础概念","slug":"透视http协议笔记2-基础概念","date":"2020-05-25T01:38:33.000Z","updated":"2025-03-07T17:17:24.720Z","comments":true,"path":"2020/05/25/透视http协议笔记2-基础概念/","permalink":"http://mcdowell8023.github.io/2020/05/25/%E9%80%8F%E8%A7%86http%E5%8D%8F%E8%AE%AE%E7%AC%94%E8%AE%B02-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/","excerpt":"","text":"HTTP 是什么 HyperText Transfer Protocol, 超文本传输协议 超文本传输协议 超文本 “超文本”，就是“超越了普通文本的文本”，包含文字、图片、音频和视频等的混合体 最关键的是含有“超链接”，能够从一个“超文本”跳跃到另一个“超文本”，形成复杂的非线性、网状的结构关系。 传输 是一个“双向协议” 数据虽然是在 A 和 B 之间传输，但并没有限制只有 A 和 B 这两个角色，允许中间有“中转”或者“接力” HTTP 是一个在计算机世界里专门用来在两点之间传输数据的约定和规范。 协议 两个或多个参与者 是对参与者的一种行为约定和规范 HTTP 是一个用在计算机世界里的协议。它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范，以及相关的各种控制和错误处理方式。 总结下来 具体说 HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范. HTTP 不是什么 HTTP 不是互联网 HTTP 是构建互联网的一块重要拼图，而且是占比最大的那一块。但是构建互联网还包含其他，超文本资源使用 HTTP，普通文件使用 FTP，电子邮件使用 SMTP 和 POP3 等。 使用浏览器访问的 是万维网（www）,只是互联网的一部分 HTTP 不是编程语言 编程语言是人与计算机沟通交流所使用的语言，而HTTP 是计算机与计算机沟通交流的语言，是要通过 编程语言实现 http 进行与其他计算机通信的。 HTTP 和 HTML 不可混为一谈 HTML 是超文本的载体，是一种标记语言，使用各种标签描述文字、图片、超链接等资源，并且可以嵌入 CSS、JavaScript 等技术实现复杂的动态效果。虽然通常，我们使用 http 传输 html 但是，http 还可以传输其他文本、文件。 HTTP 不是一个孤立的协议 HTTP 通常跑在 TCP/IP 协议栈之上：依靠 IP 协议实现寻址和路由、TCP 协议实现可靠数据传输、DNS 协议实现域名查找、SSL/TLS 协议实现安全通信。 还有一些协议依赖于 HTTP，例如 WebSocket、HTTPDNS 等。这些协议相互交织，构成了一个协议网，而 HTTP 则处于中心地位。 与 HTTP 相关的各种概念 互联网的正式名称是 Internet，里面存储着无穷无尽的信息资源，我们通常所说的“上网”实际上访问的只是互联网的一个子集“万维网”（World Wide Web），它基于 HTTP 协议，传输 HTML 等超文本资源，能力也就被限制在 HTTP 协议之内。 互联网上还有许多万维网之外的资源，例如常用的电子邮件、BT 和 Magnet 点对点下载、FTP 文件下载、SSH 安全登录、各种即时通信服务等等，它们需要用各自的专有协议来访问。 浏览器 浏览器的正式名字叫“Web Browser”，顾名思义，就是检索、查看互联网上网页资源的应用程序，名字里的 Web，实际上指的就是“World Wide Web”，也就是万维网。浏览器本质上是一个 HTTP 协议中的请求方，使用 HTTP 协议获取网络上的各种资源。 在 HTTP 协议里，浏览器的角色被称为“User Agent”即“用户代理”，意思是作为访问者的“代理”来发起 HTTP 请求。不过在不引起混淆的情况下，我们通常都简单地称之为“客户端”。 Web 服务器 服务器，Web Server。服务器是一个很大也很重要的概念，它是 HTTP 协议里响应请求的主体，通常也把控着绝大多数的网络资源，在网络世界里处于强势地位。 硬件含义就是物理形式或“云”形式的机器，在大多数情况下它可能不是一台服务器，而是利用反向代理、负载均衡等技术组成的庞大集群。 软件提供 Web 服务的应用程序，通常会运行在硬件含义的服务器上。它利用强大的硬件能力响应海量的客户端 HTTP 请求，处理磁盘上的网页、图片等静态文件，或者把请求转发给后面的 Tomcat、Node.js 等业务应用，返回动态的信息 Apache 是老牌的服务器，到今天已经快 25 年了，功能相当完善，相关的资料很多，学习门槛低，是许多创业者建站的入门产品。 Nginx 是 Web 服务器里的后起之秀，特点是高性能、高稳定，且易于扩展。在高流量的网站里更是不二之选。 此外，还有 Windows 上的 IIS、Java 的 Jetty/Tomcat 等，因为性能不是很高，所以在互联网上应用得较少。 CDN [ 负载均衡，就近访问 ] CDN，全称是“Content Delivery Network”，翻译过来就是“内容分发网络”。它应用了 HTTP 协议里的缓存和代理技术，代替源站响应客户端的请求。它可以缓存源站的数据，让浏览器的请求不用“千里迢迢”地到达源站服务器，直接在“半路”就可以获取响应。如果 CDN 的调度算法很优秀，更可以找到离用户最近的节点，大幅度缩短响应时间。 CDN 也是现在互联网中的一项重要基础设施，除了基本的网络加速外，还提供负载均衡、安全防护、边缘计算、跨运营商网络等功能，能够成倍地“放大”源站服务器的服务能力 爬虫 是一种可以自动访问 Web 资源的应用程序。它们就像是一只只不知疲倦的、辛勤的蚂蚁，在无边无际的网络上爬来爬去，不停地在网站间奔走，搜集抓取各种信息，故而 成为爬虫。 绝大多数是由各大搜索引擎“放”出来的，抓取网页存入庞大的数据库，再建立关键字索引，这样我们才能够在搜索引擎中快速地搜索到互联网角落里的页面。 爬虫也有不好的一面，它会过度消耗网络资源，占用服务器和带宽，影响网站对真实数据的分析，甚至导致敏感信息泄漏。所以，又出现了“反爬虫”技术，通过各种手段来限制爬虫。其中一项就是“君子协定”robots.txt，约定哪些该爬，哪些不该爬。 无论是“爬虫”还是“反爬虫”，用到的基本技术都是两个，一个是 HTTP，另一个就是 HTML 图形验证码等，也是一种反爬虫手段。 linux 上的 wget、curl 等命令行工具也是基于 http，也是一种 user agent","categories":[{"name":"基础","slug":"基础","permalink":"http://mcdowell8023.github.io/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://mcdowell8023.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"http","slug":"http","permalink":"http://mcdowell8023.github.io/tags/http/"}]},{"title":"透视http协议笔记1-HTTP 的前世今生","slug":"透视http协议笔记1-HTTP 的前世今生","date":"2020-05-22T00:25:58.000Z","updated":"2020-05-25T01:36:46.637Z","comments":true,"path":"2020/05/22/透视http协议笔记1-HTTP 的前世今生/","permalink":"http://mcdowell8023.github.io/2020/05/22/%E9%80%8F%E8%A7%86http%E5%8D%8F%E8%AE%AE%E7%AC%94%E8%AE%B01-HTTP%20%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/","excerpt":"","text":"HTTP 的前世今生 史前 20 世纪 60 年代，美国国防部高等研究计划署（ARPA）建立了 ARPA 网，它有四个分布在各地的节点，被认为是如今互联网的“始祖”。 在 70 年代，基于对 ARPA 网的实践和思考，研究人员发明出了著名的 TCP/IP 协议。由于具有良好的分层结构和稳定的性能，TCP/IP 协议迅速战胜其他竞争对手流行起来，并在 80 年代中期进入了 UNIX 系统内核，促使更多的计算机接入了互联网。 创世纪 - 1989 1989 年，任职于欧洲核子研究中心（CERN）的蒂姆·伯纳斯 - 李发表了一篇论文，提出了在互联网上构建超链接文档系统，把这个系统称为“万维网”（World Wide Web），也就是我们现在所熟知的 Web。 URI：即统一资源标识符，作为互联网上资源的唯一身份； HTML：即超文本标记语言，描述超文本文档； HTTP：即超文本传输协议，用来传输超文本。 HTTP/0.9 - 20 世纪 90 年代 结构比较简单，采用了纯文本格式 【20 世纪 90 年代初期，计算机处理能力低，存储容量小，网速很慢，为了便于服务器和客户端处理】 只允许用“GET”动作从服务器上获取 HTML 文档【最初设想的系统里的文档都是只读的】 响应请求之后立即关闭连接 HTTP/1.0 - 1996 1996 年正式发布 HTTP/1.0,然而不是一个“标准”，只是记录已有实践和模式的一份参考文档，不具有实际的约束力，相当于一个“备忘录” 增加了 HEAD、POST 等新方法； 增加了响应状态码，标记可能的错误原因； 引入了协议版本号概念； 引入了 HTTP Header（头部）的概念，让 HTTP 处理请求和响应更加灵活； 传输的数据不再仅限于文本 1993 年，NCSA（美国国家超级计算应用中心）开发出了 Mosaic，是第一个可以图文混排的浏览器，随后又在 1995 年开发出了服务器软件 Apache，简化了 HTTP 服务器的搭建工作。同一时期，计算机多媒体技术也有了新的发展：1992 年发明了 JPEG 图像格式，1995 年发明了 MP3 音乐格式。 从用户需求的角度促进了 HTTP 的发展。 HTTP/1.1 - 1999 得益于 1995 年，网景和微软开始的“浏览器大战” 推动了 Web 的发展，HTTP/1.0 经受了实践检验。 “浏览器大战”结束之后的 1999 年，HTTP/1.1 发布了 RFC 文档，编号为 2616，正式确立了延续十余年的传奇。 它是一个“正式的标准”，所有的浏览器、服务器、网关、代理等等，只要用到 HTTP 协议，就必须严格遵守这个标准，相当于是互联网世界的一个“立法” 增加了 PUT、DELETE 等新的方法； 增加了缓存管理和控制； 明确了连接管理，允许持久连接； 允许响应数据分块（chunked），利于传输大文件； 强制要求 Host 头，让互联网主机托管成为可能 HTTP/2 - 2015 HTTP/1.1 发布之后，整个互联网世界呈现出了爆发式的增长，度过了十多年，对于 HTTP 出现了不满的意见： 主要就是连接慢，但 HTTP/1.1 标准一直“岿然不动”，无奈之下人们只好发明各式各样的“小花招”来缓解这些问题，比如以前常见的切图、JS 合并等网页优化手段。 搜索巨头 Google 忍不住了，决定“揭竿而起”。首先开发了自己的浏览器 Chrome，然后推出了新的 SPDY 协议（2009 年，基于 TCP ），并在 Chrome 里应用于自家的服务器，这也开启了第二次的“浏览器大战”，Chrome 目前的全球的占有率超过了 60%。Google 借此顺势把 SPDY 推上了标准的宝座，互联网标准化组织以 SPDY 为基础开始制定新版本的 HTTP 协议，最终在 2015 年发布了 HTTP/2，RFC 编号 7540。 HTTP/2 的制定充分考虑了现今互联网的现状：宽带、移动、不安全，在高度兼容 HTTP/1.1 的同时改善性能 二进制协议，不再是纯文本； 可发起多个请求，废弃了 1.1 里的管道； 使用专用算法压缩头部，减少数据传输量； 允许服务器主动向客户端推送数据； 增强了安全性，“事实上”要求加密通信。 HTTP/2 到今天已经四岁，也衍生出了 gRPC 等新协议，但由于 HTTP/1.1 实在是太过经典和强势，目前它的普及率还比较低，大多数网站使用的仍然还是 20 年前的 HTTP/1.1 HTTP/3 - 2018 无论 SPDY 还是 HTTP/2，都是基于 TCP 的，TCP 与 UDP 相比效率上存在天然的劣势 这次，还是 Google，而且它要“革自己的命”。 在 HTTP/2 还处于草案之时，2013 年 Google 开发了基于 UDP 的名为 QUIC 的传输层协议，QUIC 全称 Quick UDP Internet Connections，希望它能替代 TCP，使得网页传输更加高效。 2018 年，互联网标准化组织 IETF 提议将“HTTP over QUIC”更名为“HTTP/3”并获得批准，HTTP/3 正式进入了标准化制订阶段，也许两三年后就会正式发布，到时候我们很可能会跳过 HTTP/2 直接进入 HTTP/3。 HTTP/3 原理与实践 总结 HTTP 协议始于三十年前蒂姆·伯纳斯 - 李的一篇论文； HTTP/0.9 是个简单的文本协议，只能获取文本资源； HTTP/1.0 确立了大部分现在使用的技术，但它不是正式标准； HTTP/1.1 是目前互联网上使用最广泛的协议，功能也非常完善； HTTP/2 基于 Google 的 SPDY 协议，注重性能改善，但还未普及； HTTP/3 基于 Google 的 QUIC 协议，是将来的发展方向。","categories":[{"name":"基础","slug":"基础","permalink":"http://mcdowell8023.github.io/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://mcdowell8023.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"http","slug":"http","permalink":"http://mcdowell8023.github.io/tags/http/"}]},{"title":"web移动端调试笔记","slug":"web移动端调试笔记","date":"2020-04-22T08:26:08.000Z","updated":"2020-04-23T02:11:22.410Z","comments":true,"path":"2020/04/22/web移动端调试笔记/","permalink":"http://mcdowell8023.github.io/2020/04/22/web%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%B0%83%E8%AF%95%E7%AC%94%E8%AE%B0/","excerpt":"","text":"常见的几种调试方式 Chrome Develop Tool 调试 ：无须额外的成本，方便快捷。但是，真机器和模拟还是不一样的 (vConsole 调试)[https://github.com/Tencent/vConsole],使用简单，方便，就是 UI 界面，和 websock 问题，很头疼 苹果调试套装 ：IOS Safari + Mac OS Safari 配合调试 （以下重点说明） 安卓调试套装 ：Android Chrome + 桌面 Chrome 配合调试（以下重点说明） IOS Safari + Mac OS Safari 配合调试 设置 手机设置: 设置 -&gt; Safari -&gt; 高级 -&gt; Web 检查器 mac 电脑 设置： Safari 启用开发菜单：选择偏好设置 -&gt; 高级 -&gt; 在菜单栏中显示’开发’菜单命令 调试 设备与计算机通过数据线连接,手机打开要调试的页面 在 Safari 菜单：开发 -&gt; iphone-&gt; 要调试的页面 可以愉快调试了 Android Chrome + 桌面 Chrome 配合调试 手机端：开启开发者 -&gt; usb 调试, 用数据线连接至电脑【 你也可以通过 adb 无线调试方式进行连接 】 手机端：安装装谷歌浏览器，并打开 打开控制台，更多 -&gt; More tools -&gt; Remote devices 【 直接 地址栏 输入 Chrome://inspect 】 最早在谷歌 75 时候，我是可以直接见到 调试控制 DevTools 页面，更显版本后发现有些不一样。 谷歌版本&gt;= 81 你可能会碰到，Remote devices 栏中显示 如下： 12345This panel has been deprecated in favor of the chrome://inspect/#devices interface,which has equivalent functionality/* 直译： 此面板已被弃用，取而代之的是 chrome://inspect/#devices 接口，它具有同等的功能*/ 此时我们可以直接地址栏 输入 `chrome://inspect/#devices` 直接进入 DevTools 页面 找到 RemoteTarget 下 调试设备名称下面，输入 url 地址 open 后（会见到手机打开对应页面），下面会显示对应手机浏览器页签，点击 inspect 正常情况下你会见到弹窗 显示手机页面和控制台，就可以进行调试了 当地 5 步 出现弹窗，你有可能 会碰到 404 或者白页面。别急，打开你的 翻墙，或是 下载离线包具体看这里 Android 通过 Chrome Inspect 调试 WebView 的 H5 App 出现空白页面的解决方法（不需要 FQ） 关于无线连接方式 ADB 无线模式调试 具体可以看我的文章 使用 scrcpy 连接安卓手机进行投屏演示 里的无线连接 打开开发者模式，插线，保证同一网络 插上 USB 线，开启 USB 连接，adb usb 检查插上的设备，adb devices 开启手机服务： adb tcpip 5555（PS：5555 是端口号，可以随意地指定） 拔掉数据线，关于手机 找手机 ip 地址 adb connect 10.0.1.50:5555 [端口可以缺省，需要与 4 一致，默认 5555] # 返回 connected to 10.0.1.50 就表示成功","categories":[{"name":"工具","slug":"工具","permalink":"http://mcdowell8023.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"web移动端","slug":"web移动端","permalink":"http://mcdowell8023.github.io/tags/web%E7%A7%BB%E5%8A%A8%E7%AB%AF/"},{"name":"调试","slug":"调试","permalink":"http://mcdowell8023.github.io/tags/%E8%B0%83%E8%AF%95/"}]},{"title":"zshell--从不小心切换开始","slug":"工具/zshell-从不小心切换开始","date":"2020-04-22T03:48:55.000Z","updated":"2025-03-07T18:06:45.096Z","comments":true,"path":"2020/04/22/工具/zshell-从不小心切换开始/","permalink":"http://mcdowell8023.github.io/2020/04/22/%E5%B7%A5%E5%85%B7/zshell-%E4%BB%8E%E4%B8%8D%E5%B0%8F%E5%BF%83%E5%88%87%E6%8D%A2%E5%BC%80%E5%A7%8B/","excerpt":"","text":"每次在 mac 中 打开 iTerm, 提示： 123The default interactive shell is now zsh.To update your account to use zsh, please run `chsh -s /bin/zsh`.For more details, please visit https://support.apple.com/kb/HT208050. 手贱，执行了chsh -s /bin/zsh【其实我都不知道 zeshell 是啥 🤦‍♂️】 然后 adb connect 设备的 时候，adb 找不到了！！！🤦‍♂️🤦‍♂️🤦‍♂️ 查了一圈，终于有了了解，记录下。 关于 shell Shell 是 Linux/Unix 的一个外壳，你理解成衣服也行。它负责外界与 Linux 内核的交互，接收用户或其他应用程序的命令，然后把这些命令转化成内核能理解的语言，传给内核，内核是真正干活的，干完之后再把结果返回用户或应用程序。 那么关于切换 shell 12345678# 查看 电脑几种 shellcat /etc/shells# 切换 shell# 切换成 Zshellchsh -s /bin/zsh# 切换成 bashchsh -s /bin/bash 回到最初问题 仔细想来，其实就是环境变量问题，上面之所以提示找不到，无非 是 zshell 的环境变量没有配置 adb 需要去配置 其实到这里，我仅仅为了使用 adb 切换回去 继续使用 bash 就好，但是： 好奇啊，那么继续 关于 Zshell Shell 是在程序员与服务器间建立一个桥梁，它对外提供一系列命令，让我们得以控制服务器。常用的 Bash 就是 Shell 的一种，也是 Linux 下默认 Shell 程序。 Zsh 属于 Shell 中的一种，但比 Bash 好用，而且完全兼容 Bash，拥有及其丰富的插件、强大的自动补全能力、以及自定义功能、代码高亮，可以大大提供我们使用 Linux 的效率。因为 Z 是最后一个字母，因此大家称之为——终极 Shell。 安装 Zsh mac 跳过， 【系统已经默认安装好了】 Redhat Linux，执行：sudo yum install zsh Ubuntu Linux，执行：sudo apt-get install zsh windows , 洗洗睡吧 👋 安装 on-my-zsh Zsh 虽然好用，但直接用起来比较麻烦，这就是为啥初期用的人少，后台有个大神，把 Zsh 的配置弄得相当简单 ：(ohmyzsh)[https://github.com/robbyrussell/oh-my-zsh]; 我们就借助 on-my-zsh 进行配置。 自动安装 1wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O - | sh 手动安装 克隆项目 git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh 创建.zshrc 配置文件 cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc 切换 zsh chsh -s /bin/zsh (如果你还没有切换的话) 查看 zsh 版本 zsh --version 有人说 还 需要 更新配置 source ~/.zshrc ,但是我实际是从新打开 iTerm 就看到 shell 的变化了，代码高亮… 配置 主题 .zshrc 配置文件 中 默认主题 是 robbyrussell 1ZSH_THEME=&quot;robbyrussell&quot; # 更换主题名称即可 更多主题 插件 .zshrc 配置文件 中 plugins=(git) 即时配置插件位置【默认支持 git】 如果 mac 为例 增加 autojump 安装 brew install autojump 配置 增加 12plugins=(git autojump)[[ -s ~/.autojump/etc/profile.d/autojump.sh ]] &amp;&amp; . ~/.autojump/etc/profile.d/autojump.sh 关于 autojump，他是快捷跳转 你历史目录。比如， 先 cd /projcet/lanjiang/dist ,才可以 j lanjiang 更多 作为一个 前端程序员 ，显然没有运维和服务端人员 shell 玩的溜。能了解的有限可以戳 终极 Shell——ZSH zshell 配置 adb 说会最开始碰到的问题，修正 zshell 环境变量 其实 ，打开 bash 的配置 .bash_profile 对照添加到 .zshrc，然后重启就是了。 我的配置。 12345678910# 用户配置export ANDROID_HOME=$HOME/Library/Android/sdkexport PATH=$PATH:$ANDROID_HOME/toolsexport PATH=$PATH:$ANDROID_HOME/tools/binexport PATH=$PATH:$ANDROID_HOME/platform-toolsexport PATH=$PATH:$ANDROID_HOME/emulatorexport NVM_DIR=&quot;/Users/mcdowell/.nvm&quot;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm 重启 iTerm adb version ,不会在报找不到 adb 了 为啥重启，不用 source .zshrc 每次 zsh 启动都会读取这个 .zshrc 配置文件，所以我们可以把环境变量的配置信息放到这个配置文件中，这样每次启动 zsh 的时候，就会执行一次环境变量配置信息。 而 bash 修改 配置环境变量后， 必须 倒入环境变量配置文件source .bash_profile 才可以生效。 zsh 与 bash 设置环境变量的不同点","categories":[{"name":"工具","slug":"工具","permalink":"http://mcdowell8023.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"脚本","slug":"脚本","permalink":"http://mcdowell8023.github.io/tags/%E8%84%9A%E6%9C%AC/"},{"name":"环境变量","slug":"环境变量","permalink":"http://mcdowell8023.github.io/tags/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"}]},{"title":"使用scrcpy连接安卓手机进行投屏演示","slug":"工具/使用scrcpy连接安卓手机进行投屏演示","date":"2020-04-01T07:40:35.000Z","updated":"2020-05-07T03:00:14.640Z","comments":true,"path":"2020/04/01/工具/使用scrcpy连接安卓手机进行投屏演示/","permalink":"http://mcdowell8023.github.io/2020/04/01/%E5%B7%A5%E5%85%B7/%E4%BD%BF%E7%94%A8scrcpy%E8%BF%9E%E6%8E%A5%E5%AE%89%E5%8D%93%E6%89%8B%E6%9C%BA%E8%BF%9B%E8%A1%8C%E6%8A%95%E5%B1%8F%E6%BC%94%E7%A4%BA/","excerpt":"","text":"需要演示？手机投屏到电脑上？ 快快使用 scrcpy 远程显示/控制 Android 手机 scrcpy-github 安装 要求 Android 5.0 以上，电脑安装 adb，手机启用 adb 调试，开发者模式 windows scrcpy-win64-v1.12.1.zip macOS 12brew install scrcpybrew cask install android-platform-tools # 如果 有了adb 不需要安装 使用 github scrcpy mac 启动 12345# 启动scrcpy# 帮助scrcpy --help windows 启动 1234# 先进到对应目录cd /d d:scrcpy-win64adb connect 172.16.4.37:5555:11330scrcpy.exe -s 10.0.1.158:5555 -m 720 使用 USB 线连接 在手机上启用 USB 调试 adb devices 此时可以看到自己的设备。 scrcpy 即可看到 手机屏幕投射到 电脑 control + c 退出 无法看到自己设备时，查看手机 USB 调试是否打开；PC 端是否安装手机驱动。 windos 需要先进入 使用无线 WiFi 连接 ADB 无线模式调试 打开开发者模式，插线，保证同一网络 插上 USB 线，开启 USB 连接，adb usb 检查插上的设备，adb devices 开启手机服务： adb tcpip 5555（PS：5555 是端口号，可以随意地指定） 拔掉数据线，关于手机 找手机 ip 地址 adb connect 10.0.1.50:5555 [端口可以缺省，需要与 4 一致，默认 5555] # 返回 connected to 10.0.1.50 就表示成功 scrcpy -s 10.0.1.50:5555 -m 720 # 启动 10.0.1.50:5555 的设备 以 720 分辨率 显示【分辨率越大，越卡】 据说，你的手机设备每次重启后，你可能需要重复 1-6 【 🥱 好在我的手机一般不重启 】 安卓手机连接命令 12345678910# 进入对象ip 手机 shell 命令adb -s 10.0.1.50 shell# 进入 adb shell 命令# 查看手机日志logcat ｜ grep &#x27;TAG&#x27;# 过滤 TAG 日志# 安装apk 需要 打开 允许usb 安装adb install -r &lt;apk路径&gt;","categories":[{"name":"工具","slug":"工具","permalink":"http://mcdowell8023.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"调试","slug":"调试","permalink":"http://mcdowell8023.github.io/tags/%E8%B0%83%E8%AF%95/"},{"name":"安卓","slug":"安卓","permalink":"http://mcdowell8023.github.io/tags/%E5%AE%89%E5%8D%93/"}]},{"title":"JavaScript从头来2.1-数据类型","slug":"js基础系列/JavaScript从头来2.1-数据类型","date":"2020-03-28T22:47:24.000Z","updated":"2021-04-01T03:06:56.618Z","comments":true,"path":"2020/03/29/js基础系列/JavaScript从头来2.1-数据类型/","permalink":"http://mcdowell8023.github.io/2020/03/29/js%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97/JavaScript%E4%BB%8E%E5%A4%B4%E6%9D%A52.1-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"本篇 是 JavaScript 从头来 的第二篇。 数据类型，在面试中经常问到。 判断数据类型也是日常开发中的常见操作。由此可见，数据类型是多么重要。 数据类型 ECMAscript 的数据类型 简单的数据类型（基本数据类型）【 5 + 2 种 】 1234字符串型、数值型、布尔型、null型、undefined型、 Symbol型、BigInt型// Symbol 是 ES6 引入了一种新的原始数据类型，表示独一无二的值// BigInt 也是 新增类型 用于表示比较大的 正数// 后两种为ES6新增类型 放在最后说 复杂数据类型（引用类型）【1 种】 123Objecet类型 // 本质由一组无序的名值队组成// 几种基本数据类型以外的都被称为 Objecet 【 其实是个合集，并不单纯指 &#123;&#125; 】// Array、Function 属于 object 类型 ECMAscript 数据类型具有动态性【弱类型】【 变量可以从一个类型变成另外的类型，不存在变量类型的概念 】 基本数据类型 的 实例 被称作《值》，Object 类型的实例 被称为 《对象》。 字符串 字符串字面量（字符串值） 字符串 类型由零个或者多个 16 位 Unicode 字符 组成的字符序列。''、&quot;&quot; 单引号、双引号均可。 转译序列【用于表示非打印字符、或者具有其他用途的字符】 字面量 含义 \\0 空字符 \\ ’ 单引号 \\ &quot; 双引号 \\ \\ 反斜杠 \\n 换行(LF) 【将光标“垂直”移动到下一行，而并不移动到下一行的开头】 \\r 回车(CR)【将光标移动到当前行的开头】 \\v 垂直制表符 \\t 水平制表符 【缩进】 \\b 退格 \\f 换页 \\xXX 用十六进制代码表示 一个字符 如： \\x42 表示 字符 B \\uXXXX 用十六进制代码表示 一个 Unicode 字符 如： \\u03a3 表示 Σ 字符串的运算 字符串一旦创建无法改变、修改变量的字符串需要采取覆盖方式 var str ='qwer'; str = str+'000'; 使用 + 、+= 进行拼接 长字符串拼接 普通拼接 12345678910111213// 使用 + 进行拼接let longString = &#x27;This is a very long string which needs &#x27; + &#x27;to wrap across multiple lines because &#x27; + &#x27;otherwise my code is unreadable.&#x27;longString += &#x27;还可使用+=方式&#x27;// 使用 \\ 连接let longString = &#x27;This is a very long string which needs \\to wrap across multiple lines because \\otherwise my code is unreadable.&#x27; ES6 新增 模版字符串 12var name = &#x27;mcdowell&#x27;console.log(`hi!$&#123;name&#125;`) // hi!mcdowell 字符串的比较 123456789101112131415161718var str1 = &#x27;0&#x27;var str2 = &#x27;22&#x27;var num = str1 + str2 - 0 // 一种从从 字符串转 换为 数字 的方式var str3 = str1 + str2console.log(str1 == str2) // falseconsole.log(str1 === str2) // falseconsole.log(str3 == num) // trueconsole.log(str3 === num) // falsevar name1 = &#x27;jack&#x27;var name2 = &#x27;mcdowell&#x27;var name3 = &#x27;张三&#x27;var name4 = &#x27;李四&#x27;console.log(name2 &gt;= name1) // trueconsole.log(name2 &lt; name1) // falseconsole.log(name2 &gt; name3) // falseconsole.log(name3 &lt; name4) // true 比较运算基于 Unicode 字符的编码值（编码位置）【实际中只有英语单词的比较是有意义的】 英文字母是字典序（abc 顺序） 英文字母的大写 排在小写字母前 字符串 比较第一个字符 数字和符号在英文字母之前（个别符号在字母之后） 中文字符情况更为复杂，基于 《康熙字典》的部首顺序及壁画顺序进行排序的 字符串包装类型（String 类） 字符串对象 String 类 其实就是 String() 方法，我们可以借助 new【 构造函数调用 】 进行实例化 得到 字符串对象 1234var stringObject = new String(&#x27;123&#x27;) // 生成字符串对象 也就是装箱操作typeOf stringObject // objectvar stringValue = stringObject.valueOf() // 得到字符串对象的值 也就是拆箱操作 装箱: 把基本数据类型转换为对应的引用类型的操作称为装箱，把引用类型转换为基本的数据类型称为拆箱 拆箱: 将引用类型对象转换为对应的值类型对象，它是通过引用类型的 valueOf()或者 toString()方法来实现的。如果是自定义的对象，你也可以自定义它的 valueOf()/tostring()方法，实现对这个对象的拆箱。 js 中提供 三种 包装类型，分别为 String 包装类型、Boolean 包装类型、Number 包装类型 摘自：javascript 中的装箱和拆箱操作 字符串型 与 String 类 进行的隐式转换 字符串型 与 String 类 之间存在隐式转换，即 从 字符串型到 String 类 是 装箱操作，从 String 类 到 字符串型 是拆箱操作。 123456789&#x27;123&#x27;.length // 3 要得到字符串的长度，其实是先进行了 隐式转换 装箱操作 才得到的结果// &#x27;123&#x27;其实只是字面量，他自己本身是没有 length 的方法。那么 实际是如何运行的呢// 字符串 ‘123’ 将会先被隐式转换 成 字符串对象var stringObject = new String(&#x27;123&#x27;) // 生成字符串对象 也就是装箱操作// 然后 读取 字符串对象 下的 lengthstringObject.length // 3typeof stringObject 通过 ‘+’ 进行隐式转换 12345678var stringObject = new String(&#x27;123&#x27;) // 生成字符串对象 也就是装箱操作stringObject + &#x27;789&#x27; // &#x27;123789&#x27; 把 字符串对象 进行 隐式转换// 常见使用的隐式转换456 + &#x27;&#x27; // &#x27;456&#x27;// 过程 =&gt; new String(456).valueOf() + &#x27;&#x27; // 把 字符串对象 进行 隐式转换(valueOf()) 后进行拼接 字符串与字符串对象 123456789101112var str1 = new String(&#x27;abc&#x27;)var str2 = new String(&#x27;abc&#x27;)str1 == &#x27;abc&#x27; // truestr2 == &#x27;abc&#x27; // true 在左右两边类型不想等时候，会进行隐式转换成（调用对象的的 valueOf）变成字符串 后进行比较str2 === &#x27;abc&#x27; // false 类型不一样str1 == str2 // false == 虽然字符串相等，但是并非引用了同一个对象， 所以是falsestr1 === str2 // false == 虽然字符串相等，但是并非引用了同一个对象， 所以是false// 实际中不推荐 这样使用str1 + &#x27;&#x27; == str2 + &#x27;&#x27; // truestr1 + &#x27;&#x27; === str2 + &#x27;&#x27; // true 为了避免 字符串 与 字符串对象 混用，造成混乱，使用字符串隐式转换即可满足日常 字符串类 的方法 建议在控制台中输入 new String() 得到 String 进行属性查看 常用方法分类(String.prototype 上的方法) 字符方法 charAt和 charCodeAt 、[] 12345678// charAt 根据 下标 返回 对应位置的 的长度为 1 的字符串，从 0 开始，如果超过了，返回空字符串var stringValue = &#x27;hello world&#x27;console.log(stringValue.charAt(1)) //&quot;e&quot;// charCodeAt 根据 下标 返回 对应位置的 的长度为 1 的字符串 的字符 编码，从 0 开始，如果超过了，返回NaNconsole.log(stringValue.charCodeAt(1)) //返回字符编码&quot;101&quot;// string 有length 自然也有 []方式console.log(stringValue[2]) // &quot;l&quot; 字符串操作方法 拼接 concat 12345// 用于 拼接字符串 实际使用 &#x27;+&#x27; 进行拼接更多var stringValue = &#x27;hello &#x27;var result = stringValue.concat(&#x27;world&#x27;, &#x27;!&#x27;)alert(result) // &quot;hello world!&quot;alert(stringValue) // &quot;hello&quot; 取出新字符串 slice、substr、 substring 取出新字符串 不影响 原来的字符串 123456789101112var stringValue = &#x27;hello world&#x27;// 按照 参数 start 开始至 end 结束 取出新的字符串。如果 start 和 end 是负数，则返回从末尾逆向起数的下标值alert(stringValue.slice(3)) //&quot;lo world&quot;alert(stringValue.substring(3)) //&quot;lo world&quot;alert(stringValue.substr(3)) //&quot;lo world&quot;// 截取到 第七位 但是不包含第七位alert(stringValue.slice(3, 7)) //&quot;lo w&quot;// 截取到 第七位 但是不包含第七位alert(stringValue.substring(3, 7)) //&quot;lo w&quot;// 从3位向后数，截取 7个字符alert(stringValue.substr(3, 7)) //&quot;lo worl&quot; 第一个参数 为 负数： slice()和 substr() 在接收一个负数时，会经过计算 （length + 负数（如：-3））后，进行操作 substring() 直接忽略 负数 为 0，返回全部字符。 第二个参数 为 负数： slice() 从数组尾部开始算起的元素，会经过计算 （length+ 1 + 负数（如：-3））后，进行操作 substring() 直接忽略 负数 为 0, 进行操作（类似余 start 与 end 位置互换） substr() 直接忽略 负数 为 0，返回全空字符。 示例： 1234567var stringValue = &#x27;hello world&#x27;alert(stringValue.slice(-3)) //&quot;rld&quot;alert(stringValue.substring(-3)) //&quot;hello world&quot;alert(stringValue.substr(-3)) //&quot;rld&quot;alert(stringValue.slice(3, -4)) //&quot;lo w&quot;alert(stringValue.substring(3, -4)) //&quot;hel&quot;alert(stringValue.substr(3, -4)) //&quot;&quot; 字符串位置 indexOf()和lastIndexOf() indexOf 从头部 查找字符串返回 index，没找到返回 -1； 第二参数 ，指定 从头部 开始的查找位置 lastIndexOf 从尾部 查找字符串返回 index，没找到返回 -1； 第二参数 ，指定 从尾部 开始的查找位置 12345var stringValue = &#x27;hello world&#x27;alert(stringValue.indexOf(&#x27;o&#x27;)) //4alert(stringValue.lastIndexOf(&#x27;o&#x27;)) //7alert(stringValue.indexOf(&#x27;o&#x27;, 6)) //7alert(stringValue.lastIndexOf(&#x27;o&#x27;, 6)) //4 trim() 返回 去掉首尾 空格 字符串大小写转换 12345678var stringValue = &#x27;hello world&#x27;alert(stringValue.toUpperCase()) //&quot;HELLO WORLD&quot;alert(stringValue.toLowerCase()) //&quot;hello world&quot;// 本地 化的大小写 转换alert(stringValue.toLocaleUpperCase()) //&quot;HELLO WORLD&quot;alert(stringValue.toLocaleLowerCase()) //&quot;hello world&quot; 字符串模式匹配方法 match 接收正则 或者 要匹配的字符串 在字符串内检索指定的值，或找到一个或多个正则表达式的匹配 类似 indexOf() 和 lastIndexOf()，但是它返回指定的值，而不是字符串的位置 [与 RegExp 对象的 exec()相同] 12345var str = &#x27;cat, bat, sat, fat&#x27;// 仅匹配以第一位 的 ，返回含有 index ，值 等信息的特殊数组str.match(/.at/) // [&quot;cat&quot;, index: 0, input: &quot;cat, bat, sat, fat&quot;, groups: undefined]// 全局匹配 是返回全部数组str.match(/.at/g) // [&quot;cat&quot;, &quot;bat&quot;, &quot;sat&quot;, &quot;fat&quot;] search 接收正则 或者 要匹配的字符串 在字符串内检索指定的值，或找到一个正则表达式的匹配 返回 第一次出现的位置，找不到返回 -1 类似 indexOf() 借助 正则 中的 i 实现忽略大小写匹配 12345var str = &#x27;cat, bat, sat, fat&#x27;str.search(&#x27;bat&#x27;) // 5str.search(/.at/) // 0str.search(/.at/g) // 0str.search(/.bt/) // -1 replace 接收两个参数 [0]要替换的 字符串或者正则 ；[1]替换内容 或者 函数返回 的替换内容 用于在字符串中用一些字符替换另一些字符 或替换一个与正则表达式匹配的子串 1234var str = &#x27;cat, bat, sat, fat&#x27;str.replace(&#x27;at,&#x27;123&#x27;) // &quot;c123, bat, sat, fat&quot;str.replace(/.at/,&#x27;123&#x27;) // &quot;123, bat, sat, fat&quot;str.replace(/.at/g,&#x27;$&amp;_123&#x27;) // &quot;cat_123, bat_123, sat_123, fat_123&quot; 更多 split 接收两个参数 [0]要替换的 字符串或者正则 ；[1] 可选参数–指定返回的数组的最大长度 方法用于把一个字符串分割成字符串数组 12345678var str = &#x27;How are you doing today?&#x27;console.log(str.split(&#x27; &#x27;)) // [&#x27;How&#x27;,&#x27;are&#x27;,&#x27;you&#x27;,&#x27;doing&#x27;,&#x27;today?&#x27;]console.log(str.split(&#x27;&#x27;)) // [&quot;H&quot;, &quot;o&quot;, &quot;w&quot;, &quot; &quot;, &quot;a&quot;, &quot;r&quot;, &quot;e&quot;, &quot; &quot;, &quot;y&quot;, &quot;o&quot;, &quot;u&quot;, &quot; &quot;, &quot;d&quot;, &quot;o&quot;, &quot;i&quot;, &quot;n&quot;, &quot;g&quot;, &quot; &quot;, &quot;t&quot;, &quot;o&quot;, &quot;d&quot;, &quot;a&quot;, &quot;y&quot;, &quot;?&quot;]console.log(str.split(&#x27; &#x27;, 3)) // [&quot;How&quot;, &quot;are&quot;, &quot;you&quot;]var htmlStr = &#x27;&lt;p&gt;213&lt;/p&gt;&#x27;htmlStr.split(/\\&lt;|\\&gt;/) // [&quot;&quot;, &quot;p&quot;, &quot;213&quot;, &quot;/p&quot;, &quot;&quot;] localeCompare 用本地特定的顺序来比较两个字符串。 要以本地特定的顺序与 stringObject 进行比较的字符串 返回值 ：如果 stringObject 小于 target，则 localeCompare() 返回小于 0 的数。如果 stringObject 大于 target，则该方法返回大于 0 的数。如果两个字符串相等，或根据本地排序规则没有区别，该方法返回 0 1234var stringValue = &#x27;yellow&#x27;alert(stringValue.localeCompare(&#x27;brick&#x27;)) //1alert(stringValue.localeCompare(&#x27;yellow&#x27;)) //0alert(stringValue.localeCompare(&#x27;zoo&#x27;)) //-1 排序示例： 123456// 将用本地特定排序规则对字符串数组进行排序var str = &#x27;asdfsdwerqvzfvadfas&#x27;.split(&#x27;&#x27;)str.sort(function (a, b) &#123; return a.localeCompare(b)&#125;)// 结果： [&quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;d&quot;, &quot;d&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;f&quot;, &quot;f&quot;, &quot;q&quot;, &quot;r&quot;, &quot;s&quot;, &quot;s&quot;, &quot;s&quot;, &quot;v&quot;, &quot;v&quot;, &quot;w&quot;, &quot;z&quot;] Number 型 在 javascript 中，数值的内部结构为 64 位浮点小数，即时是整数，也是由浮点小数形式存在的。因为所有数值都是浮点小数，所以运行效率多少会有些下降。 不同的方式 表示不同的 字面量 十进制：常见 79 、12 等等。 八进制: 第一位必须是 0，然后是八进制序列（0 ～ 7）,如果大于 7 则被认为是 十进制。 1234567var octNum1 = 070 // 8进制 的 56var octNum2 = 0621 // 8进制 的 401var octNum3 = 079 // 无效的8进制 ---解析为 79// 8进制 转换 为 10进制0621 // =&gt;;(6 * 8) ^ (2 + 2 * 8) ^ (1 + 1 * 8) ^ 0 八进制 字面量在 严格模式下，是无效的，会导致报错 十六进制: 前两位必须是 0x,然后是 16 进制序列（0 ～ 9、A ～ F）[A ～ F 可大写，可小写] 123456var hexNum1 = 0xa // 16进制 的 10var hexNum2 = 0x1f // 16进制 的 31var hrexNum2 = 0x200 // 16进制的 512// 16进制 转换 为 10进制0x200 // =&gt;;(2 * 16) ^ (2 + 0 * 16) ^ (1 + 0 * 16) ^ 0 计算 在进行算数计算的时候，八进制和十六进制表示的数值都会被转换为 十进制数值。 1234567891011121314151617181920// 两个八进制相加071 + 022 // = 75 （结果为 十进制 ）/* 【 计算过程： 57 + 18 = 75 或： 个位：1 + 2 =&gt; 3 十位： 7 + 2 =&gt; 9 ,8进1 余1， 结果是： 0113 （十进制的 75 ） 】 */// 两个十六进制相加0xa2 + 0xff // 417 (结果为 十进制)/* 【计算过程： 个位： 2 + F =&gt; 17，余1 进 1 十位： A + F + 1 =&gt; 26 , 进1 余10， 结果是：0x1A1 （十进制的 417 ）】 */ js 其实不管是整数还是浮点数 都是使用 IEEE754【二进制浮点数算术标准】 进行存储 运算的 浮点数 浮点数必须包含小数点，而且小数点后至少一位。 123var num1 = 1.1var num2 = 1.0var num3 = 0.1 // 有效但是不推荐 由于保存 浮点数值 需要的 内存空间 是保存整数的两倍 ECMAscript 会在某些时候将浮点数转换为 整数。 12var floatNum1 = 1 // 直接转换为 1var floatNum2 = 21.0 // 整数解析为 21 使用科学技术法（用 e 表示），表示极大或极小的数字 数值（整数或者浮点数）e(或 E) 指数（10 次幂的指数） 【表示数值 与 10 次方乘积】 1234563.2145e8 // 等于 32145000045.12356e5 // 等于 45123561e-1 // 等于 0.13e-4 // 等于0.0003 浮点数计算精度问题 由于采用 IEEE754 数据格式 的存储数字的原因, 浮点数计算的数值会产生舍入误差值的问题。【具体戳 JS 0.1+0.2 的理解】javascript 浮点数计算精度最高 17 位小数，进行算数计算时候，精度远远不如整数。 0.1 + 0.2 = 0.30000000000000004 怎样理解 简单来说：计算机在计算时，都是先转换为 二进制后进行计算的，得到结果后，在转换为 10 进制。 刚好 0.1 和 0.2 转为二进制的时候，是个无限的位数，超出了 双精度位数限制（52 为）,进行了取舍，后进行的计算数值。 123450.1 + 0.2 === 0.3 // 输出false 0.1+0.2 的计算结果0.300000000000000004// 永远不要测试某个特定的浮点数值// 正确的比较方法是使用 JavaScript 提供的最小精度值：console.log(Math.abs(0.1 + 0.2 - 0.3) &lt;= Number.EPSILON)//检查等式左右两边差的绝对值是否小于最小精度，才是正确的比较浮点数的方法 IEEE754【二进制浮点数算术标准】 IEEE754 标准包含一组实数的二进制表示法,它由符号位、指数位、尾数位三部分组成。 1符号位(s) * 尾数位(m) * 2^指数位(p) js 采用双精度存储（double precision），占用 64 bit。具体情况如： 123456789101112131415161718// IEEE 754 双精度 二进制 浮点表示法s p指数位（11位） m 尾数位 (共计52位，可表示53位)0 10000000001 010000000000000000000000000000000000000000000000000000// 根据以上数值进行计算(-1)^S*(1.M)*2^(E-1023)// M后面共计50个0 E= (10000000001)2 = (1025)10(-1)^0*(1.01000...)*2^(E-1023=2)// 注意此处 2进制乘法 相当于 进行小数点位移// 1 x 1.01 × 2∧2// 输出 101【输出的结果仍然是2进制，转为10进制是 5】// 指数 为啥 减1023？ 你没看图啊，那是偏移量。// 为啥指数位要减偏移量？ 因为指数也有正负,那么怎么表示？// 将真值映射到正数域数值（移码）。使用移码比较大小，只要高位对齐后，逐一比较就行 意义： 1 位用来表示符号位（s） 11 位用来表示指数(p) 52 位表示尾数(m)：IEEE754 规定，在计算机内部保存有效数字时，默认第一位总是 1，所以舍去，只保留后面的部分。比如保存 1.01，只存 01，等读取的时候再把第一位 1 加上去。所以 52 位有效数字实际可以存储 53 位。 根据 ECMAscript 规范： s 符号为 是 +1 或 -1，m 尾数位 是一个小于 2^53 但不小于 2^52 的正整数，p 指数位 是一个闭区间 -1074 到 971 中的整数。 浮点数 将该数字乘以 2，取出整数部分作为二进制表示的第 1 位；然后再将小数部分乘以 2，将得到的整数部分作为二进制表示的第 2 位；以此类推，直到小数部分为 0。 特殊情况： 小数部分出现循环，无法停止，则用有限的二进制位无法准确表示一个小数，这也是在编程语言中表示小数会出现误差的原因摘自小数用二进制如何表示 12345670.1&gt;&gt; parseInt(0.1*2), parseInt(0.2*2),parseInt(0.4*2),parseInt(0.8*2)......&gt;&gt; 0.0001 1001 1001 1001…（1001无限循环）0.2&gt;&gt; parseInt(0.2*2), parseInt(0.4*2),parseInt(0.8*2),parseInt(0.6*2)......&gt;&gt; 0.0011 0011 0011 0011…（0011无限循环） 然而，js 采用的 双精度 尾数(m) 位数 是有限的（52 位），此时只能模仿十进制进行四舍五入了，但是二进制只有 0 和 1 两个，于是变为 0 舍 1 入。这即是计算机中部分浮点数运算时出现误差，丢失精度的根本原因。 整数 你以为精度丢失，只存在浮点数？ 大于 9007199254740992 的可能会丢失精度。 由于 尾数位最大是 52 位，因此 JS 中能精准表示的最大整数是 Math.pow(2, 53)【安全值为 Math.pow(2, 53)-1】，十进制即 9007199254740992，所以大整数丢失精度的本质原因与浮点数一样。 12345// 实际情况9007199254740992 + 1 // 丢失9007199254740992 + 2 // 未丢失9007199254740992 + 3 // 丢失9007199254740992 + 4 // 未丢失 推荐阅读 从科学记数法到浮点数标准 IEEE 754、IEEE-754 浮点转换器、JS Number 类型数字位数及 IEEE754 标准 数值范围 在计算机中，我们有一定的精度限制。 最大的数字是什么？ 在数学中，你应该是无法给出具体数字。但是在 ECMAscript 中你可以。因为毕竟内存是有限的。而JavaScript 中的 Number 类型 基本 符合 IEEE 754-2008 规定的双精度浮点数规则。 根据 ECMAscript 规范 (s) * (m) * (2^e) ，m 范围 【2^52 - 2^53 】 的正整数，p 指数位 是一个闭区间 -1074 到 971 中的整数 所以。。。 1234567891011121314151617// 能精确表示的整数范围上限,S为1个0，E为11个0，S为53个1;((Math.pow(2, 53) - 1 === Number.MAX_SAFE_INTEGER - // true // 能精确表示的整数范围下限,S为1个1，E为11个0，S为53个1 (Math.pow(2, 53) - 1)) === Number.MIN_SAFE_INTEGER( // true // 能表示的最大数字，S为1个0，E为971，S为53个1 Math.pow(2, 53) - 1 ) * Math.pow(2, 971)) === Number.MAX_VALUE // true// 能表示的最接近于0的正数，S为1个0，E为-1074，S为0Math.pow(2, -1074) === Number.MIN_VALUE // true// [MIN_SAFE_INTEGER, MAX_SAFE_INTEGER] 的整数都可以精确表示，// 但是超出这个范围的整数就不一定能精确表示。这样就会产生所谓的大数精度丢失问题。 Number.MAX_VALUE 能表示的最大正数。最小的负数是 -MAX_VALUE。 Number.MIN_VALUE 能表示的最小正数即最接近 0 的正数 (实际上不会变成 0)。最大的负数是 -MIN_VALUE。 Number.NaN 特殊的“非数字”值。 Number.NEGATIVE_INFINITY 特殊的负无穷大值，在溢出时返回该值。 Number.POSITIVE_INFINITY 特殊的正无穷大值，在溢出时返回该值。 ES6 新增 Number.EPSILON 两个可表示(representable)数之间的最小间隔。[最小精度] Number.MAX_SAFE_INTEGER JavaScript 中最大的安全整数 (2^53 - 1)。 Number.MIN_SAFE_INTEGER JavaScript 中最小的安全整数 (-(2^53 - 1)). JavaScript 中的 Number 类型有 18437736874454810627(即 2^64 - 2^53+3) 个值。 ECMAscript 的 Number 类型基本符合 IEEE 754-2008 规定的双精度浮点数规则，但是 JavaScript 为了表达几个额外的语言场景（比如不让除以 0 出错，而引入了无穷大的概念），规定了几个例外情况： NaN，占用了 9007199254740990，这原本是符合 IEEE 规则的数字； Infinity，无穷大； -Infinity，负无穷 注意：javascript 的数值保存方式，可以保存正 0 和负 0，正 0 和负 0 被认为是相等的。 0/0 返回 NaN 正数/0、负数/-0 返回 Infinity 负数/0、正数/-0 返回 -Infinity 解决 精度问题的方法 借助 Number.EPSILON 进行最小精度判断 先将小数处理为整数，再除以乘积 【有可能超出最大安全值】 通过字符串的方式，模拟计算，进行对应计算。【大部分成熟计算库都使用此方式】 数值转换 number（） 传入 Boolean true 是 1，false 是 0； 传入 undefined 返回 NaN, null 返回 0,什么都不传 返回 0 传入 字符串 纯数字 忽略前导 0，返回十进制数字。16 进制 Oxf1 等数字，转为 十进制数字。 传入 字符串的包含 非数字 非空字符串 [字母符号等] 返回 NaN 传入 对象： 先调用 valueOf()方法，如果返回 结果是 NaN ,继续调用 toString(),依据以上规则返回值 parseInt（） 传入 空字符串、Boolean、undefined、null、对象等均返回 NaN 传入 包含数字的字符串 比较复杂 123456789parseInt(&#x27; 12 3 &#x27;) // 12parseInt(&#x27;1dasd12&#x27;) // 1// 会忽略 字符串 起始位置的空字符串、数字后面的字母、符号、空字符【之后的内容直接被截取】parseInt(&#x27; w1d&#x27;) // NaNparseInt(&#x27; 1.12 &#x27;) // 1 其实取整就是 按照上面规则 一刀切parseInt(&#x27;.12 &#x27;) // NaN// 起始 位置是字母、符号[+、- 正负除外]的 直接返回 NaN 不会忽略前导 0，可能会被按照 八进制或十六进制 进行解析，单推荐传入第二个参数进行使用。 进行 进制 转换，请传入第二参数，基数 1234parseInt(&#x27;10&#x27;, 2) // 2 按照二进制解析parseInt(&#x27;10&#x27;, 8) // 8 按照八进制解析parseInt(&#x27;10&#x27;, 10) // 10 按照十进制解析parseInt(&#x27;10&#x27;, 16) // 16 按照十六进制解析 parseFloat（） 同 parseInt 传入 空字符串、Boolean、undefined、null、对象等均返回 NaN 会忽略 字符串 起始位置的空字符串、数字后面的字母、符号、空字符【之后的内容直接被截取】 传入 字符串 起始 位置是字母、符号[+、- 正负除外]的 直接返回 NaN 传入整数，仍然会返回整数，传入小数仍然返回小数。 忽略前导 0，只进行十进制 解析 借助 运算符进行隐式转换 从 数字字符串 转换 成数字 使用 减法、乘法、除法[-、*、/]: 12345678&#x27;12&#x27; - 0 // 12;&#x27;w12&#x27; - 0 // NaN;&#x27; 12&#x27; * 1 // 12;&#x27;1/2&#x27; * 1 // NaN;&#x27;12&#x27; / 1 // 12;&#x27;w12&#x27; / 1 // NaN; 从数字转为字符串 使用 加法 [ + ] 1212 + &#x27;&#x27; // &#x27;12&#x27;12 + &#x27;0&#x27; // &#x27;120&#x27; 方法： Number.isNaN() / isNaN() 确定传递的值是否是 NaN。默认对传入的 值进行转换后，进行判断isNaN('123')===false;isNaN('blue')===true;isNaN 同样适用于 对象。 Number.parseFloat()/parseFloat() 和全局对象 parseFloat() 一样。 Number.parseInt()/parseInt() 转换为整数 Number.isFinite() / isFinite() 确定传递的值类型及本身是否是有限数。 ES6 新增 Number.isInteger() 确定传递的值类型是“number”，且是整数。 Number.isSafeInteger() 确定传递的值是否为安全整数 ( -(253 - 1) 至 253 - 1 之间)。 Number 类 与 string 类 同样，也存在 Number 类。经过数据类型转换后，数值和数值对象可以被视为等价 通过 new 显示的生成数值对象new Number() Number 类 的方法 建议在控制台中输入 new Number() 得到 Number 进行属性查看，同步理解 函数或者构造函数 Number(value) : 将参数转换为字符串类型 new Number(value) : 得到一个 Sting 实例 Number.prototype 对象的 属性 | 字面量 | 含义 ｜ | | ----------------------------- | ---------------------------------------------------------------------------------------------------- | ---------------------------------------------------------- | | numObj.toExponential(digits) | 以指数表示法（科学计数法）返回该数值字符串表示形式[digits：一个整数，用来指定小数点后有几位数字。] | 123 得到 1.23e+2 | | numObj.toFixed(digits) | 方法使用定点表示法来格式化一个数值[digits：小数点后数字的个数；介于 0 到 20 （包括）之间，默认是 0 ] | — | | numObj.toLocaleString() | 转换为和本地环境想对应的字符串 | — | | numObj.toPrecision(precision) | 转换为小数点形式（科学计数法）的字符串[precision:有效数字–除去小数点以外的位数] | 如，precision 是 6 123=&gt;123.000;precision 是 2,123=&gt;1.2e+2 | Undefined Undefined 类型只有一个值，就是特殊的 undefined。 在声明变了时，不进行初始化的值就是 undefined。 123456789var msg// var name;console.log(msg) // undefined 【只是声明了，未进行初始化负值】console.log(name) // 报错无法执行 【没有进行变量声明而报错】// 奇怪 的现象？？console.log(typeof msg) // undefinedconsole.log(typeof name) // undefined// 不管是为定义还是未声明 都是 无法真正操作的 所以，返回此种情况 是合理的 undefined 可以进行赋值操作【undefined、NaN 和 Infinity 都是全局对象 window 的属性。既然是属性，当然可以赋值。然而这三个属性又是不可写的属性，即它们的的内部特性[[writable]]为 false，所以赋值无效 】 undifined 不是常量不是保留字，你完全可以自定义一个叫做 undefined 的变量或者函数【 非全局作用域 】；比如 var undefined=‘foo’ 12345678910111213//此方法 表明是 undefined 是window 不可写的属性Object.getOwnPropertyDescriptor(window, &#x27;undefined&#x27;)// 2. undefined 全局模式可以赋值 不会报错，但是 赋值不会成功undefined = 11console.log(undefined, &#x27;全局&#x27;)// 3. undefined 可以 非全局作用域 进行赋值 使用function foo() &#123; var undefined = 10 console.log(undefined)&#125;foo() // 打印10 以上 摘自由 ES 规范学 JavaScript(一)：为什么 undefined 可以被赋值，而 null 不可以？ 建议使用 void 0 代替 undefined ? 1234567void 0 === undefined // true/* JavaScript 的代码 undefined 是一个变量，而并非是一个关键字， 这是 JavaScript 语言公认的设计失误之一， 所以，我们为了避免无意中被篡改， 建议使用 void 0 来获取 undefined 值 -- 《重学前端-程劭非（winter）》 */ void 运算符 对给定的表达式进行求值，然后返回 undefined if 判断 通过msg===undefined 或 typeof(msg)===&quot;undefined&quot; 的形式确定变量是否是 undefined；【undefined 是 false !undefined 是 true】 一个函数如果没有使用 return 指定返回值，将会返回一个 undefined 值 Null 类型 Null 类型 只有一个值 null。null 是缺少标识符，表示变量 未指向任何对象【 这就是 typeof null 返回“object” 的原因 】 如果定义变量将来要用来保存对象，初始变量最好是 null。 undefined 实际派生自 null null 是一个字面量[与 true 和 false 类似]。属于 JavaScript 的保留字,不可以赋值 null==undefined ; null!==undefined、 Boolean 类型 Boolean 类型 有两个 字面量，true 和 false。 字面量 true 和 false 区分大小写，与 True 和 False(以及其他形式的大小写)都不是 Boolean，知识标识符。 其他类型转换为 Boolean 使用Boolean()方法 使用!!msg if 条件语句中 自动转换 123var msg = &#x27;hello&#x27;console.log(Boolean(msg), &#x27;Boolean(msg),!!msg&#x27;, !!msg) // true &quot;Boolean(msg),!!msg&quot; true 各类型不同值对应转换规则 数据类型 转换为 true 的值 转换为 false 的值 Boolean true false String 任何非空字符串 空字符串（‘’） Number 非 0 数字 0 和 NaN Object 任何对象 null Undefined –不存在– undefined","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://mcdowell8023.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://mcdowell8023.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"追本溯源","slug":"追本溯源","permalink":"http://mcdowell8023.github.io/tags/%E8%BF%BD%E6%9C%AC%E6%BA%AF%E6%BA%90/"},{"name":"js基础","slug":"js基础","permalink":"http://mcdowell8023.github.io/tags/js%E5%9F%BA%E7%A1%80/"}]},{"title":"JavaScript从头来1.1-基本概念","slug":"js基础系列/JavaScript从头来1.1-基本概念","date":"2020-03-26T22:47:24.000Z","updated":"2020-11-03T06:50:39.418Z","comments":true,"path":"2020/03/27/js基础系列/JavaScript从头来1.1-基本概念/","permalink":"http://mcdowell8023.github.io/2020/03/27/js%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97/JavaScript%E4%BB%8E%E5%A4%B4%E6%9D%A51.1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","excerpt":"","text":"javascript 简介 特点 解释型语言 类似于 c 和 java 的语法结构 动态语言 基于原型的面向对象 字面量的表现能力 函数式编程 JavaScript 组成 浏览器客户端 :核心（ECMAScript）+ 文档对象模型（DOM）+ 浏览器对象模型（BOM） 服务端：核心（ECMAScript）+ 内置宿主对象 ECMAScript 与浏览器没有依赖关系（本身不包含输入、输出定义）。ECMA-262 定义的是语言基础，可以在此基础上构建完善的脚本语言。 具体包含【语法、类型、语句、关键字、保留字、操作符、对象】 表达式和语句的构成 JavaScript 的源代码本质上是一个语句的集合。语句是由语句和表达式所构成的。表达式则由表达式和 运算符所构成。即使在一条语句中包含其他语句，只要对这条被包含的语句继续进行分解， 最终都会到达仅包含保留字、表达式与符号的状态。 html 中的 javascript (script 标签) 将 JavaScript 插入 HTML 的主要方法是使用&lt;script&gt;元素。 关于 script 标签 属性 src: 没有表述 行内代码；有表示加载加载外部 js type: 代替原来的 language 属性，表示语言类型。 浏览器中始终是 text/javascript 如果值是 module,代码会被理解为 ES6 模块，才可以使用 import 和 export 关键字 nomodule: 在不支持 type=“module”【不支持 import 和 export】 的浏览器（IE11）执行的代码 crossorigin（跨源） 基本概念 协议(pro tocal)、域名(domain)、端口(port) 有一个不同的，都视作 跨源（跨域） CORS 元素：【Cross Origin Resource Share】 &lt;script&gt;、&lt;link&gt;、&lt;imag&gt;、&lt;audio&gt;、&lt;video&gt; 配置相关请求的 CORS(跨源资源共享)设置。 默认不使用 CORS。crossorigin= “” 或者不进行设置 ，为 anonymous 配置 crossorigin= “anonymous” 配置文件请求不必设置凭据标志。 crossorigin=&quot;use-credentials&quot;设置凭据 标志，意味着出站请求会包含凭据。 integrity:可选。安全校验值 用于 第三方 资源 提供的散列值 进行计算校验。校验 安全，于确保内容分发网络(CDN)不会提供恶意内容。 关于 script 加载 defer: 不阻塞文档正常加载，但是延迟执行（文档完全被解析和显示 之后再执行）。只对外部脚本文件有效。 【IE7 及一下也可使用】。 async: 异步加载脚本，加载后 立即执行脚本(可能会 阻塞文档加载)。【立即开始下载脚本，但不能阻止页面其他动作，比如下载资源或等待其他脚本加载】src 引入方式有效。 &lt;script type=&quot;module&quot;&gt;&lt;/script&gt; : 使用 defer 方式进行加载 [ 异步加载脚本,延迟到 文档都加载完后 才去执行 ] &lt;script type=&quot;module&quot; async&gt;&lt;/script&gt; : 使用 async 方式进行加载[ 异步加载脚本后，立即执行 ] 没值: 会阻塞文档加载，开始加 脚本，直至 加载并执行完毕后，才会继续执行 文档加载。[通常应该把&lt;script&gt;元素放到页面末尾，介于主内容之后及&lt;/body&gt;标签 之前] 加载优化 预加载 &lt;link rel=&quot;preload&quot; href=&quot;gibberish.js&quot;&gt; MDN 通过 link 标签 rel=&quot;preload&quot;进行内容预加载 关键字和保留字 就有特殊用途的–关键字，如： void break return do case else new var ... 预留的不能用作特殊字符的保留字，如： boolean float native init short ... 标识符 标识符指变量、函数、属性的名字、或者函数的参数。 组合规则： 第一个字符必须是字母、下划线（_）、或者美元( $ ) 其他字母可以是字母、下划线、美元或者数字 驼峰写法： 第一个字母小写 剩下的每个单词首字母大写 必须是除保留字以外的单词。 必须是除 true、false、null 以外的单词。 必须是以 Unicode 的(非空)字符开始，之后接有 Unicode 字符或是数字的单词。 单词的长度并无限制。 习惯上，以下划线(_)开始的标识符会被作为“内部标识符”来使用 字面量 字面量(literal)指的是，在代码中写下这些值之后，将会在运行时直接使用这些值的字面含义。 1234// 字符串字面量&quot;bar&quot;的例子var foo = &#x27;bar&#x27;// 数值字面量0的例子var val0 = 0 名称 具体示例 数值 100 字符串值 “foobar” 布尔值 true null 值 null Object { x:1, y:2 } 数列 [3, 1, 2] 函数 function() { return 0; } 正则表达式 /foo/ 区分大小写 变量、函数名、操作符都区分大小写 严格模式 头部添加' use strict '，表示在严格模式下的执行。 严格执行模式下，执行结果会有很大不同。支持浏览器：IE10+、Firefox4+、Safari5.1+、Opera12+、Chrome 语句 每条语句，分号结尾（;）【 现代项目架构中，不加分号是编译后，统一由脚手架添加 】。 复合语句，使用花括号 （{}）进行代码块分割，明确意图，降低出错情况。 变量的基础 变量的作用是给某一个值或是对象标注名称。ECMAscript 变量是非常松散的（可以保存任何**类型**的数据）。每个变量仅仅只是一个用于存值的占位符。 1234567891011121314151617181920212223// 操作符（关键字） + 变量名var clock // 变量值是： undefinedvar count = 1 // 变量值是： 1 【 等于： var count = undefined； count = 1; 】先声明 后负值dfunction test() &#123; num = 1 // 有意 忽略 var 关键字，的确可以在局部作用域创建一个全局变量。 // 但是不推荐这样使用会导致， 造成不必要的混乱 var isShow = true // 局部变量 console.log(count) // 1 count 是个全局变量&#125;test()console.log(isShow) // 错误 : isShow is not defined 因为 局部变量 无法访问console.log(clockName) // undefined： 变量提升【只会提升变了声明 ，不回提升负值】var clockName = &#x27;littleClock&#x27;// 批量var message = &#x27;hi&#x27;, found = false, age = 29 关于 变量、常量、字面量 的区别 变量、常量是引用，变量值可变，常量值固定。字面量是值 函数基础 函数本身也是一种对象。 正如变量存在的意义是为了调用没有名称的对象，函数名存在的意义是为了调用没有名称的函数。因此，变量名和函数名实质上是相同的。 12345678910// 匿名函数的语法function (参数, 参数, ......) &#123; 函数体&#125;function 函数名 (参数, 参数, ......) &#123; 函数体&#125;var 函数名 = function()&#123; 函数体&#125; 对象的基础 对象特点 属性值可以由函数指定 具备一种称为原型链的构造 对象字面量表达式与对象的使用 123&#123; key: value&#125; key 属性名可以是标识符、字符串值或是数值。value 属性值则可以是任意的值或对象。 属性访问 . 方式用于确定属性的赋值或取值：obj.key=123 []方式用于不确定值的属性[字符串类型]的赋值或取值：123var name = &#x27;key&#x27;obj[name] = 123obj[&#x27;id&#x27;] = 123 new 表达式 new 表达式的作用是生成一个对象。new 之后所写的是函数名,成的对象，其属性能够被 读取。 12var obj = new Object()typeof obj // &quot;object&quot; JavaScript 中没 有类的概念，所以，根据 JavaScript 的语法规则，new 之后所写的是函数名。 就会把该函数作为构造函数来进行调用。 数组的基础 数组是一种用于表达有顺序关系的值的集合的语言结构。在 JavaScript 中，数组并非是一种内建类 型。相对地，JavaScript 支持 Array 类，所以数组能够以 Array 类的实例的形式实现。 12345var arr = [1, 100, 7]arr[1] = 100 // 读取索引值为1的元素var n = 1console.log(arr[n]) // 与a[1]含义相同 200console.log(arr[n + 1]) // 与a[2]含义相同 数组内部元素可以是多种类型 12345var arr = [1, &#x27;23&#x27;, true, null, undefined]arr.push(function () &#123; return 123&#125;)// [1, &quot;23&quot;, true, null, undefined,function()&#123;return 123&#125;] 数组内部元素可以是多维 123var arr = [1, 2, 3]arr.push([4, 5, 6])console.log(arr) // [1, 2, 3,[4, 5, 6]] 条件语句 if-else 语句 12345678// 通过代码块来避免出现容5易使人误解的缩进if (i == 0) &#123; if (j == 0) &#123; console.log(&#x27;i==0 and j==0&#x27;) &#125; else &#123; console.log(&#x27;i==0 and j!=0&#x27;) &#125;&#125; switch-case 语句 1234567891011121314151617181920212223242526// switch-case语句的语法var s = &#x27;foo&#x27;// 可以在switch表达式中使用字符串值。// 可以在case表达式中使用和switch表达式类型不同的值。// s === 0 的值为假，所以将继续进行比较。switch (s) &#123; case 0: console.log(&#x27;not here&#x27;) break // 可以在case表达式中使用含有变量的表达式。 // s === s.length的值为假，所以将继续进行比较。 case s.length: console.log(&#x27;not here&#x27;) break // 可以在case表达式中使用方法调用表达式。 // s === (0).toString()的值为假，所以将继续进行比较。 case (0).toString(); console.log(&#x27;not here&#x27;) break // 还可以在case表达式中书写这样的表达式。 // s === &#x27;f&#x27; + &#x27;o&#x27; + &#x27;o&#x27;为真，所以将执行以下的代码。 case &#x27;f&#x27; + &#x27;o&#x27; + &#x27;o&#x27;: console.log(&#x27;here&#x27;) break // 如果所有的case表达式在等值运算(===)后得到的结果都为假，则执行以下的代码。 default: console.log(&#x27;not here&#x27;) break&#125; 进行相等运算符(===)进行比较 case 标签并没有对代码按块 进行分割的功能。因此在一个 case 标签结束执行之后，并不会跳出 switch 语句，需要 break 循环语句 while 12345678// 使用代码块的话就能很容易地理清语句结构// 循环10次的while语句var i = 0while (i &lt; 10) &#123; console.log(i) i++ return&#125; 使用 break 等来中断循环,continue 跳出当次 要避免出现无限循环，从 while 循环中跳出，可以执行以下操作。 保证在循环过程中条件表达式的值将变为假 在循环内部使用 break 语句 在循环内部抛出异常 do-while 语句 123456// do-while语句的例子do &#123; // 不管是否符合条件， 先执行一次 // 之后，符合条件，继续进入执行 console.log(&#x27;in loop&#x27;)&#125; while (flag) 使用 break 等来中断循环,continue 跳出当次 只要稍加调整，这两种情况也都能通过 while 语句来实现。 如果循环内的语句不执行一次，条件表达式的求值就没有意义的情况 希望确保循环内的语句至少被执行一次的情况 for 循环 123for (var i = 0; i &lt; 10; i++) &#123; // 语句&#125; 可以使用 return、break 等来中断循环,continue 跳过当次 for in 循环 for in 语句是用于枚举对象属性名的循环语句 1234var obj = &#123; x: 1, y: 3, z: 2 &#125;for (var k in obj) &#123; console.log(k)&#125; 注意： 枚举属性的顺序:不是一定的 有一些无法被枚举的属性 由原型继承而来的属性，会被意外枚举 推荐做法： 123456var obj = &#123; x: 1, y: 3, z: 2 &#125;var arr = Object.keys(obj)for (var i = 0; i &lt; arr.lengt; i++) &#123; var name = arr[i] console.log(obj[name])&#125; 跳出循环 break 语句 普通用法 123456789101112131415// 不通过break语句跳出循环的代码示例var flag_loop = truewhile (flag_loop) &#123; 省略 if (跳出循环的条件) &#123; flag_loop = false &#125;&#125;// 通过break语句跳出循环的代码示例while (true) &#123; 省略 if (跳出循环的条件) &#123; break &#125;&#125; 通过标签跳转 借助标签跳转 可以跳出多层循环 1234567891011// 标签的语法规则标签字符串: 语句//eg: 使用标签来同时跳出嵌套的循环outer_loop: while (true) &#123; console.log(&#x27;outer loop&#x27;) while (true) &#123; console.log(&#x27;inner loop&#x27;) break outer_loop &#125;&#125; continue 语句 跳过在此之后本次循环内尚未执行的语句,将会跳转至循环的开头。 123456for (var i = 0; i &lt; 10; i++) &#123; if (i % 2 !== 0) &#123; continue &#125; // do something&#125; return 语句 return 语句会中断函数的处理，并将指定的表达式的值作为函数的返回值返回。如果没有指定表达式，函数的返回值将会是 undefined 值 return 语句","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://mcdowell8023.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://mcdowell8023.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"追本溯源","slug":"追本溯源","permalink":"http://mcdowell8023.github.io/tags/%E8%BF%BD%E6%9C%AC%E6%BA%AF%E6%BA%90/"},{"name":"js基础","slug":"js基础","permalink":"http://mcdowell8023.github.io/tags/js%E5%9F%BA%E7%A1%80/"}]},{"title":"JavaScript从头来1.2-基本概念","slug":"js基础系列/JavaScript从头来1.2-基本概念","date":"2020-03-26T22:47:24.000Z","updated":"2020-08-13T21:46:39.442Z","comments":true,"path":"2020/03/27/js基础系列/JavaScript从头来1.2-基本概念/","permalink":"http://mcdowell8023.github.io/2020/03/27/js%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97/JavaScript%E4%BB%8E%E5%A4%B4%E6%9D%A51.2-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","excerpt":"","text":"异常 throw 语句来抛出异常对象(异常值) 12// throw语句的语法规则throw 表达式 借助 try-catch 抛出 捕捉抛出异常 123456789// try-catch-finally结构的语法try &#123; // 正常 流程&#125; catch (erro) &#123; // 捕捉的异常 throw erro&#125; finally &#123; // 成功、异常 都会 执行&#125; 表达式 表达式由 运算符 和 操作数 组成 运算符 运算符 的优先级 两个操作数的运算符被称为双目运算符，需要在运算符的前后分别书写一个操作数。大部分运算符都是双目运算符，三目运算符有 1 个，其余的都是单目运算符。三目运算符有 3 个操作数，而单目运算符则只有 1 个操作数。 单目运算符又可以根据运算符与操作数的前 后位置关系，分为前置运算符与后置运算符。前置运算符是以“运算符 操作数”的顺序书写的，而后置 运算符则是按照“操作数 运算符”的顺序。 表达式求值 除了含有 &amp;&amp; 运算符、|| 运算符、?: 运算符这三个运算符的情况外，其他的表达式都是首先对操作数进行求值。 操作数按从左至右的顺序求值。 对于函数方法或是构造函数调用表达式的情况，会在调用前对参数从左至右求值。 优先对括号内的表达式求值。 如果在对操作数求值的过程中产生了异常，则不会对剩余的操作数进行求值。 对于函数方法或是构造函数调用表达式的情况，如果在对参数进行求值的过程中发生异常，则不会对剩余的参数进行求值。 算数运算符 +[加法]、-[减法]*[乘法]/[除法]%[取模]、++(前置)++(后置)[自增]、--(前置)、--(后置)[自减]、-(单目)[符号反转]、+(单目)[符号保持不变] ++ 运算符的含义是对操作数加 1。-- 运算符的含义是对操作数减 1。这两个运算符都会重写操作数的值。这类会改写操作数本身的值的运算符，称为破坏性运算符 赋值运算符是另一种有代表性的破坏性运算符 12345678// 前置运算符的行为var n = 10var m = ++nconsole.log(m, n) // n变为了11。++n的值是进行了加法之后的值，所以m为11。 11 11// 后置运算符的行为var n = 10var m = n++console.log(m, n) // n变为了11。++n的值是进行了加法之前的值，所以m为10。 10 11 相等运算符 相等运算 ==,只比进行隐式数据类型转换后的值 是否相等，忽略 两个操作数 本身类型。 全等运算 ===,上来先比较类型是否相等，类型相同后才进行比较，必须是内容一样的，则结果为真。 比较运算符 如果两个操作数都 是数值，则对这两个数值的大小进行比较。如果两个操作数都是字符串型则对字符串值内容的 Unicode 编码进行大小比较。 一方为数值，另一方为可以被转换为数值的数据类型的情况，将其转换为数值类型后再进行大小比较。 如果操作数中含有 NaN 则结果为假。 一方为字符串值，另一方为可以被转换为字符串值的数据类型的情况，将其转换为字符串值后再对字符串值进行大小比较。 操作数中有无法被转换为数值及字符串值的值，或是转换结果为 NaN的情况，运算的结果为假。 in 运算符 指定的属性在指定的对象或其原型链中，则 in 运算符返回 true. 12345678910111213141516171819// 数组var trees = new Array(&#x27;redwood&#x27;, &#x27;bay&#x27;, &#x27;cedar&#x27;, &#x27;oak&#x27;, &#x27;maple&#x27;, null)0 in trees // 返回true3 in trees // 返回true5 in trees // 返回true 只要这个属性确实存在， 仍然返回 true6 in trees // 返回false&#x27;bay&#x27; in trees // 返回false (必须使用索引号,而不是数组元素的值)&#x27;length&#x27; in trees // 返回true (length是一个数组属性)Symbol.iterator in trees // 返回true (数组可迭代，只在ES2015+上有效)// 内置对象&#x27;PI&#x27; in Math // 返回true// 自定义对象var mycar = &#123; make: &#x27;Honda&#x27;, model: &#x27;Accord&#x27;, year: 1998 &#125;&#x27;make&#x27; in mycar // 返回true&#x27;model&#x27; in mycar // 返回true 逻辑运算符 运算符 说明 短路规则 ! 逻辑非(NOT) 无(单目运算符) &amp;&amp; 逻辑与(AND) 若左操作数的值为假，则不再对右操作数进行求值。 || 逻辑或(OR) 若左操作数的值为真，则不再对右操作数进行求值。 &amp;&amp; 运算和 || 运算有一个重要的性质——短路求值。运算前仅会先对左边的操作数进行求值。 1234567891011var n = 1 &amp;&amp; 2console.log(n) // 2var n = 0 &amp;&amp; 2console.log(n) // 0var n = 0 || &#x27;--&#x27;console.log(n) // --var n = &#x27;type&#x27; || &#x27;default&#x27;console.log(n) // type 条件运算符（三目运算符） 条件运算符是唯一的三目运算符。由于三目运算符只有这一个，所以有时也会直接把条件运算符称 为三目运算符。 与 &amp;&amp; 运算符和 || 运算符一样，条件运算符也有短路求值的特性。 基本可以理解为if else的缩写，把?看作 if,:看作else 条件表达式 ? 表达式1 : 表达式2 常用示例 12345678// 这是 一个处理数字 小于两位数时候，的补0 操作函数function formatZero(num) &#123; if (isNaN(num)) &#123; return &#x27;--&#x27; &#125; // 在获得计算结果后，进行返值 return num &gt; 10 ? &#x27;&#x27; + num : &#x27;0&#x27; + num&#125; 位运算符 运算符 说明 &amp; 按位与(AND) | 按位或(OR) ^ 按位异或(XOR) &lt;&lt; 左移 &gt;&gt; 右移(最左位保持原符号不变) &gt;&gt;&gt; 无符号右移(最左位被置为 0) ~ 单目运算符。按位取反，取 1 的补码 123456// 右侧移动 1位 除以2\b^1(2的1次方); 移动 2位 除以 2^2(2的2次方);....72 &gt;&gt; 1 // 36(72/2)72 &gt;&gt; 2 // 18(72/2^2)// 左侧移动 1位 乘以2\b^1(2的1次方); 移动 2位 乘以 2^2(2的2次方);....72 &lt;&lt; 2 // 288 (72*2^2)72 &lt;&lt; 3 // 576 (72*2^3) 赋值运算符 用于对变量赋值的 = 运算符是赋值运算符 123456789var a = 1console.log(a) // 1// 多次赋值 从右到左x = y = z = 0console.log(x, y, z) // 0 0 0z += 1y -= 1console.log(z, y) // 1,-1 new 运算符 new 运算符创建一个用户定义的对象类型 的 实例或具有构造函数的内置对象 的 实例。new 关键字会进行如下的操作： 创建一个空的简单 JavaScript 对象（即{}）； 链接该对象（即设置该对象的构造函数）到另一个对象 ； 将步骤 1 新创建的对象作为 this 的上下文 ； 如果该函数没有返回对象，则返回 this。 123456789function Car(make, model, year) &#123; this.make = make this.model = model this.year = year&#125;const car1 = new Car(&#x27;Eagle&#x27;, &#x27;Talon TSi&#x27;, 1993)console.log(car1.make) delete 运算符 delete 操作符会从某个对象上移除指定属性。成功删除的时候回返回 true，否则返回 false。 注意： delete 对象上没有的属性，依然会返回 true 【成功与否 主要看 Object.defineProperty 设置该属性 的 configurable 是否 true】 123456789101112131415const object1 = &#123;&#125;Object.defineProperty(object1, &#x27;property1&#x27;, &#123; configurable: false, // 如果设为true 就可以 delete object1.property1 返回 true value: 42, writable: false,&#125;)object1.name = &#x27;jack&#x27;object1.tag = nulldelete object1.name // truedelete object1.tag // truedelete object1.id // truedelete object1.property1 // false void 运算符 void 是 undefined 类型的单目运算符。无论向其传递什么操作数，其运算结果都会是 undefined 值。 由于 js 的特性 undefined 不是保留字，容易被篡改，所以建议使用 void 0 代替 undefined 进行类型判断 一个 void 的常见用法 1234567&lt;a href=&quot;javascript:void(document.form.submit())&quot; &gt;发送HTML表单数据但不跳转页面&lt;/a&gt;&lt;!-- 为了阻止标 签 a 跳转页面，需要将 href 属性中表达式的值强制设为 undefined 值。对此最为简单的惯用方法就是通 过 void 运算来实现。 --&gt; 逗号(,)运算符 逗号运算符(,)是一个双目运算符，其作用为依次对其左操作数与右操作数求值。 逗号运算符的运算结果是其右操作数的值，也就是说其结果的类型取决于所使用的操作数 数据类型的判断 本节建议看完 全部 Object 对象章节，再回过头重看一遍 typeof 运算符 typeof 一元运算符，用来返回操作数类型的字符串 ‘undefined’ – 未定义 ‘boolean’ – 布尔值 ‘string’ – 字符串 ‘number’ – 数值 ‘function’ – 函数 ‘object’ – 对象或者 null [ null 被认为是 空对象的引用 ] 技术角度说，函数不是一种数据类型，是对象，但是函数有一些特殊属性。因此需要 将函数 与对象区分开 123456789typeof true // &quot;boolean&quot;typeof &#123;&#125; // &quot;object&quot;typeof typeof 11 // &quot;string&quot;typeof function () &#123;&#125; // &quot;function&quot; -- 由于特殊考虑，确实需要将function 与 object区分开来typeof [1, 2, 3] // &quot;object&quot; -- 可是数组 不如你所预想的那样typeof /abc/g // &quot;object&quot;typeof new RegExp(&#x27;meow&#x27;) // &quot;object&quot; -- 遇到检测数组的同样问题 正如你看到的，typeof 返回的，不一定都是你想看到的。【因为 array、正则表达式、函数等，除了原始值，都是对象】 实际情况一览表： Value Class Type “foo” String string new String(“foo”) String object 1.2 Number number new Number(1.2) Number object true Boolean boolean new Boolean(true) Boolean object new Date() Date object new Error() Error object [1,2,3] Array object new Array(1, 2, 3) Array object new Function(“”) Function function /abc/g RegExp object (function in Nitro/V8) new RegExp(“meow”) RegExp object (function in Nitro/V8) {} Object object new Object() Object object 你可以看到：除了被正常的个数据类型对象外，显示为 object 的还有 js 内置对象 RegExp(正则对象),Array 对象,Error对象,Date 日期对象 那么我们用什么判断类型，数组是数组，正则是正则，字符串是字符串呢？ instanceof 运算符 用法 object instanceof constructor 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。 【看起来可以完美进行类型判断】但是，只有在比较自定义的对象时才有意义。 如果用来比较内置类型用处不大 比较 自定义对象 1234567891011//function Foo() &#123;&#125;function Bar() &#123;&#125;Bar.prototype = new Foo()new Bar() instanceof Bar // truenew Bar() instanceof Foo // true// 如果仅仅设置 Bar.prototype 为函数 Foo 本身，而不是 Foo 构造函数的一个实例Bar.prototype = Foonew Bar() instanceof Foo // false 比较 比较内置类型 12345678910111213141516/abc/g instanceof RegExp // truenew Date() instanceof Date // true&#x27;123&#x27; instanceof Array // false123 instanceof Array // false[] instanceof Array // true(&#123;&#125;) instanceof Array // false // 不加（） 会报错// 然而 你以为完美了？ 不然。。。[] instanceof Object // true/abc/g instanceof Object // true// 比较内置类型new String(&#x27;foo&#x27;) instanceof String; // truenew String(&#x27;foo&#x27;) instanceof Object; // true&#x27;foo&#x27; instanceof String; // false&#x27;foo&#x27; instanceof Object; // false 注意：用来比较内置类型用处不大 基本类型值（undefined,null,‘23df’,123,true） instanceof Object(String、Number) 也都是 false 因为检查原型链会找到 undefined 其实按照用法，要求进行两个对象 进行比较 ，而这种比较方式本身就是错误的 js 所有 对象 都派生 Object ，所以 任何对象 instanceof Object 都是 true !(mycar instanceof Car) 与 !mycar instanceof Car 不同，后者 会先 转换 为 布尔值，然后进行instanceof判断，会一直显示 false 使用 arr instanceof Array判断是不是数组,仅限于在当前 JavaScript 上下文的 Array 对象 相同。 instanceof 操作符应该仅仅用来比较来自同一个 JavaScript 上下文的自定义对象 instanceof 问题在于，它假定了单一的全局执行环境。如果网页中包含多个框架，那实际上就存在两个以上不同的全局执行环境， 从而存在两个以上不同版本的 Array 构造函数。如果你从一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有各自不同的构造函数。 为了解决这个问题，尽量使用 Array.isArray()方法，这个方法的目的是确认某个值是否是数组，而不管它是在哪个全局执行环境中创建的。 支持 Array.isArray()的浏览器：IE9+、Firefox 4+、Safari 5+、Opera 10.5+和 chrome。 那么如何一劳永逸的判断数据类型？ 对象的类定义 其实我们要的，是检测对象的 的内部属性 [[Class]] 的值 （对象的 类定义）； JavaScript 标准文档中定义: [[Class]] 的值只可能是下面字符串中的一个： Arguments, Array, Boolean, Date, Error, Function, JSON, Math, Number, Object, RegExp, String. 为了获取对象的 [[Class]]，我们需要使用定义在 Object.prototype 上的方法 toString。 123456789101112131415161718Object.prototype.toString.call([]) // &quot;[object Array]&quot;Object.prototype.toString.call(&#123;&#125;) // &quot;[object Object]&quot;Object.prototype.toString.call(4) // &quot;[object Number]&quot;Object.prototype.toString.call(&#x27;acdf&#x27;) // &quot;[object String]&quot;// 高级浏览器表现Object.prototype.toString.call(null) // &quot;[object Null]&quot;Object.prototype.toString.call(undefined) // &quot;[object Undefined]&quot;// IE8Object.prototype.toString.call(null) // &quot;[object Object]&quot;Object.prototype.toString.call(undefined) // &quot;[object Object]&quot;// 通用方法 通常不对null undefined 进行判断function is(type, obj) &#123; var clas = Object.prototype.toString.call(obj).slice(8, -1) return obj !== undefined &amp;&amp; obj !== null &amp;&amp; clas === type&#125;is(&#x27;String&#x27;, &#x27;test&#x27;) // trueis(&#x27;String&#x27;, new String(&#x27;test&#x27;)) // true 敲黑板 辨别到底是不是数组的方法 ：使用 Array.isArray 或者 Object.prototype.toString.call 方法 那么为什么是 Object.prototype.toString 而不是直接使用 toString 方法。因为，array 、date 等 对象都是派生自 Object,对其进行实例化的时候，已经改写了 toString 方法。 记住 一劳永逸的的判断 变量类型：Object.prototype.toString.call 参考 1：typeof 和 instanceOf 的区别 参考 2：为什么用 Object.prototype.toString.call(obj)检测对象类型?","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://mcdowell8023.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://mcdowell8023.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"追本溯源","slug":"追本溯源","permalink":"http://mcdowell8023.github.io/tags/%E8%BF%BD%E6%9C%AC%E6%BA%AF%E6%BA%90/"},{"name":"js基础","slug":"js基础","permalink":"http://mcdowell8023.github.io/tags/js%E5%9F%BA%E7%A1%80/"}]},{"title":"vue项目调整兼容IE8+","slug":"vue项目调整兼容IE8+","date":"2019-11-28T06:29:00.000Z","updated":"2020-03-29T10:03:45.659Z","comments":true,"path":"2019/11/28/vue项目调整兼容IE8+/","permalink":"http://mcdowell8023.github.io/2019/11/28/vue%E9%A1%B9%E7%9B%AE%E8%B0%83%E6%95%B4%E5%85%BC%E5%AE%B9IE8+/","excerpt":"","text":"记一次，vue 项目调整兼容 IE8+ 要点 flex 样式兼容 element UI 部分组件兼容 详细 交代说明 公司项目开发接近收尾,突然硬性要求兼容 ie9。项目搭建时，采用 vue2.6 + elementUI + axios,使用大量 es6 语法（Promise），和 flex 布局。 需要面临的问题 elementUI 针对 IE 部分存在兼容问题 axios 针对 IE 下返回表现不同 flex 只支持到 IE10 Promise IE 系（不含除去 Edge） 不支持 基本兼容垫片 babel-polyfill 1npm install --save-dev babel-polyfill 在 webpack config.js 中加入: 123module.exports = &#123; entry: &#123;app: [&#x27;babel-polyfill&#x27;, &#x27;./src/main.js&#x27;]&#125; IE 11 中接口返回值接收失败 查找发现 Axios 返回值 response 的 data 是个字符串的 json。需要转换为 JavaScript 对象，才可正常读取。 代码如下： 1234567891011121314151617181920212223242526272829303132import axios from &#x27;axios&#x27;import config from &#x27;./config&#x27;const Axios = axios.create(config)// 用于转换为 JavaScript对象const looseJsonParse = function(obj) &#123; return Function(&#x27;&quot;use strict&quot;;return (&#x27; + obj + &#x27;)&#x27;)()&#125;// Response 拦截器Axios.interceptors.response.use( response =&gt; &#123; var pathsearch = window.location.pathname + window.location.search if (response) &#123; var res = typeof response.data === &#x27;string&#x27; ? looseJsonParse(response.data) : response.data switch (res.status) &#123; case &#x27;200&#x27;: return res case &#x27;40001&#x27;: console.log(response) return 0 default: return res &#125; &#125; &#125;, error =&gt; &#123; return error &#125;)export default Axios 关于 looseJsonParse 转换为 JavaScript 对象 其实也可使用 JSON.parse() 【 ie8+ 】 虽然可以 eval(‘(’ + obj + ‘)’)，但不建议使用 由于性能和容易被劫持攻击等原因，推荐使用 looseJsonParse 方式 戳这里 插曲：eval 与 JSON.parse() 详细了解？戳这里 JSON.parse 只是格式化 json;要求严格的 json 格式（只能解析属性名是双引号包裹的字符串对象【key、value 都要双引号】，并会忽略换行和空格（值外面））。 eval 函数可将一个 JavaScript 代码字符串求值成特定的对象，解析 json 只是其中一点功能。 eval 解析 json 需要加入’()’ eg: eval(‘(’ + obj + ‘)’) eval 对 josn 的格式没有特殊要求，但是会直接执行里面内容进行运算。（eval 相当于一个执行环境）eg: eval(‘(’ + ‘{data:new Date()}’ + ‘)’) eval 解析 json 需要加入’( )’ 是因为 eval()相当于一个执行环境，当你不加括号的时候，jsonstr1 会被认为是一条复合语句。运行的时候就会逐个字符的解析。 但是加上括号的时候，jsonstr1 就当做一个表达式去运算。从括号开始就被当做了对象进行识别。 IE 9 中接口返回值的 data 为 undefined 查找发现 在 Axios config 中，默认设置了 responseType: ‘json’ 。 ie9 下不支持,返回数据没有 data 字段 解决 注释 // responseType: ‘json’ 就好 IE 中 elementUI 组件 bug NavMenu 导航 组件 移入下拉报错（TypeError 对象不支持此操作） 查找发现 NavMenu 组件默认使用的 hover 方式不被 IE 支持 解决 在对应的 el-menu 加入属性 menu-trigger=“click” mode=“horizontal” 注意： 文档说的很明确，menu-trigger (只在 mode 为 horizontal 时有效) IE 下 table 组件 下表格与表头错位的兼容问题 问题 因为表格宽度未设置 100%，导致计算每列出现几 px 的精度差，最后导致整体样式错乱 解决 全局接入 css 补丁: 1234567891011body .el-table th.gutter &#123; display: table-cell !important;&#125;body .el-table colgroup.gutter &#123; display: table-cell !important;&#125;table &#123; width: 100% !important;&#125; IE 下报错 ：Unhandled promise rejection SyntaxError: 缺少 ‘;’ 或 Unhandled promise rejection SyntaxError: 缺少 ‘）’ 查找发现 vue-chart 出现了兼容问题。 解决 查阅文档 步骤 1： npm i echarts vue-echarts -S 步骤 2：npm i resize-detector -S 步骤 3： 当使用 Vue CLI 3+ 时，需要在 vue.config.js 中的 transpileDependencies 增加 vue-echarts 及 resize-detector，如下： 1234567// vue.config.jsmodule.exports = &#123; transpileDependencies: [ &#x27;vue-echarts&#x27;, &#x27;resize-detector&#x27; ]&#125; 当使用 Vue CLI 2 的 webpack 模板时，需要按下述的方式修改 build/webpack.base.conf.js： 1234567891011&#123; test: /\\.js$/, loader: &#x27;babel-loader&#x27;, - include: [resolve(&#x27;src&#x27;), resolve(&#x27;test&#x27;)] + include: [ + resolve(&#x27;src&#x27;), + resolve(&#x27;test&#x27;), + resolve(&#x27;node_modules/vue-echarts&#x27;), + resolve(&#x27;node_modules/resize-detector&#x27;) + ]&#125; 还有一种方案，直接使用 echarts 兼容样式问题 问题 最早使用了大量的 flex 布局，导致 IE9 无法正常显示。 解决 在 index.html 中借助 “&lt;!–[if IE 9]&gt;” 来引入针对 IE9 的样式补丁，如下： 1234567891011121314151617&lt;!--[if IE 9]&gt; &lt;style&gt; .flex-row-between &gt; :nth-child(1) &#123; float: left; &#125; .flex-row-between &gt; :nth-child(2) &#123; float: right; &#125; img &#123; vertical-align: middle; &#125; &lt;/style&gt;&lt;![endif]--&gt;&lt;!-- 或者，也比较建议借助link 引入补丁样式 --&gt;&lt;!--[if IE 9]&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;static/compatible/forIE9.css&quot; /&gt;&lt;![endif]--&gt; IE9、10、11、edge 下 头像裁剪上传 报错（提示对象或方法未定义） 由于此处代码是同事写的，屡了下流程： 通过 点击 label 标签 触发 隐藏 input file 控件，选取图片; 通过 FileReader 读取文件 使用 FileReader.readAsArrayBuffer() 得到 blob 对象; 使用 window.URL.createObjectURL 得到 dataUrl 喂给 vue-cropper 组件进行图片裁剪; 从 vue-cropper 裁剪后，返回得到 base64，通过 new File() 转换为 file 文件; // 或者 blob 对象 使用 formData 发送给后台; 后台返回成功后，修改页面头像，流程完毕。 了解到都使用哪些东西，还需要了解下基本知识。 MDN 下了 File、 blob、URL.createObjectURL 技术实现采用了一些比较高级的 api ，对于 IE 来讲不是太友好，总结如下： 浏览器 File blob createObjectURL new File(转换为 File 文件) IE9 NO NO NO NO IE10 YES YES YES NO IE11 YES YES YES NO Edge YES YES YES NO 看起来情况不太乐观。那么，一个一个解决。 IE9 下头像上传 从上面看来，IE9 不支持高级 api ，原来的整套应该全部不适用。 果然，从 第一步 获取文件就在报错。 input file 控件 的 target.files 是 udefined。难道无法拿到文件？ 补习了下： IE9 获取 File 文件对象 前端图片预览，上传前预览，兼容 IE7、8、9、10、11，Firefox，Chrome 得到如下信息： 低版本 IE 由于 JS 安全问题，不允许 JS 访问本地文件,所以无法获取 files 对于低版本的 IE 可以使用 ActiveXObject 获取文件对象, 但是默认情况下 ActiveXObject 为不可用的, 所以要想使用此对象要先启用设置, 即: Tools(工具) / Internet options(选项) / Security(安全) / Custom level(自定义级别) 找到&quot;Initialize and script ActiveX controls not marked as safe for scripting&quot; 设置为&quot;Enable(not secure)&quot;即可. 获取文件路径 出于安全性的考虑，低版本 IE 上传文件时屏蔽了真实的本地文件路径, 以 C:\\fakepath**取而代之, 所以默认情况下通过 fileEle.value 不能获取到 文件的真实路径. 如果想获取真实路径, 有两种方式: 通过设置 IE 的安全设置, 即: Tools(工具) / Internet options(选项) / Security(安全) / Custom level(自定义级别) 找到&quot;Include local directory path when uploading files to a server&quot; 设置为的&quot;Enable&quot; 使用 JS 获取, 即: fileEle.select().blur(); var filePath = document.selection.createRange().text; 然后试了下 在 IE 下使用 ActiveXObject 读取文件。然后读取文件还要设置【⊙﹏⊙b 汗】，放弃。 与产品沟通了下。本着华丽升级，优雅降级的原则【好吧，就是我也没有办法】。IE9 下可以取消裁剪。 先科普下 兼容 ie9 文件上传，解决 ie9 下提示下载或保存 HTML5 file 对象和 blob 对象的互相转换 js blob 转 File Convert blob to file HTML 利用 meta 标签设置 IE 文档模式及相关知识拓展","categories":[{"name":"项目改造","slug":"项目改造","permalink":"http://mcdowell8023.github.io/categories/%E9%A1%B9%E7%9B%AE%E6%94%B9%E9%80%A0/"}],"tags":[{"name":"兼容","slug":"兼容","permalink":"http://mcdowell8023.github.io/tags/%E5%85%BC%E5%AE%B9/"},{"name":"vue","slug":"vue","permalink":"http://mcdowell8023.github.io/tags/vue/"}]},{"title":"docker笔记-基础篇","slug":"工具/docker笔记-基础篇","date":"2019-10-28T02:24:19.000Z","updated":"2020-04-22T08:24:05.227Z","comments":true,"path":"2019/10/28/工具/docker笔记-基础篇/","permalink":"http://mcdowell8023.github.io/2019/10/28/%E5%B7%A5%E5%85%B7/docker%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80%E7%AF%87/","excerpt":"","text":"本文仅以前端视角，接触使用 docekr。认识较为肤浅，大神请绕行。 关于 Docker Docker 是啥 Docker 主要用途 Docker 中的概念 安装 慢？！修改镜像源地址 基本操作 镜像操作 检索拉取镜像 新增 镜像 删除 镜像 修改 镜像 名称 查看 镜像 导入、导出、上传 镜像 容器操作 新增容器 删除 容器 修改 容器 状态 进入 容器 查看 容器 器与主机之间的数据拷贝 导入、导出 容器 关于 Docker Docker 是啥 Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。它是目前最流行的 Linux 容器解决方案。 Docker 主要用途 提供一次性的环境。比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。 提供弹性的云服务。因为 Docker 容器可以随开随关，很适合动态扩容和缩容。 组建微服务架构。通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。 以上摘自阮老师博客 Docker 中的概念 镜像（image）: 镜像中包含有需要运行的文件。镜像用来创建 container，一个镜像可以运行多个 container；镜像可以通过 Dockerfile 创建，也可以从 Docker hub/registry 上下载。 容器（container）: 容器是 Docker 的运行组件，启动一个镜像就是一个容器，容器是一个隔离环境，多个容器之间不会相互影响，保证容器中的程序运行在一个相对安全的环境中。 仓库（repository）: 共享和管理 Docker 镜像，用户可以上传或者下载上面的镜像，官方地址为 https://registry.hub.docker.com/（类似于 github 对源代码的管理），也可以搭建自己私有的 Docker registry。 以上摘自Ant Design Pro 的 Docker 部署方式 从我的角度，使用 docker 常常是要解决宿主依赖环境的问题。比如： 我是个前端开发从业者，可能有些时候需要在本地 查看 打包编译后的项目真实表现。以前需要本地安装一个 Nginx 配好文件，然后启动。现在，只需要编写好 dockerfile 文件，直接输入命令，就可以在本地查看项目。 再者，搭建较为复杂的环境（依赖因为网络等问题过于缓慢），不同开发者需要安装很多东西，不便捷。如，搭建一个 gitbook 文档项目（支持多个文档），从 nodejs ,gitbook, gitbookcli 等比较多的依赖全局安装后，还需要安装 gitbook 的插件（比较慢，而且还没有较快的国内镜像），才可本地启动。毕竟项目本身只是辅助编写文档，因为环境问题给团队带来困扰，就得不偿失了。 如果，将项目的依赖环境做成镜像，放到自己的内部服务器上，每个需要启动项目的人直接使用 docker 镜像，那么基本无痛启动项目。 安装 安装系统推荐使用 Mac 或者 Linux。 Windows 不建议使用。《菜鸟教程》的 Docker Windows 安装中说的 Docker toolbox（老黄历） 已经无法使用了。官方推荐 安装 Docker desktop，需要系统是专业版的。（而且折腾一番，及时能用，跑别人写的 Dockerfile 还会碰到问题。过于折腾，本末倒置。） Mac 或 Windows 安装软件地址 安装教程： Mac 安装 ubuntu 安装 Windows 安装 1234567# 查看版本 验证成功docker version# 把用户加入 Docker 用户组 避免每次命令都输入sudosudo usermod -aG docker $USER# 启动一个Nginx 验证效果 正常浏览器输入http://localhost/即可访问docker run --detach --publish=80:80 --name=webserver nginx 慢？！修改镜像源地址 Docker 修改镜像源地址 如果是 dockerDesktop 进入设置，找到 Daemon 选项，修改 registry-mirrors 选项为：'http://hub-mirror.c.163.com’ [这个是网易的加速镜像]，然后 apply &amp;&amp; start insecure registry 一般 是公司搭建的私服使用 基本操作 镜像操作 检索拉取镜像 1234# 1. 检索镜像 或去 &lt;https://hub.docker.com&gt; 进行搜索docker search &lt;Images Name&gt;# 2. 从仓库中拉取 镜像 到本地docker pull &lt;Images Name:tag-缺省为latest&gt; 非官方下载 需要加上 仓库地址。 如从网易蜂巢的镜像源来下载 ubuntu:18.04 镜像，可以使用如下命令，此时下载的镜像名称为 hub.c.163.com/public/ubuntu:18.04 新增 镜像 根据现有容器生成镜像 12345678# OPTIONS# -a: 作者信息；# -c: 提交时执行dockerfile指令，包含CMD等# -m: 提交消息# -p: 提交暂停容器运行docker commit [OPTIONS] CONTAINER [镜像名称[:TAG]]# 常用方式 填写信息 作者 镜像名称（不包含大写）docker commit -m&#x27;提交消息&#x27; -a &#x27;作者&#x27; &lt;容器ID&gt; &lt;Images Name:tag&gt; 本地模版导入 123456# OPTIONS# -c: 提交时执行dockerfile指令，包含CMD等# -m: 提交消息docker import [OPTIONS] file|URL|- &lt;Images Name:tag&gt;# eg:cat exampleimage.tgz | docker import - exampleimagelocal:new 基于 dockerfile 创建 12345678910# 编写好 dockerfile 后 进行build# OPTIONS# --file , -f Dockerfile的名称（默认为“ PATH / Dockerfile”）# --tag , -t 名称以及“ name：tag”格式的标签（可选）docker build [OPTIONS] &lt;Dockerfile的 PATH | URL | - &gt;# eg:# 使用URL github.com/creack/docker-firefox 的 Dockerfile 创建镜像。docker build github.com/creack/docker-firefox# 使用根目录下的 Dockerfile 创建名称为 lanjiang/gitbook 的镜像docker build -t lanjiang/gitbook . 删除 镜像 docker rmi 删除 123456# 删除 镜像 (没有使用该镜像的容器 才可删除，不推荐强制删除)docker rmi [-f: 强制删除] &lt;Images Name/ids&gt;# 筛选包含 none 的镜像删除docker rmi $(docker images | grep &quot;none&quot; | awk &#x27;&#123;print $3&#125;&#x27;)# 删除全部镜像docker rmi $(docker images -a -q) docker image prune 清除没有被使用的镜像 123456# 清除没有被使用的镜像# OPTIONS:# -a 删除所有无用镜像（不光临时镜像）；# -filter filter:只清理给定过滤的镜像；# -f,-force:强制删除docker image prune [OPTIONS] 修改 镜像 名称 12# 给镜像添加标签docekr tag &lt;Images Name/id&gt; &lt;new Images Name&gt; 查看 镜像 12345# 查看 本地镜像docker images / docker image ls# 查看 本地全部镜像（包含临时镜像）docker images -a 导入、导出、上传 镜像 123456# 镜像 导出 和 载入docker save -o &lt;导出名称&gt; &lt;Images Name:tag&gt;# 将镜像 node 生成 /Users/mcdowell/Downloads/ 下的dockderApp.tardocker save -o /Users/mcdowell/Downloads/dockderApp.tar node# ordocker save node &gt; /Users/mcdowell/Downloads/dockderApp11.tar 1234# 将/Users/mcdowell/Downloads/ 下的tf-keras.tar 镜像 导入镜像docker load -i /Users/mcdowell/Downloads/tf-keras.tar# ordocker load &lt; /Users/mcdowell/Downloads/tf-keras.tar 12# 上传镜像docker push [OPTIONS] NAME[:TAG] 123456789# eg:# 本地生成镜像docker commit c16378f943fe rhel-httpd# 给刚生成的镜像打上 源标签docker tag rhel-httpd registry-host:5000/myadmin/rhel-httpd# 上传镜像docker push registry-host:5000/myadmin/rhel-httpd# 如果是官网仓库 （官方仓库省略源地址）docker push myadmin/rhel-httpd 容器操作 新增容器 新建 123456789101112131415161718192021222324252627# 新建 容器（默认是停止的）docker create &lt;Images Name:version /ID&gt;# 用 XX镜像 新建容器 并启动 （ docker create + docker start ）# OPTIONS 常用说明# -d: 后台运行容器，并返回容器ID；# -i: 以交互模式运行容器，通常与 -t 同时使用；# -P: 随机端口映射，容器内部端口随机映射到主机的高端口# -p: 指定端口映射，格式为：主机(宿主)端口:容器端口# -t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；docker run [OPTIONS] &lt;Images Name:version&gt; [COMMAND] [ARG...]# 用 node 镜像 以交互模式终端 新建容器 并启动docker run -it node bash# 用 ubuntu:18.04 镜像 以交互模式终端 新建容器 并启动docker run -it ubuntu:18.04 /bin/bash# 进入交互模式 使用ctrl+d 或者 exit 退出# 用 lanjiang/gitbook镜像 新建容器 并启动 映射到 80 端口docker run -p 80:80 lanjiang/gitbook# 用 nginx镜像 以守护进行（后台运行）的方式 新建容器 并启动 映射到 80 端口 --默认返回ID号docker run -d -p 80:80 nginx# 使用docker镜像nginx:latest 以后 随机端口 台模式 启动一个容器,并将容器命名为mynginx【需要使用docker port 才可访问】docker run -P -d --name mynginx nginx:latest 删除 容器 docker rm 删除 12345678# 删除容器 id可以是多个 （容器必须终止才能删除）docker rm &lt;IDs&gt;# 筛选包含 gitbook 的容器删除docker rm $(docker ps -a|grep gitbook|awk &#x27;&#123;print $1&#125;&#x27;)# 删除 全部容器docker rm $(docker ps -a -q) docker container prune 删除 12345# 删除暂停的容器# OPTIONS# --filter 提供过滤器值（例如&#x27;until =&#x27;）# --force , -f 强制删除，不提示docker container prune [OPTIONS] 修改 容器 状态 启动、重启 12345# 启动 容器docker start &lt;Images Name:version /ID&gt;# 重启 容器docker restart &lt;ID&gt; 暂停\\恢复 容器 (保存容器状态） 1234# 暂停 容器docker pause &lt;ID&gt;# 恢复 容器docker unpause &lt;ID&gt; 终止容器 12345# 终止容器 id可以是多个 kill 也可以docker stop &lt;IDs&gt;# 筛选包含 gitbook 的容器终止docker stop $(docker ps -a|grep gitbook|awk &#x27;&#123;print $1&#125;&#x27;) 进入 容器 docker attach 进入 容器 12345# 默认 CTRL-c不退出当前终端而是 给容器内 程序执行docker attach [OPTIONS] &lt;container Name/ID&gt;# 使用 --sig-proxy=false 避免上述问题docker attach --sig-proxy=false mynginx# 缺点：多个窗口执行时，一个窗口阻塞，其他窗口无法执行 docker exec 进入 容器 1234567891011# 使用 exec 进入容器#OPTIONS说明：# -d :分离模式: 在后台运行# -i :即使没有附加也保持STDIN 打开# -t :分配一个伪终端docker exec [OPTIONS] &lt;container Name/ID&gt; [\b命令] [ARG...]# 在容器 mynginx 中以交互模式执行容器内 /root/blue.sh 脚本:docker exec -it mynginx /bin/sh /root/blue.sh# 在运行的容器中 以 以交互模式终端 执行 bash 命令docker exec -it &lt;container Name/ID&gt; /bin/bash 查看 容器 查看本地容器 12345678# 输出 ID容器的 日志docker logs &lt;ID&gt;# 查看 运行的 容器docker ps# 查看全部容器（包含运行和暂停的）docker ps -a # -q:只显示ID 查看容器内部信息 123456789101112# 查看容器详情docker inspect &lt;container Name/ID&gt;# 查看容器内 进程（容器需要启动）docker top &lt;container Name/ID&gt;# 查看统计信息 （cpu 内存 存储 网络使用情况）docker stats &lt;container Name/ID&gt;# 查看系统变更docker diff &lt;container Name/ID&gt;# 查看 容器 端口映射docker port &lt;container Name/ID&gt; 器与主机之间的数据拷贝 12345678# 容器与主机之间的数据拷贝docker cp &lt;path&gt; &lt;path&gt;# 将主机/www/blue目录拷贝到容器63d47d7c0d4c的/www目录下。docker cp /www/blue 63d47d7c0d4c:/www/# 将主机/www/blue目录拷贝到容器 63d47d7c0d4c中，目录重命名为www(此处无斜杠))docker cp /www/blue 63d47d7c0d4c:/www# 将容器 63d47d7c0d4c 的 /www 目录拷贝到主机的 /tmp 目录中。docker cp 63d47d7c0d4c:/www /tmp/ 导入、导出 容器 123456# 容器导出docker export -o tf-keras-33f6c8359187.tar &lt;container Name/ID&gt;# ordocker export 33f6c8359187 &gt; tf-keras-33f6c8359187.tar# 导入docker import tf-keras-33f6c8359187.tar 与镜像导出（docker save）比较： 容器快照文件 将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积更大","categories":[{"name":"工具","slug":"工具","permalink":"http://mcdowell8023.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://mcdowell8023.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Docker","slug":"Docker","permalink":"http://mcdowell8023.github.io/tags/Docker/"}]},{"title":"浏览器全屏api--fullScreen","slug":"web/浏览器全屏api-fullScreen","date":"2019-09-24T07:40:35.000Z","updated":"2020-03-29T10:00:02.803Z","comments":true,"path":"2019/09/24/web/浏览器全屏api-fullScreen/","permalink":"http://mcdowell8023.github.io/2019/09/24/web/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%A8%E5%B1%8Fapi-fullScreen/","excerpt":"","text":"fullScreen 浏览器 全屏 api 本文转载 Fullscreen API 工作开发中遇到需要浏览器 全屏。 查询 api 后，决定使用 requestFullscreen，但是 api 存在兼容问题。 借助大佬的总结： 启动全屏模式 12345678910111213141516// 处理兼容性 调用 全屏apifunction launchIntoFullscreen(element) &#123; if (element.requestFullscreen) &#123; element.requestFullscreen() &#125; else if (element.mozRequestFullScreen) &#123; element.mozRequestFullScreen() &#125; else if (element.webkitRequestFullscreen) &#123; element.webkitRequestFullscreen() &#125; else if (element.msRequestFullscreen) &#123; element.msRequestFullscreen() &#125;&#125;// 开启全屏 模式 谷歌浏览器 、安卓手机 亲测可用launchIntoFullscreen(document.documentElement) // 整个页面launchIntoFullscreen(document.getElementById(&#x27;videoElement&#x27;)) // 或者任意对象 退出全屏模式 12345678910// 退出全屏function exitFullscreen() &#123; if(document.exitFullscreen) &#123; document.exitFullscreen(); &#125; else if(document.mozCancelFullScreen) &#123; document.mozCancelFullScreen(); &#125; else if(document.webkitExitFullscreen) &#123; document.webkitExitFullscreen(); &#125;&#125; 全屏属性和事件 document.fullScreenElement：已推送到全屏状态的元素。 document.fullScreenEnabled：说明当前是否启用了全屏。 123456789/* 兼容写法 */var fullscreenElement = document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElementvar fullscreenEnabled = document.fullscreenEnabled || document.mozFullScreenEnabled || document.webkitFullscreenEnabled 实际使用 12345678910111213// 添加事件监听document.addEventListener(&#x27;fullscreenchange&#x27;, function(e) &#123; console.log(&#x27;fullscreenchange event! &#x27;, e)&#125;)document.addEventListener(&#x27;mozfullscreenchange&#x27;, function(e) &#123; console.log(&#x27;mozfullscreenchange event! &#x27;, e)&#125;)document.addEventListener(&#x27;webkitfullscreenchange&#x27;, function(e) &#123; console.log(&#x27;webkitfullscreenchange event! &#x27;, e)&#125;)document.addEventListener(&#x27;msfullscreenchange&#x27;, function(e) &#123; console.log(&#x27;msfullscreenchange event! &#x27;, e)&#125;) 全屏 CSS 1234567891011121314151617181920212223242526272829303132333435:-webkit-full-screen &#123; /* properties */&#125;:-moz-full-screen &#123; /* properties */&#125;:-ms-fullscreen &#123; /* properties */&#125;:full-screen &#123; /*pre-spec */ /* properties */&#125;:fullscreen &#123; /* spec */ /* properties */&#125;/* deeper elements */:-webkit-full-screen video &#123; width: 100%; height: 100%;&#125;/* styling the backdrop*/::backdrop &#123; /* properties */&#125;::-ms-backdrop &#123; /* properties */&#125; 实例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt; &lt;title&gt;全屏api测试页面&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div style=&quot;padding:20px;&quot;&gt; &lt;button onclick=&quot;launchFullscreen(document.documentElement);&quot; class=&quot;sexyButton&quot; &gt; 启动全屏 &lt;/button&gt; &lt;button onclick=&quot;exitFullscreen();&quot; class=&quot;sexyButton&quot;&gt;关闭全屏&lt;/button&gt; &lt;button onclick=&quot;dumpFullscreen();&quot; class=&quot;sexyButton&quot;&gt; 转储全屏属性数据 &lt;/button&gt; &lt;/div&gt; &lt;!-- 谷歌浏览器 、安卓手机 亲测可用 --&gt; &lt;style&gt; /* 全屏后 样式 */ :-webkit-full-screen &#123; background: pink; &#125; :-moz-full-screen &#123; background: pink; &#125; :-ms-fullscreen &#123; background: pink; &#125; :full-screen &#123; /*pre-spec */ background: pink; &#125; :fullscreen &#123; /* spec */ background: pink; &#125; &lt;/style&gt; &lt;script&gt; // 处理兼容性 调用 全屏api function launchFullscreen(element) &#123; if (element.requestFullscreen) &#123; element.requestFullscreen() &#125; else if (element.mozRequestFullScreen) &#123; element.mozRequestFullScreen() &#125; else if (element.webkitRequestFullscreen) &#123; element.webkitRequestFullscreen() &#125; else if (element.msRequestFullscreen) &#123; element.msRequestFullscreen() &#125; &#125; // 退出全屏 function exitFullscreen() &#123; if (document.exitFullscreen) &#123; document.exitFullscreen() &#125; else if (document.mozCancelFullScreen) &#123; document.mozCancelFullScreen() &#125; else if (document.webkitExitFullscreen) &#123; document.webkitExitFullscreen() &#125; &#125; function dumpFullscreen() &#123; console.log( &#x27;document.fullscreenElement is: &#x27;, document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement ) console.log( &#x27;document.fullscreenEnabled is: &#x27;, document.fullscreenEnabled || document.mozFullScreenEnabled || document.webkitFullscreenEnabled || document.msFullscreenEnabled ) &#125; // 添加事件监听 document.addEventListener(&#x27;fullscreenchange&#x27;, function(e) &#123; console.log(&#x27;fullscreenchange event! &#x27;, e) &#125;) document.addEventListener(&#x27;mozfullscreenchange&#x27;, function(e) &#123; console.log(&#x27;mozfullscreenchange event! &#x27;, e) &#125;) document.addEventListener(&#x27;webkitfullscreenchange&#x27;, function(e) &#123; console.log(&#x27;webkitfullscreenchange event! &#x27;, e) &#125;) document.addEventListener(&#x27;msfullscreenchange&#x27;, function(e) &#123; console.log(&#x27;msfullscreenchange event! &#x27;, e) &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"拓展","slug":"拓展","permalink":"http://mcdowell8023.github.io/categories/%E6%8B%93%E5%B1%95/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://mcdowell8023.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"api","slug":"api","permalink":"http://mcdowell8023.github.io/tags/api/"}]},{"title":"ant-design踩坑：Cascader级联选择","slug":"ant-design踩坑-Cascader级联选择","date":"2019-09-03T11:33:33.000Z","updated":"2020-03-29T09:59:54.841Z","comments":true,"path":"2019/09/03/ant-design踩坑-Cascader级联选择/","permalink":"http://mcdowell8023.github.io/2019/09/03/ant-design%E8%B8%A9%E5%9D%91-Cascader%E7%BA%A7%E8%81%94%E9%80%89%E6%8B%A9/","excerpt":"","text":"Cascader 级联选择 遇到的问题 要点 级联选择 数据中 isLeaf: false 可以控制是否选中【false 表示不选中】，触发 loadData 函数 级联选择 数据中 如果当前层不是最终级【就是你要 id 的那层】，children 一定不能为[],否则会导致组件选中错误层级，不会触发 loadData 函数 详细 交代说明 公司开发后台管理系统，涉及一个地级区域选择的功能，实现效果如下 后台给的接口是根据参数查询省，然后市…,如下 查看官网文档 通过官网示例，了解到 采用 动态加载选项 示例的方式，使用 loadData 实现动态加载选项。 按照官网的介绍，结合实际接口，我们需要 每次动态修改 根据返回 数据进行 数据拼接。 编码 当然后台数据返回的字段与组件预制不同，我们可以借助 fieldNames 属性进行自定义字段。 编码 测试组件 时候，你会发现点击第一层的数据就会直接选中【我们要的是最后一层，通信商的 id】。查阅属性说明未果。但是通过示例后发现，数据中 isLeaf: false 可以控制是否选中，从而触发 loadData。 貌似准备就绪。然后，愉快的编码 点击非 type 是 3 的一层，进行接口调用 1234567891011121314151617// Cascader loadData 事件 函数 查询数据const cascaderLoadData = selectedOptions =&gt; &#123; // 点击得到的 一级 或 二级 数据 const targetOption = selectedOptions[selectedOptions.length - 1] const &#123; id, type &#125; = targetOption targetOption.loading = true const newType = type + 1 if (type !== 3) &#123; // 一级 或 二级 数据 // 这里是调用 查询地区接口的函数 getDict(&#123; [newType === 2 ? &#x27;regionId&#x27; : &#x27;cityId&#x27;]: id, webId: id, type: newType &#125;) &#125;&#125; 数据拼接,上代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// 这里是 得到后台返回数据 在 reducers 的 数据动态拼接处理// 提供 Cascader optionssaveVPNAddressDict(state, action) &#123; const &#123; params: &#123; type, webId &#125;, res, &#125; = action.payload; const &#123; VPNAddressDict &#125; = state; const pushList = (arr, typeNum) =&gt; &#123; return arr ? arr .map(item =&gt; &#123; if (!item) &#123; return null; &#125; return &#123; ...item, loading: false, isLeaf: typeNum === 3, // 用于控制非 第三层 不能选 children: null, &#125;; &#125;) .filter(item =&gt; item) : []; &#125;; let dicts = []; const dict = pushList(res, type); // 基本思路就是： 根据type 确定层级 当前数据该是第几层 根据 webId 找到应该对应的 数据对象 switch (type) &#123; case 1: // 查询省数据 dicts = [...dict]; break; case 2: // 查询市数据 dicts = VPNAddressDict.map(item =&gt; &#123; if (item.id === webId) &#123; return &#123; ...item, loading: false, children: [...dict], &#125;; &#125; return item; &#125;); break; case 3: // 运营商数据 dicts = VPNAddressDict.map(items =&gt; &#123; const list = items &amp;&amp; items.children ? items.children : []; const children = list.map(item =&gt; &#123; if (item.id === webId) &#123; return &#123; ...item, loading: false, children: [...dict], &#125;; &#125; return item; &#125;); return &#123; ...items, loading: false, isLeaf: false, children, &#125;; &#125;); break; default: dicts = []; break; &#125; return &#123; ...state, VPNAddressDict: dicts, &#125;; 然后按照示例使用组件 基本完成后。测试发现，如果你依次点击 【 广东 &gt; 广州 &gt; 移动 】（ 选中最后一层），再次选择 【北京】 组件直接选中了 【北京】（直接选中第一层）。多次测试发现只要不点击最后一层，那么不会出现这个问题。 分析：根据 bug 出现的情况，可以判断，是执行了 saveVPNAddressDict 动态拼接函数 type= 3 的运营商数据拼接出现的问题。 检查代码未发现明显错误。通过打印数据发现，【北京】数据的 children 是个空数组。 凭借多年开发的直觉[🤦‍ 好吧，我也不知道我是怎么知道的]，推测 children 数据问题。 验证：自造一条假数据，直接给组件测试使用。数据如下 1234567891011121314const options = [ &#123; value: &#x27;北京&#x27;, label: &#x27;北京&#x27;, isLeaf: false, children: [] &#125;, &#123; value: &#x27;广东&#x27;, label: &#x27;广东&#x27;, isLeaf: false, children: [] &#125;] 验证结果发现，children 字段如果是数组，会导致直接选中，不会触发 loadData。 8.修正。那么在函数执行时候，如果没被选中的 children 显示为 null。 修正如下 1234567891011121314151617181920212223// saveVPNAddressDict case 3的代码片段case 3: // 运营商数据 dicts = VPNAddressDict.map(items =&gt; &#123; const list = items &amp;&amp; items.children ? items.children : []; const children = list.map(item =&gt; &#123; if (item.id === webId) &#123; return &#123; ...item, loading: false, children: [...dict], &#125;; &#125; return item; &#125;); return &#123; ...items, loading: false, isLeaf: false, children:children.length?children:null, &#125;; &#125;); break; 总结 级联选择 数据中 isLeaf，children 两个字段直接影响 是否被选中，loadData 是否会触发。","categories":[{"name":"踩坑","slug":"踩坑","permalink":"http://mcdowell8023.github.io/categories/%E8%B8%A9%E5%9D%91/"}],"tags":[{"name":"ant-design","slug":"ant-design","permalink":"http://mcdowell8023.github.io/tags/ant-design/"},{"name":"踩坑","slug":"踩坑","permalink":"http://mcdowell8023.github.io/tags/%E8%B8%A9%E5%9D%91/"},{"name":"react","slug":"react","permalink":"http://mcdowell8023.github.io/tags/react/"}]},{"title":"git 学习笔记","slug":"工具/git-学习笔记","date":"2019-08-28T08:37:24.000Z","updated":"2020-03-29T09:59:30.671Z","comments":true,"path":"2019/08/28/工具/git-学习笔记/","permalink":"http://mcdowell8023.github.io/2019/08/28/%E5%B7%A5%E5%85%B7/git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"目录 目录 安装 git 初始化 基本配置 配置帐号信息 配置别名 查看配置 参数说明 生成 shh 密钥 获取 Git 仓库 在现有目录中初始化仓库 克隆现有的仓库 本地已有构建的项目 不进行版本控制 添加不进行版本控制的文件目录 提交 commit 后，想再忽略一些已经提交的文件 常见操作 查看信息 查看帮助 git help 查看状态 git status 查看变化 git diff 查看日志 git log 查看某个文件的版本历史 git show 图形化查看提交内容 gitk 更新 文件重命名 文件删除 提交 撤销&amp;回滚 简单总结 撤销 修改文件 尚未提交 修改文件 已经提交（git commit）到 本地仓库 回滚 还原 远端服务器 提交的代码 删除最后一次远程提交 回滚某次提交 删除某次提交 操作标签 创建标签 查看标签 删除标签 操作分支 查看分支 新建分支 提交到远程分支 删除分支 合并分支 暂存 分离头【detached HEAD】 操作子仓库 常用命令详解 git pull 详解 git fetch 详解 git add 详解 git commit 详解 git remote 详解 git push 详解 语法 示例 完整示例 本地分支名 缺省 本地分支、远程分支都 缺省 远程主机名、本地分支、远程分支都 缺省 simple 方式 和 matching 方式 git branch 详解 语法 示例 git checkout 详解 例子 git reset 详解 git cherry-pick 详解 git submodule 详解 git 原理 git 工作解析图 git 文件目录 commit 与 tree 和 blob 的关系 git 注意事项 常见缩写 安装 git 已有？请跳过 git 文档地址 git 下载地址 查看 git 版本 1git --version 初始化 基本配置 配置帐号信息 1234# 设置 [本仓库 | 全局 | 系统 ] 的 用户名称$ git config [--local | --global | --system] user.name &#x27;Your name&#x27;# 设置 [本仓库 | 全局 | 系统 ] 的 用户邮箱$ git config [--local | --global | --system] user.email &#x27;Your email&#x27; 当然你也可以通过修改 .git 文件目录下面的 config 文件进行修改 配置别名 123456# 配置别名$ git config --global alias.st status # git st$ git config --global alias.co checkout # git co$ git config --global alias.br branch # git br$ git config --global alias.ci commit # git ci 查看配置 12345# 查看配置git config --list [--local | --global | --system]# 根据git哈希值 查看内容 / 查看类型git cat-flie [-p / -t] 参数说明 local：区域为本仓库 global: 当前用户的所有仓库 system: 本系统的所有用户 缺省等同于 local 优先级：local &gt; global &gt; system 生成 shh 密钥 如果你想通过 https 的方式 每次提交输入密码，当然可以跳过此节 检查是否已经存在公私钥 1234# 查看.ssh目录下是否有密钥 如列表中包含 id_rsa和id_rsa.pub 说明电脑中已经存在公私钥ls -al ~/.ssh# cat ~/.ssh/id_rsa.pub 生成密钥 123456# 生成秘钥（根据电脑主机）$ ssh-keygen -t rsa# 根据邮箱生成 密钥$ ssh-keygen -t rsa -C &quot;youremail&quot;# 执行后 ：建议不要输入，一路回车， 生成的 id_rsa 是私钥 生成的 id_rsa.pub 是公钥 添加 密钥 在对应服务器增加密钥。【github -&gt; setting -&gt; SSH and GPG keys】 如果公司是自己搭建的 git 服务（未使用 gitlab），则交给管理员添加。如果使用 gitlab 在设置增加密钥 获取 Git 仓库 在现有目录中初始化仓库 12345678910111213# 初始化本地仓库 缺省 为当前目录$ git init [&#x27;your_project&#x27;/缺省]# git init --bare 建立裸仓库【中心仓库】# 获取状态$ git status# .或*代表全部添加$ git add [file1] [file2] ...# 提交$ git commit -m &quot;提交message&quot;# 添加远程源$ git remote add origin [远程地址]# push 同时 设置默认跟踪分支$ git push -u origin master 克隆现有的仓库 12345# 克隆远程仓库到本地 fileName 的文件夹内 【缺省-默认远端名称】$ git clone [url] &lt;fileName/缺省&gt;# 克隆 为 裸仓库【中心仓库】$ git clone --bare [ 连接地址 ] &lt; file bf名称 &gt; 从裸仓库 clone 下来的本地仓库可以进行正常的 push 操作， 但是从一般仓库 clone 下来的本地仓库却不行。 这也正是裸仓库存在的意义。 裸仓库一般情况下是作为远端的中心仓库而存在的。 本地已有构建的项目 12345678$ git remote -v #查看远程版本库信息$ git remote add github &lt;url&gt; #添加github远程版本库$ git fetch github #拉取远程版本库$ git merge -h #查看合并帮助信息$ git merge --allow-unrelated-histories github/master# or git pull origin master --allow-unrelated-histories# 对github上的master分支与本地master分支进行合并（两分支不是父子关系，所以合并需要添加 --allow-unrelated-histories）$ git push github #推送同步到github仓库 不进行版本控制 添加不进行版本控制的文件目录 项目目录下 新建 .gitignore 文件 ，写入不需要进行版本控制的文件名或文件夹 123456789101112131415# 文件示例node_modules # 对 node_modules文件夹及其文件 及 node_modules文件 不进行版本控制doc # 对 [doc文件夹及其子文件 和 名称为doc的文件] 不进行版本控制*doc # 不允许 任何 包含doc字符的 文件夹及其子文件 和 文件（包括.扩展名）不进行版本控制doc/ # 对 [doc文件夹及其下文件] 不进行版本控制*doc/ # 对 [任何 包含doc字符的文件夹及其下文件] 不进行版本控制*.md // 对 .md结尾的文件 不进行版本控制# /* 复合示例 */doc!doc/* # git管doc文件夹，不管doc文件 提交 commit 后，想再忽略一些已经提交的文件 把忽略的文件添加到 .gitignore; 通过 git rm --cached &lt; file &gt;的方式删除掉 git 仓库里面无需跟踪的文件。 你需要确认 的 云端源 也要删除 git commit -m 'delete git remote somefile' git push 常见操作 查看信息 查看帮助 git help 12345678# 所有可用的命令都将打印在标准输出上$ git help [--all/-a]# 在标准输出中也会列出有用的Git指南$ git help [--guide/-g]# 显示 git 手册页$ git help git 查看状态 git status git status 命令用于显示工作目录和暂存区的状态。git status 不显示已经 commit 到项目历史中去的信息。看项目历史的信息要使用 git log 常用于 git commit 之前, 这样能防止你不小心提交了您不想提交的东西。 1234567# 显示工作目录和暂存区的状态$ git status# 只列出所有已经被git管理的且被修改但没提交的文件$ git status -uno# 紧凑的格式输出$ git status -s # or $ git status --short 查看变化 git diff 对比 修改之后还没有暂存起来的内容变化 123456789101112131415161718192021222324252627282930313233343536# 工作树中的更改尚未分段进行下一次提交$ git diff# 比较当前文件和暂存区文件差异 git diff$ git diff &lt;file&gt;$ git diff &lt;id1&gt;&lt;id1&gt;&lt;id2&gt; # 比较两次提交之间的差异$ git diff &lt;branch1&gt; &lt;branch2&gt; # 在两个分支之间比较$ git diff --staged # 比较暂存区和版本库差异$ git diff --cached # 比较暂存区和版本库差异$ git diff --stat # 仅仅比较统计信息$ git diff HEAD # 显示工作版本(Working tree)和HEAD的差别$ git diff test # 查看当前目录和另外一个分支(test)的差别# 假定：HEAD、缓存区、工作区中的readme.md文件内容均不相同。# 比较 工作区 &lt;===&gt; HEAD$ git diff HEAD -- readme.md# 比较 工作区 &lt;===&gt; 缓存区$ git diff -- readme.md# 比较 缓存区 &lt;===&gt; HEAD$ git diff --cached -- readme.md# 比较两个提交或分支的差异$ gti diff [分支名称/commit-id] [分支名称/commit-id] --&lt; file &gt;# 对比两个版本的不同$ git diff [commit号] [commit号]# 对比 当前提交版本与上次提交$ git diff HEAD HEAD^[同 HEAD～1]# 对比当前提交版本与上上次（前两次）提交$ git diff HEAD HEAD^^[同HEAD～2] 补充说明： 一个节点，可以包含多个子节点（checkout 出多个分支） 一个节点可以有多个父节点（多个分支合并） 是~都是父节点，区别是跟随数字时候，2 是第二个父节点，而~2 是父节点的父节点 ^和~可以组合使用,例如 HEAD~2^2 查看日志 git log 123456789101112131415# 查看所有分支的历史 git log 等同于它$ git log --all# 查看图形化的 log 地址$ git log --all --graph# 查看单行的简洁历史。$ git log --oneline# 查看最近的四条简洁历史。$ git log --oneline -n4#查看所有分支最近 4 条单行的图形化历史。$ git log --oneline --all -n4 --graph# 跳转到git log 的帮助文档网页$ git help --web log$ git log -1 // 最近一次提交信息 查看某个文件的版本历史 git show 1234// 先查看文件提交历史git log --pretty=oneline [文件名或文件路径] // 例如src/AfterView/common/commonStream.vuegit show [版本号] // 显示具体的某次的改动的修改 图形化查看提交内容 gitk 1234# 在当前目录下输入，弹出图形化界面$ gitk$ gitk --all 定制化图形界面 ： view --&gt; new view [勾选 all refs] # 显示全部分支 更新 使用 git pull 进行更新 1234# 按照git branch 设置的默认跟踪的服务器和分支来拉取$ git pull# 实例：拉取远程服务器origin的master分支$ git pull origin master 使用 git fetch 进行更新 12345678# 将远程仓库的master分支下载到本地当前branch中$ git fetch orgin master# 比较本地的master分支和origin/master分支的差别 $ git log -p master ..origin/master # 进行合并$ git merge origin/master 文件重命名 先删除文件再添加文件 1234567# 重命名3步骤 eg: 重命名 readme 为 readme.md$ mv [文件名1] [文件名2] # 重命名文件名1为文件名2$ git add [&#x27;文件名&#x27;] # 添加新文件 eg: git add readme.md$ git rm [&#x27;文件名&#x27;] # 删除旧文件 eg: git rm readme# 就可以正常commit 直接使用 git 命令 123$ git mv [&#x27;旧文件名&#x27;] [&#x27;新文件名&#x27;] # git重命名（相当于上面三个步骤）# 就可以正常commit 12345# 回滚到对版本号的应提交状态【缺省回滚到最近的一次提交】$ git reset --hard [提交版本号|缺省]# 记录所有HEAD的历史，也就是说当你做reset，checkout等操作的时候，这些操作会被记录在reflog中$ git reflog 文件删除 先删除文件再添加文件 12345$ rm &lt;file&gt; # 删除文件$ git add [&#x27;文件名&#x27;] # 添加新文件 eg: git add readme.md# 就可以正常commit 直接使用 git 命令 12# 删除工作区，暂存区 的文件$ git rm &lt;file&gt; 如果删除出错 借助 git reset --hard 进行撤销 提交 123456789101112131415161718192021# 添加新文件$ git add [&#x27;文件名&#x27; | &#x27;.&#x27;代表全部]# 查看提交状态【是否有未提交】（不必的） but 能防止你不小心提交了您不想提交的东西# $ git status # 没有未提交的显示 nothing to commit# 提交填写日志$ git commit -m&#x27;这里填写提交日志&#x27;# 如果发现点问题，那么继续进行了修改# 继续执行 git add . 重新提交，会覆盖上次提交，只以当前为准# $ git commit --amend# 查看日志(不必的)# $ git log# 更新 先更新避免发生冲突$ git pull# 推送到 orgin 远端服务器$ git push 撤销&amp;回滚 简单总结 修改了工作区，恢复：git checkout add 后，想撤销： git reset HEAD commit 后，想撤销： git reset --hard [需要回退的 commit id] 撤销 修改文件 尚未提交 未执行 git add 操作 123# 从暂存区（index） 恢复 文件$ git checkout &lt;fileName&gt;$ git checkout . 文件执行了 git add 操作，恢复 文件（index 内回滚） 123456789# 取消暂存$ git reset HEAD fileName# 撤销修改$ git checkout &lt; fileName &gt;# 暂存区的 commitid 覆盖工作区修改$ git checkout [commitid] -- &lt;file&gt;# git checkout 5384b04 -- src/pages/AdScreen/components/commonStream.vue // 回退 5384b04 的文件 同时对多个文件执行了 git add 操作，本次只想提交其中一部分文件 1234$ git add *$ git status# 取消暂存$ git reset HEAD &lt;filename&gt; 修改文件 已经提交（git commit）到 本地仓库 修改 git commit 不再产生新的 Commit[ 只能修改最近一次 ] 1234# 修改最后一次提交$ git add sample.txt# 代替（或这说修改）上一次提交，不只是修改message。$ git commit --amend -m&quot;说明&quot; 多次 git commit 撤销到其中某次 Commit 1234567891011121314# 修改最后一次提交$ git reset --[soft/hard/mixed] [commit|HEAD]# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit] 回滚 已进行 git push，即已推送到“远程仓库”中。我们将已被提交到“远程仓库”的代码还原操作叫做“回滚”！ 注意：对远程仓库做回滚操作是有风险的，需提前做好备份和通知其他团队成员！ 还原 远端服务器 提交的代码 12345# 根据 tag 还原工作区代码$ git checkout &lt;tag&gt;# 回滚到指定commitID$ git checkout &lt;commitID&gt; &lt;filename&gt; 删除最后一次远程提交 使用 revert 1234$ git revert HEAD$ git push origin master 使用 reset 1234$ git reset --hard HEAD^$ git push origin master -f 二者区别： revert 是放弃指定提交的修改，但是会生成一次新的提交，需要填写提交注释，以前的历史记录都在； reset 是指将 HEAD 指针指到指定提交，历史记录中不会出现放弃的提交记录。 回滚某次提交 1234# 找到要回滚的 commitID$ git log# 根据 commitID 进行回滚$ git revert commitID 删除某次提交 1234567891011# 找到要回滚的 commitID$ git log --oneline -n5# 注意：最后的^号，意思是commit id的前一次提交$ git rebase -i &quot;commit id&quot;^ # git rebase -i &quot;5b3ba7a&quot;^# 根据交互输入命令修改信息# 合并多个历史版本commit合并$ git rebase -i [父级commit id ]# 合并多个历史版本commit合并$ git rebase -i [开始commit 的父级id] [结束commit id] 如果没有指定 结束 commit,那么结束 commit 默认为当前分支最新的 commit，那么 rebase 结束后会自动更新当前分支指向的 commit, 如果指定了结束 commit，而且结束 commit 不是当前分支最新的 commit，那么 rebase 后会有生成一个 游离的 head,，而且当前分支指向的 commit 不会更新 具体还可参考： Deleting a Git commit 在 Git 中，如何『删除』commit？ 操作标签 标签操作允许为存储库中的特定版本提供有意义的名称。 创建标签 12345678910# 创建标签$ git tag -a &#x27;tag1&#x27; -m &#x27;tag1的说明&#x27; [HEAD / commit id / 缺省]# -a选项的 标签名称，-m选项的 标签消息。# 缺省：HEAD 要标记特定提交，则使用相应的COMMIT ID而不是HEAD指针# 将 tag1 推送到 origin 远端$ git push origin &lt;tagname&gt;# 一次性推送全部尚未推送到远程的本地标签$ git push origin --tags 查看标签 123456$ git tag# 查看 所有可用的标签$ git tag -l# 查看 tagName标签的 详细信息$ git show tagName 删除标签 1234567891011# 查看 所有可用的标签$ git tag -l# 删除 tagName标签$ git tag -d &lt;tagName&gt;# 删除 远端 tag 标签$ git push origin --delete tag &lt;tagname&gt;# 删除 远端 tag 标签 类似 删除远端分支的做法$ git push origin :refs/tags/标签名 操作分支 查看分支 1234# 查看分支git branch -v# 查看本地分支对应的远程分支$ git branch -av 新建分支 1234567891011121314151617# 新建一个名字为 dev2 的分支 (不切换到新分支)$ git branch dev2# 新建一个名字为 dev2 的分支 并切换到该分支$ git checkout -b &lt;branchname&gt;# 从某个版本创建分支 并切换到该分支$ git checkout -b &lt;branchname&gt; [commit号/分支名称]# 创建并切换分支$ git checkout -b &lt;branchname&gt; [commit版本号]# 基于 远端分支 建立 本地分支（远程分支名x） 采用此种方法建立的本地分支会和远程分支建立映射关系$ git checkout -b &lt;本地分支名x&gt; &lt;origin/远程分支名x&gt;/* 相当于分别执行了下面两条命令 */# git branch &lt;branchname&gt;# git checkout &lt;branchname&gt; 提交到远程分支 12345678910$ git push [origin] &lt;分支名称&gt;:&lt;分支名称&gt;# 本地分支push到远程服务器，远程分支与本地分支同名（当然可以随意起名）$ git pull [origin] &lt;分支名称&gt; 更新远程分支到本地# /* 远程分支关联 */$ git branch --set-upstream-to=[origin]/&lt;分支名称&gt;# 接下来就 可以直接pull 或者push 了# 查看关联的分支名称$ git branch -vv [origin] 代指 添加远程裸仓库地址时候，创建的名称 删除分支 12345678910# 删除分支 -d是删除 -D 是强制删除$ git branch [-D/-d] &lt;branchname&gt;# 删除远程分支$ git branch -d -r &lt;branchname&gt;$ git push origin :&lt;branchname&gt;# OR$ git branch # 查看分支名称$ git push origin --delete &lt;branchname&gt; 合并分支 fast-forward fast-forward 方式 合并 这种方法相当于直接把 master 分支移动到 test 分支所在的地方，并移动 HEAD 指针 12345# 先切换到主分支，为合并分支准备$ git checkout master# 进行合并$ git merge dev no-fast-forward 方式 合并 这种合并方法会在 master 分支上新建一个提交节点，从而完成合并 12345# 先切换到主分支，为合并分支准备$ git checkout master# 进行合并$ git merge –no-ff dev squash 方式 合并 squash 和 no-ff 非常类似，区别只有一点不会保留对合入分支的引用 12$ git checkout master$ git merge –squash dev rebase 方式 合并 rebase 与 merge 不同，rebase 会将合入分支上超前的节点在待合入分支上重新提交一遍，变成线性历史 12345# 先切换到主分支，为合并分支准备$ git checkout master# 进行合并$ git rebase dev cherry-pick 挑拣 合并 对已经存在的 commit 进行 再次提交 [选择某些节点进行合并] 12$ git cherry-pick &lt;commit id&gt; 当执行完 cherry-pick 以后，将会 生成一个新的提交；这个新的提交的哈希值和原来的不同，但标识名 一样； 图解 4 种 git 合并分支方法 &gt; git cherry-pick 的使用 暂存 当收到紧急任务，手里又存在未完成的模块可以先放到暂存区 123456789git stash # 暂存git stash list # 查看暂存列表git stash apply [序号/缺省为stash@&#123;0&#125;] # 恢复暂存进度到工作区git stash pop [序号/缺省为stash@&#123;0&#125;] # 恢复暂存进度到工作区并删除# git stash pop = git stash pop stash@&#123;0&#125; 分离头【detached HEAD】 执行 git checkout [commit 版本号] ，git 会提示显示处于分离头（无分支状态），在此状态下，进行的提交操作不挂到在分支下，直接切换分支，会导致分离头的提交丢失。 错误示范： 12345678910git checkout 15a6686b624 # 检出15a6686b624的提交，到分离头情况git commit -am&quot;错误示例&quot; # 创建一次提交git branch -av # 查看分支git checkout marst # 切换到marst 分支 此时git 会提示你，对分离头提交# 最后一次补救git branch [分支名称] [commit版本号] 正常使用 1234# 使用某个提交创建分支git checkout -b [分支名称] [commit版本号] // 创建并切换分支git checkout -b 本地分支名x origin/远程分支名x // 基于 远端分支 建立 本地分支（远程分支名x） 采用此种方法建立的本地分支会和远程分支建立映射关系 操作子仓库 12345678910111213141516171819# 添加子仓库$ git submodule add &lt;仓库地址&gt; &lt;本地路径&gt;# 检出子仓库# 初始化本地配置文件$ git submodule init# 检出父仓库列出的commit$ git submodule update# 或者使用组合指令。$ git submodule update --init --recursive# 删除子仓库# 1删除.gitsubmodule里相关部分# 2删除.git/config 文件里相关字段# 3删除子仓库目录。$ git rm -r --cached &lt;本地路径&gt; git submodule 使用小结 常用命令详解 git pull 详解 git pull 相当于从远程获取最新版本并 merge 到本地 1234# 按照git branch 设置的默认跟踪的服务器和分支来拉取$ git pull# 实例：拉取远程服务器origin的master分支$ git pull origin master git pull 详解 12345$ git pull [&lt;options/缺省&gt;] [&lt;远端仓库名称&gt; [&lt;分支名称&gt;…​]]# options : –allow-unrelated-histories 允许无关的历史，这个选项，更多是在更改远程仓库的时候用到# options : –ff 开启fast-forward# options : –no-ff 强行关闭fast-forward方式# options : –ff-only git fetch 详解 git fetch 相当于是从远程获取最新到本地，不会自动 merge 在实际使用中，git fetch 更安全一些 使用 git fetch 进行更新 12345678# 将远程仓库的master分支下载到本地当前branch中$ git fetch orgin master# 比较本地的master分支和origin/master分支的差别 $ git log -p master ..origin/master # 进行合并$ git merge origin/master OR 123456# 从远程仓库master分支获取最新，在本地建立tmp分支$ git fetch origin master:tmp#將當前分支和tmp進行對比$ git diff tmp#合并tmp分支到当前分支$ git merge tmp git pull = git fetch + git merge git add 详解 将修改添加到暂存区 1234567891011121314151617# 将所有修改添加到暂存区$ git add .# Ant风格添加修改$ git add *# 将文件的修改、文件的删除，添加到暂存区。$ git add -u# 将文件的修改，文件的删除，文件的新建，添加到暂存区$ git add -A# 将以Controller结尾的文件的所有修改添加到暂存区$ git add *Controller# 将所有以Hello开头的文件的修改添加到暂存区 例如:HelloWorld.txt,Hello.java,HelloGit.txt ...$ git add Hello*# 将以Hello开头后面只有一位的文件的修改提交到暂存区 例如:Hello1.txt,HelloA.java 如果是HelloGit.txt或者Hello.java是不会被添加的$ git add Hello? git commit 详解 用于将更改记录(提交)到存储库 1234567891011121314# 普通提交填写提交信息$ git commit -m &quot;the commit message&quot;# 将所有已跟踪文件中的执行修改或删除操作的文件都提交到本地仓库，即使它们没有经过git add添加到暂存区，# 然后提交(有点像svn的一次提交,不用先暂存)。# 对于没有track的文件,还是需要执行`git add &lt;file&gt;` 命令。$ git commit -a$ git commit -a -m &quot;the commit message&quot;# 增补提交（修改上次提交），会使用与当前提交节点相同的父节点进行一次新的提交，旧的提交将会被取消。$ git commit --amend git remote 详解 git remote 命令管理一组跟踪的存储库 12345678910111213141516171819202122232425262728293031# 查看当前的远程库# 列出已经存在的远程分支$ git remote# 列出详细信息，在每一个名字后面列出其远程url$ git remote [-v | --verbose]# 添加一个名字为 &lt;name&gt; 的 远程服务器# $ git remote add &lt;name&gt; &lt;url&gt;$ git remote add [-t &lt;branch&gt;] [-m &lt;master&gt;] [-f] [--[no-]tags] [--mirror=&lt;fetch|push&gt;] &lt;name&gt; &lt;url&gt;# 重命名 远程链接$ git remote rename &lt;old&gt; &lt;new&gt;# 删除 远程链接$ git remote remove &lt;name&gt;$ git remote set-head &lt;name&gt; (-a | --auto | -d | --delete | &lt;branch&gt;)$ git remote set-branches [--add] &lt;name&gt; &lt;branch&gt;…​# 获取 &lt;name&gt; 远程服务 地址$ git remote get-url [--push] [--all] &lt;name&gt;# 设置 &lt;name&gt; 远程服务 地址$ git remote set-url [--push] &lt;name&gt; &lt;newurl&gt; [&lt;oldurl&gt;]# eg: git remote set-url [ 裸仓库名称/常用origin]$ git remote set-url --add [--push] &lt;name&gt; &lt;newurl&gt;$ git remote set-url --delete [--push] &lt;name&gt; &lt;url&gt;$ git remote [-v | --verbose] show [-n] &lt;name&gt;…​$ git remote prune [-n | --dry-run] &lt;name&gt;…​$ git remote [-v | --verbose] update [-p | --prune] [(&lt;group&gt; | &lt;remote&gt;)…​] git push 详解 将修改添加到暂存区 语法 123# 命令用于将本地分支的更新，推送到远程主机。与git pull命令相似。$ git push &lt;远程主机名/缺省&gt; &lt;本地分支名/缺省&gt;:&lt;远程分支名/缺省&gt; 示例 origin 可通过 .git config 查看地址 完整示例 123# 将本地的master分支推送到origin主机的master分支。如果master不存在，则会被新建。$ git push origin master 本地分支名 缺省 表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。 1234# 表示删除origin主机的master分支$ git push origin :master# 等同于$ git push origin --delete master 本地分支、远程分支都 缺省 表示推送特定主机的对应分支简写方式：如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。 12# 将当前分支推送到origin主机的对应分支$ git push origin 远程主机名、本地分支、远程分支都 缺省 表示推送origin 主机的对应分支简写方式：如果当前分支只有一个追踪分支，那么主机名都可以省略。 123# 将当前分支推送到 预设 主机【默认origin】的对应分支$ git push 当前分支与多个主机存在追踪关系，则可以使用-u 选项指定一个默认主机，这样后面就可以不加任何参数使用 git push 12# 将本地的master分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用git push了$ git push -u origin master simple 方式 和 matching 方式 不带任何参数的 git push，默认只推送当前分支，这叫做 simple 方式 matching 方式，会推送所有有对应的远程分支的本地分支 Git 2.0 版本之前，默认采用 matching 方法，现在改为默认采用 simple 方式 如果要修改这个设置，可以采用 git config 命令 123$ git config --global push.default matching# 或者$ git config --global push.default simple 1234567891011121314151617181920212223242526# 不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机# 所有本地分支都推送到origin主机$ git push --all origin# 使用-–force选项，结果导致在远程主机产生一个”非直进式”的合并(non-fast-forward merge)$ git push --force origin# git push不会推送标签(tag)，除非使用–tags选项$ git push origin --tags# 推送tag$ git push origin tag_name# 删除远程标签$ git push origin :tag_name# 将当前分支推送到远程的同名分支$ git push origin HEAD# 将当前所在指针分支 推送到 远程的master分支$ git push origin HEAD:master# 用本地分支 dev 覆盖远程分支 dev_op$ git push -f origin dev:refs/dev_op# or$ git push origin :refs/dev //删除远程的dev分支$ git push origin dev:refs/dev_op git branch 详解 用于列出，创建或删除分支 语法 123456789101112# 查看分支$ git branch [-r | -a]# 新建分支$ git branch [-f] &lt;branchname&gt;# 重命名分支 使用-M则表示强制重命名$ git branch (-m | -M) &lt;oldbranch&gt; &lt;newbranch&gt;# 删除分支 使用-D则表示强制删除，相当于 --delete --force$ git branch (-d | -D) &lt;branchname&gt; 使用-d 在删除前 Git 会判断在该分支上开发的功能是否被 merge 的其它分支。如果没有，不能删除。如果 merge 到其它分支，但之后又在其上做了开发，使用-d 还是不能删除。-D 会强制删除 示例 12345678910111213141516171819202122232425# 查看分支$ git branch# 列出所有远程分支$ git branch -r# 查看本地和远程分支$ git branch -a# 查看本地分支对应的远程分支$ git branch -vv# 新建一个名字为 dev2 的分支$ git branch dev2# 修改分支的名字#你需要重命名远程分支，推荐的做法是：1.删除远程待修改分支 2.push本地新分支名到远程$ git branch -m dev2# 删除本地分支$ git branch -d &lt;branchname&gt;# 删除远程分支$ git branch -d -r &lt;branchname&gt;$ git push origin :&lt;branchname&gt;# OR$ git branch$ git push origin --delete dev2 git checkout 详解 用于切换分支或恢复工作树文件。这条命令会重写工作区 123456789101112131415161718192021222324252627282930313233343536# 切换 &lt;branch&gt; 分支$ git checkout &lt;branch&gt;# 从 &lt;branch&gt; 分支 提交中取出文件$ git checkout &lt;branch&gt; &lt;fileName&gt;# 从暂存区（index） 恢复文件$ git checkout &lt;fileName&gt;# 新建 &lt; branch &gt; 分支 并进行切换$ git checkout -b &lt;branch&gt;$ git checkout -b|-B &lt;new_branch&gt; [&lt;start point&gt;] # 完整版# 相当于 执行# git branch newBranch# git checkout newBranch# 换到newBranch的远程分$ git checkout -b newBranch origin/newBranch# 检出索引中的 fileName文件$ git checkout -- &lt;fileName&gt;# 检出索引中的 fileName文件$ git checkout -- &lt;fileName&gt;# 用于检出某一个指定文件# 不填写commit id，则默认会从暂存区检出该文件，如果暂存区为空，则该文件会回滚到最近一次的提交状态$ git checkout [-q] [&lt;commit id&gt;] [--] &lt;paths&gt;# 当暂存区为空，如果我们想要放弃对某一个文件的修改，可以用这个命令进行撤销$ git checkout [-q] [--] &lt;paths&gt;# 新建的分支，严格意义上说，还不是一个分支，因为HEAD指向的引用中没有commit值，只有在进行一次提交后，它才算得上真正的分支$ git checkout --orphan &lt;new_branch&gt;# 将当前分支修改的内容一起打包带走，同步到切换的分支下 [切换到新分支后，当前分支修改过的内容就丢失了]$ git checkout --merge &lt;branch&gt;$ git checkout -m &lt;branch&gt; 例子 1234567891011121314151617181920212223#//取出master版本的head。$ git checkout master#//在当前分支上 取出 tag_name 的版本$ git checkout tag_name#//放弃当前对文件file_name的修改$ git checkout master file_name#//取文件file_name的 在commit_id是的版本。commit_id为 git commit 时的sha值。$ git checkout commit_id file_name# 从远程dev/1.5.4分支取得到本地分支/dev/1.5.4$ git checkout -b dev/1.5.4 origin/dev/1.5.4#这条命令把hello.rb从HEAD中签出.$ git checkout -- hello.rb# 检出索引中的所有C源文件$ git checkout -- &#x27;*.c&#x27;#这条命令把 当前目录所有修改的文件 从HEAD中签出并且把它恢复成未修改时的样子.#注意：在使用 git checkout 时，如果其对应的文件被修改过，那么该修改会被覆盖掉。$ git checkout . git reset 详解 12345678910$ git reset [ –-soft | -–mixed | -–hard] &lt;commit&gt;# git reset &lt;commit&gt; 的意思就是 把HEAD移到&lt;commit&gt;# --soft 这个只是把 HEAD 指向的 commit 恢复到你指定的 commit，暂存区 工作区不变# --hard 这个是 把 HEAD， 暂存区， 工作区 都修改为 你指定的 commit 的时候的文件状态# --mixed 这个是不加时候的默认参数，把 HEAD，暂存区 修改为 你指定的 commit 的时候的文件状态，工作区保持不变# 取消暂存区 部分文件（files 代表多个）的修改$ git reset HEAD --&lt; files &gt; git cherry-pick 详解 语法 12345678910$ git cherry-pick [&lt;options&gt;] &lt;commit-ish&gt;...# 常用options:# --quit 退出当前的chery-pick序列# --continue 继续当前的chery-pick序列# --abort 取消当前的chery-pick序列，恢复当前分支# -n, --no-commit 不自动提交# -e, --edit 编辑提交信息 git submodule 详解 命令用于初始化，更新或检查子模块 1234567891011121314$ git submodule status [--cached] [--recursive] [--] [&lt;path&gt;…​]# 添加 子模块 路径为 相关信息保存在 .gitmodules 文件$ git submodule add &lt;url&gt; [&lt;path&gt;]# 初始化本地配置文件$ git submodule init [--] [&lt;path&gt;…​]# 检出父仓库列出的commit$ git submodule update# 使用组合指令$ git submodule update --init --recursive git 原理 git 工作解析图 下面这个图展示了工作区、版本库中的暂存区和版本库之间的关系： git 文件目录 COMMIT_EDITMSG config 当前 git 的配置文件 description （仓库的描述信息文件） HEAD （指向当前所在的分支），例如当前在 develop 分支，实际指向地址是 refs/heads/develop hooks [文件夹] index info [文件夹] logs [文件夹] objects [文件夹] （存放所有的 git 对象，对象哈希值前 2 位作为文件夹名称，后 38 位作为对象文件名, 可通过 git cat-file -p 命令，拼接文件夹名称+文件名查看） ORIG_HEAD refs [文件夹] • heads （存放当前项目的所有分支） • tags (存放的当前项目的所有标签，又叫做里程碑) commit 与 tree 和 blob 的关系 12345commit 对应一个treetree 包含文件[blob]，如果下级还是文件夹，则又是一个treeblob 是tree下面具体文件 【与文件名无关具体到文件内容】 git 注意事项 checkout reset 慎用 禁止向集成分支[多人使用分支] 执行 push -f [强制更新到远端 可能会导致远端所在分支回退很多版本] 如果单人自行分支，确认是要返回某个节点， 使用 push -f 公共分支修改 commit ： git reflog 命令查找历史，然后利用 git reset --hard [提交版本号|缺省] 的方式恢复 公共分支 禁止进行 rebase 变基操作 对于自己在本地的多次 commit，我想把他合并成一次 commit，还没有 push 的情况下,使用 rebase 常见缩写 1234567891011121314-d --delete：删除-D --delete --force的快捷键-f --force：强制-m --move：移动或重命名-M --move --force的快捷键-r --remote：远程-a --all：所有","categories":[{"name":"工具","slug":"工具","permalink":"http://mcdowell8023.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://mcdowell8023.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"git","slug":"git","permalink":"http://mcdowell8023.github.io/tags/git/"}]},{"title":"git常用命令","slug":"工具/git常用命令","date":"2019-08-21T03:23:21.000Z","updated":"2020-03-29T09:59:23.193Z","comments":true,"path":"2019/08/21/工具/git常用命令/","permalink":"http://mcdowell8023.github.io/2019/08/21/%E5%B7%A5%E5%85%B7/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"git 常用命令清单 转载 阮老师博客 部分修改 说明 Workspace：工作区 Index / Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库 一、新建代码库 12345678# 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url] 二、配置 Git 的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 123456789# 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name &quot;[name]&quot;$ git config [--global] user.email &quot;[email address]&quot; 三、增加/删除文件 123456789101112131415161718192021222324# 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p# 移除文件$ git rm -f *# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed] 四、代码提交 12345678910111213141516171819# 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ... 五、分支 12345678910111213141516171819202122232425262728293031323334353637383940414243# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -d -r [remote/branch] 六、标签 123456789101112131415161718192021222324252627# 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag] 七、查看信息 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364# 通过图像方式查看提交历史gitk# 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog 八、远程同步 123456789101112131415161718192021222324# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all 九、撤销 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576# 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 从仓库取出file覆盖当前分支$ git checkout branch|tag|commit -- file_name# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 取消已经暂存的文件$ git reset HEAD *# 同上$ git reset --mixed HEAD *# 重置到指定状态，不会修改索引区和工作树$ git reset --soft HEAD *# 重置到指定状态，会修改索引区和工作树$ git reset --hard HEAD *# 重置index区文件$ git reset -- files#撤销前一次操作$ git revert HEAD#撤销前前一次操作$ git revert HEAD~# 撤销指定操作commit 所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]# 暂时将未提交的变化移除，稍后再移入# 将工作区现场（已跟踪文件）储藏起来，等以后恢复后继续工作。$ git stash# 查看保存的工作现场$ git stash list# 恢复工作现场$ git stash apply# 删除stash内容$ git stash drop# 恢复的同时直接删除stash内容$ git stash pop# 恢复指定的工作现场，当你保存了不只一份工作现场时$ git stash apply stash@&#123;0&#125; 十、子仓库 git submodule 12345678910111213141516171819# 添加子仓库$ git submodule add &lt;仓库地址&gt; &lt;本地路径&gt;# 检出子仓库# 初始化本地配置文件$ git submodule init# 检出父仓库列出的commit$ git submodule update# 或者使用组合指令。$ git submodule update --init --recursive# 删除子仓库# 1删除.gitsubmodule里相关部分# 2删除.git/config 文件里相关字段# 3删除子仓库目录。$ git rm -r --cached &lt;本地路径&gt; 十一、其他 123# 生成一个可供发布的压缩包$ git archive","categories":[{"name":"工具","slug":"工具","permalink":"http://mcdowell8023.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://mcdowell8023.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"git","slug":"git","permalink":"http://mcdowell8023.github.io/tags/git/"},{"name":"命令","slug":"命令","permalink":"http://mcdowell8023.github.io/tags/%E5%91%BD%E4%BB%A4/"},{"name":"速查","slug":"速查","permalink":"http://mcdowell8023.github.io/tags/%E9%80%9F%E6%9F%A5/"}]},{"title":"hexo博客-常见问题","slug":"工具/hexo博客-常见问题","date":"2019-07-17T16:15:05.000Z","updated":"2020-04-23T04:40:39.946Z","comments":true,"path":"2019/07/18/工具/hexo博客-常见问题/","permalink":"http://mcdowell8023.github.io/2019/07/18/%E5%B7%A5%E5%85%B7/hexo%E5%8D%9A%E5%AE%A2-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/","excerpt":"","text":"博客在 github 访问访问慢？ 在 coding page 上部署实现国内外分流 申请 coding 账户，新建项目 同 GitHub 添加 ssh key 同 GitHub 修改_config.yml 12345deploy: type: git repo: github: &lt;github项目地址 url&gt;,master coding: &lt;coding项目地址 url&gt;,master 部署 12hexo ghexo d coding 控制台 开启 pages 菜单目录中 -&gt; 代码 pages 服务 注意：本地电脑之前 没有与 远端托管服务器[ github、coding 等 ] 建立过 ssh 连接，部署会报错[ 即使已经在远端配置好了 ssh 公钥 ]。 可以先用本地电脑与远端进行 ssh -T git@github.com 进行测试 或者 项目克隆。 补充 coding 不太给力，不知道为啥私自改了地址，而且访问巨慢。 ps: 决定使用 码云，虽然每次都要点击 更新 ，但是总访问不了的强啊 要注意 根目录菜单的倒是样式无法加载 的问题【 仓库名 与 用户名一样】。 戳这里看详情 同时使用 Gitub 和码云部署博客 第三方主题 没有办法上传到自己的项目中？ 在使用第三方主题的时候，难免要对主题进行微调。但是调整后的主题文件 是无法上传上去的。这时候，你换台电脑来写博客，就还得再来一遍。【别问我，我是怎么知道的 😂】 其实第三方主题是别人的项目，你修改后自认是无法提交到别人的项目上。 那么针对上面问题，有两个解决办法： 删掉 第三方主题 的.git &lt; 好用但不推荐 &gt; git 不能嵌套上传，最好是显示隐藏文件，检查一下有没有，否则上传的时候会出错，导致你的主题文件无法上传 使用 Git 的 Submodule for 主题的仓库到自己的目录下 【喂，for 就不用说了吧】 然后先删掉你原来主题文件 【❗️ 备份 ❗ 备份 ️❗️ 备份】 1git rm -r --cached themes/&lt; 主题目录 &gt; 添加 submodlue 1git submodule add &lt; for后的主题仓库地址 &gt; themes/&lt; 主题目录 &gt; 当前工程根路径下生成一个名为“.gitmodules”的文件 123[submodule &quot;themes/主题&quot;]path = themes/主题url = https://github.com/wuchong/jacman.git # 主题地址 单独提交修改后的主题【这是你还原主题更改的好时候】 12345cd themes/&lt; 主题目录 &gt;git add .git commit -m &quot;我只是对主题进行了一些调整&quot;git push origin master //这是提交到fork后主题的仓库 然后返回博客项目根目录 进行正常提交就好 在新电脑上 clone 后 npm install 之前要去下载 主题 123cd themes/&lt; 主题目录 &gt;git submodule initgit submodule update # 获取我的主题的配置 注意：一定要切换到对应分支【 同时注意更新下来的版本 】 关于博客版本管理 关于 hexo 博客的机制是这样的：由于 hexo d 上传部署到 github 的 pages 服务其实是 hexo 编译后的文件，是用来生成网页的，不包含源文件。 那么我们写博客的源文件总要放到网上去托管啊。 那么新建仓库，直接上传到 github？ 这样算上刚刚 for 的主题，再加上 主页的 pages 服务的主页，一个博客用了三个仓库。貌似有点浪费资源。 那么。。。 可以在主页仓库[pages 服务的仓库]的其他分支上传源码 在下面，其实就是 git 的知识了，然而还是贴上吧 1234567# 在github仓库上，创建hexo 分支，用于存放源码git remote -v #查看远程版本库信息git remote add github &lt;url&gt; #添加github远程版本库git fetch github hexo #拉取远程版本库git merge -h #查看合并帮助信息git merge --allow-unrelated-histories github/heox # 对github上的heox分支与本地master分支进行合并（两分支不是父子关系，所以合并需要添加 --allow-unrelated-histories）git push github hexo #推送同步到github仓库 的 hexo 记得 fetch,pull,push 的时候 一定要 带着分支 相关连接 基于 Hexo 的博客同步中的一些问题 相关文章 hexo博客-建站","categories":[{"name":"技术帖","slug":"技术帖","permalink":"http://mcdowell8023.github.io/categories/%E6%8A%80%E6%9C%AF%E5%B8%96/"}],"tags":[{"name":"hexoBlog","slug":"hexoBlog","permalink":"http://mcdowell8023.github.io/tags/hexoBlog/"}]},{"title":"hexo博客-建站","slug":"工具/hexo博客-建站","date":"2019-07-17T16:14:13.000Z","updated":"2019-08-30T09:38:03.621Z","comments":true,"path":"2019/07/18/工具/hexo博客-建站/","permalink":"http://mcdowell8023.github.io/2019/07/18/%E5%B7%A5%E5%85%B7/hexo%E5%8D%9A%E5%AE%A2-%E5%BB%BA%E7%AB%99/","excerpt":"","text":"安装启动 依赖：Node.js (Should be at least nodejs 6.9) / Git 安装 Hexo 1npm install -g hexo-cli 建站 123hexo init &lt;blogName&gt;cd &lt;blogName&gt;npm install 目录介绍 12345678 .├── _config.yml # 博客项目配置文件├── package.json # 依赖包，不多少├── scaffolds # 文章模版 可以根据现有模版自定义├── source # 存放用户资源的地方| ├── _drafts| └── _posts # 文章存放目录└── themes # 主题 source : 资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。 修改配置 1234567891011vim _config.yml# 修改信息# Sitetitle: # 例如 mcdowell博客subtitle: # 例如 博客+笔记description: # 例如 javascript/vue/react/node OR 其他 笔记帖以及日常磨叨keywords: # 例如 web js vue react nodejsauthor: # 例如 mcdowelllanguage: # 例如 zh-CNtimezone: 更多详细配置 见 hexo 本地启动 12hexo g # g -&gt; generate 生成静态文件hexo s # s -&gt; server 启动项目 然后你就见到 你的 项目了 更换主题 去 hexo 官网挑选心仪主题 找到主题 github 地址 12git clone &lt;github 地址&gt; themes/&lt;主题名称&gt;#eg git clone https://github.com/blleng/hexo-theme-lx themes/lx 修改配置 _config.yml 123vim _config.yml# 修改配置theme: &lt;主题名称&gt; # eg: lx 新建文章 新建默认模版文章 1hexo new &lt;title&gt; 可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局 新建指定模版文章 12hexo new &lt;模版名称&gt; &quot;文章标题&quot;# eg: hexo new photo &quot;My Gallery&quot; 准备 github GitHub 创建个人仓库 准备 github 账号 New repository，新建仓库 创建一个和你用户名相同的仓库，后面加.github.io 只有这样，将来要部署到 GitHub page 的时候，才会被识别，也就是 xxxx.github.io，其中 xxx 就是你注册 GitHub 的用户名。 生成 SSH 添加到 GitHub 本地电脑生成 ssh 密钥 初始化 git 信息 12git config --global user.name &quot;yourname&quot;git config --global user.email &quot;youremail&quot; 生成密钥 1ssh-keygen -t rsa -C &quot;youremail&quot; 找到.ssh 下的 id_rsa.pub 文件，里面存放的就是密钥信息，可以对应添加到 github 生成的 id_rsa 是私钥 生成的 id_rsa.pub 是公钥 将 hexo 部署到 GitHub 修改配置 _config.yml 123456vim _config.yml# 修改配置deploy:type: gitrepo: https://github.com/YourgithubName/YourgithubName.github.io.git # gitub 地址branch: master 安装 deploy-git 用于部署 1npm install hexo-deployer-git --save 然后 三部曲 123456hexo clean # 清理hexo generate # 生成静态文件hexo deploy # 部署推到远端# 缩写hexo g -d # -&gt; hexo generate --deploy 然后浏览器打开 https://YourgithubName.github.io 【YourgithubName 是你的 githu 账户名称】 就可以访问了 关于留言功能 valine :[https://valine.js.org/] 为博客添加 Gitalk 评论插件 :[https://www.jianshu.com/p/78c64d07124d] 推荐相关连接 Hexo 博客常用插件及用法 GitHub+Hexo 搭建个人网站详细教程 hexo 史上最全搭建教程 相关文章 hexo博客-常见问题","categories":[{"name":"技术帖","slug":"技术帖","permalink":"http://mcdowell8023.github.io/categories/%E6%8A%80%E6%9C%AF%E5%B8%96/"}],"tags":[{"name":"hexoBlog","slug":"hexoBlog","permalink":"http://mcdowell8023.github.io/tags/hexoBlog/"}]}]}